<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     Steady&#39;blog
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  <link rel="stylesheet" href="/css/style.css">
  <script src="/js/pace.min.js"></script>

  

  

</head>

</html>

<body>
  <div id="app">
    <main class="content">
      


<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>

<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article id="post-前端性能优化-偏运维篇" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/07/28/前端性能优化-偏运维篇/">前端性能优化(偏运维篇) </a>
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2022/07/28/前端性能优化-偏运维篇/" class="article-date">
  <time datetime="2022-07-28T04:37:23.000Z" itemprop="datePublished">2022-07-28</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>#前端性能优化(偏运维篇)</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>   在日常工作中，前端和运维沟通不会太频繁，大多数时候是前端项目在测试环境、生产环境部署、CI/CD集成的时候会做一些沟通，无非就是提供一些shell ci语句，配置一下Nginx转发。<br>   但实际上遇到性能优化的时候，前端和运维两个部门有太多优化点需要一起来治理和维护。前端的性能优化会更直接与用户的体验挂钩。从用户体验侧来说，前端服务 5s 的加载时间优化缩减 80%(1s) 与后端服务 50ms 的响应优化缩减 80%(10ms) 相比，用户的体验提升会更大。因此很多时候，与体验相关的性能的瓶颈会出现在前端。<br>   面试的一个经典题目：”从用户在浏览器地址栏输入网址，到看到整个页面，中间发生了哪些事情？” 这个问题看似简单，但实际要说明白这个过程，需要较强的技术能力。在这个过程中，也包含了众多前端优化的细节点。<br>   下面就由一个前端同学的视角来展开聊聊，如何优化前端性能。</p>
<h1 id="为什么要解决性能问题"><a href="#为什么要解决性能问题" class="headerlink" title="为什么要解决性能问题"></a>为什么要解决性能问题</h1><p>几个好的案例</p>
<ol>
<li>亚马逊（美国最大电商公司）：通过调查得出，网页打开的速度每快100毫秒，就会让网站增加1%的收益</li>
<li>Pinterest（世界最大图片社交分享平台）：重建了他们的页面以实现性能优化，使感知等待时间减少了40％，从而将搜索引擎流量和注册量提高了15％</li>
<li>COOK（医疗贸易公司）：通过将平均页面加载时间减少850毫秒，发现他们能够将转化率提高7％，将跳出率降低7％</li>
</ol>
<p>从以上例子中，我们可以得出结论，网站的性能极度影响业务结果。</p>
<h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><p>  前端缓存是解决性能的一把利刃，同时也是前端bug的重灾区，运维同学如果没有设置好缓存，那么就会导致前端缓存bug。所以有必要一起来学习下前端缓存</p>
<p>  1）.强缓存 </p>
<p>  我们先看图1<br>    <img src="/images/pasted-21.png" alt="upload successful"><br>   再看图2<br>    <img src="/images/pasted-22.png" alt="upload successful"><br>    图1的缓存使用了memory cache，而图2使用了disk cache</p>
<p>   谁决定这个资源「from disk cache」与「from memory cache」？<br>   当然，最终决定使用哪种缓存的应该是客户端，也就是浏览器了。浏览器对于缓存什么策略或者机制？</p>
<p>   三级缓存原理</p>
<ul>
<li><p>先去内存看，如果有，直接加载</p>
</li>
<li><p>如果内存没有，择取硬盘获取，如果有直接加载</p>
</li>
<li><p>如果硬盘也没有，那么就进行网络请求</p>
</li>
<li><p>加载到的资源缓存到硬盘和内存</p>
<p>比如：访问静态资源=&gt; 200 =&gt; 关闭tab栏；再次访问同样一个静态资源=&gt; 200(from disk cache) =&gt; 刷新页面 =&gt; 200(from memory cache);</p>
<p>已上两种浏览器缓存，都属于强缓存类型，遵守强缓存规则</p>
<p>在强缓存的情况下，浏览器不会向服务器发送请求，而是直接从本地缓存中读取内容，这个“本地”也就是我们在 Chrome DevTools 上看到的「from disk cache」与「from memory cache」<br>与其相关的响应头则是 Expires 和 Cache-Control。在 Expires 上可以设置一个过期时间，浏览器通过将其与当前本地时间对比，判断资源是否过期，未过期则直接从本地取即可。而 Cache-Control 则可以通过给它设置一个 max-age，来控制过期时间。例如，max-age=300 就是表示在响应成功后 300 秒内，资源请求会走强缓存。<br>运维同学，需要注意前端页面html的请求，大多数情况下都是不需要设置强缓存的，那么Cache-Control需要设置为no-store。</p>
</li>
<li><p>no-cache 和 no-store 的区别</p>
<p>no-cache 和 no-store 用作控制缓存，被服务器通过响应头 Cache-Control 传递给客户端<br>no-store永远都不要在客户端存储资源，永远都去原始服务器去获取资源。<br>no-cache可以在客户端存储资源，每次都必须去服务端做新鲜度校验，来决定从服务端获取新的资源（200）还是使用客户端缓存（304）。也就是所谓的协商缓存。</p>
<p>一般情况下对于 index.html 或者现代构建环境下不加 hash 的静态资源都需要设置 Cache-Control: no-cache，用来强制每次在服务器端的新鲜度校验。甚至直接设置no-store来及时保持html的新鲜度，为了任何情况下获取html文档head标签中最新的hash静态资源。比如，对于chrome，no-cache用于在重新访问时重新加载页面，但如果您返回历史记录（后退按钮），它仍然会缓存它，不会发起网络请求。比如下图就是生产环境index.html的响应头设置<br><img src="/images/pasted-24.png" alt="upload successful"></p>
</li>
</ul>
<p>  2）.协商缓存</p>
<p>  刚才我们设置的强缓存，也有过期失效的时候。这个时候就需要通过发起请求到服务器询问一下，该资源是否有过期，如果没有过期，就可以避免发起不必要的静态资源http请求，导致用户需要等待下载完成。<br>  一种协防缓存的方式是：服务器第一次响应时返回 Last-Modified，而浏览器在后续请求时带上其值作为 If-Modified-Since，相当于问服务端：XX 时间点之后，这个资源更新了么？服务器根据实际情况回答即可：更新了（状态码 200）或没更新（状态码 304）。</p>
<p>上面是通过时间来判断是否更新，如果更新时间间隔过短，例如 1s 一下，那么使用更新时间的方式精度就不够了。所以还有一种是通过标识 —— ETag。服务器第一次响应时返回 ETag，而浏览器在后续请求时带上其值作为 If-None-Match。一般会用文件的 MD5 作为 ETag。</p>
<p>  3）.一张图看懂强缓存和协商缓存如何工作的<br><img src="/images/pasted-23.png" alt="浏览器缓存流程图"></p>
<p>  4）.总结<br> 运维同学需要熟悉缓存的设置，才能在生产环境中帮助业务提升缓存的命中，减少网络请求</p>
<h1 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h1><p>访问一个页面第一步就是检查缓存，当缓存没有命中，我们才能真正发起一个网络请求。</p>
<p>1）.HTTP 2.0</p>
<p>HTTP 2.0 相⽐于 HTTP 1.X，可以说是⼤幅度提⾼了 web 的性能。<br>在 HTTP 1.X 中，为了性能考虑，我们会引⼊雪碧图、将⼩图内联、使⽤多个域名等等的⽅<br>式。这⼀切都是因为浏览器限制了同⼀个域名下的请求数量，当⻚⾯中需要请求很多资源的<br>时候，队头阻塞（Head of line blocking）会导致在达到最⼤请求数量时，剩余的资源需要等<br>待其他资源请求完成后才能发起请求。<br>你可以通过 <a href="https://http2.akamai.com/demo" target="_blank" rel="noopener">https://http2.akamai.com/demo</a> 感受下 HTTP 2.0 ⽐ HTTP 1.X 到底快了多少。</p>
<p><img src="/images/pasted-25.png" alt="upload successful"><br>在 HTTP 1.X 中，因为队头阻塞的原因，你会发现请求是这样的</p>
<p><img src="/images/pasted-28.png" alt="upload successful"></p>
<p>在 HTTP 2.0 中，因为引⼊了多路复⽤，你会发现请求是这样的</p>
<p><img src="/images/pasted-27.png" alt="upload successful"></p>
<p>⼆进制传输<br>HTTP 2.0 中所有加强性能的核⼼点在于此。在之前的 HTTP 版本中，我们是通过⽂本的⽅式<br>传输数据。在 HTTP 2.0 中引⼊了新的编码机制，所有传输的数据都会被分割，并采⽤⼆进制<br>格式编码</p>
<p><img src="/images/pasted-29.png" alt="upload successful"></p>
<p>运维同学们看到这里，是不是已经迫不及待要开启HTTP 2.0了</p>
<p>2）.DNS预解析</p>
<p>DNS 的作⽤就是通过域名查询到具体的 IP。<br>因为 IP 存在数字和英⽂的组合（IPv6），很不利于⼈类记忆，所以就出现了域名。你可以把<br>域名看成是某个 IP 的别名，DNS 就是去查询这个别名的真正名称是什么。<br>在 TCP 握⼿之前就已经进⾏了 DNS 查询，这个查询是操作系统⾃⼰做的。当你在浏览器中<br>想访问 <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a> 时，会进⾏⼀下操作：</p>
<ol>
<li>操作系统会⾸先在本地缓存中查询</li>
<li>没有的话会去系统配置的 DNS 服务器中查询</li>
<li>如果这时候还没得话，会直接去 DNS 根服务器查询，这⼀步查询会找出负责 com 这个<br>⼀级域名的服务器</li>
<li>然后去该服务器查询 google 这个⼆级域名</li>
<li>接下来三级域名的查询其实是我们配置的，你可以给 www 这个域名配置⼀个 IP，然后还<br>可以给别的三级域名配置⼀个 IP<br>以上介绍的是 DNS 迭代查询，还有种是递归查询，区别就是前者是由客户端去做请求，后者<br>是由系统配置的 DNS 服务器做请求，得到结果后将数据返回给客户端。<br>PS：DNS 是基于 UDP 做的查询</li>
</ol>
<p>这里我们需要了解的是：</p>
<p>首先，DNS 解析流程可能会很长，耗时很高，所以整个 DNS 服务，包括客户端都会有缓存机制，这个作为前端不好涉入；<br>其次，在 DNS 解析上，前端还是可以通过浏览器提供的其他手段来“加速”的。<br><a href="https://www.w3.org/TR/resource-hints/#dns-prefetch" target="_blank" rel="noopener">DNS Prefetch</a><br>就是浏览器提供给我们的一个 API。它是 Resource Hint 的一部分。它可以告诉浏览器：过会我就可能要去 yourwebsite.com 上下载一个资源啦，帮我先解析一下域名吧。这样之后用户点击某个按钮，触发了 yourwebsite.com 域名下的远程请求时，就略去了 DNS 解析的步骤。使用方式很简单：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"dns-prefetch"</span> href=<span class="string">"//yourwebsite.com"</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>当然，浏览器并不保证一定会去解析域名，可能会根据当前的网络、负载等状况做决定。标准里也明确写了,user agent SHOULD resolve as early as possible。</p>
<p>3）.预先建立连接</p>
<p>我们知道，建立连接不仅需要 DNS 查询，还需要进行 TCP 协议握手，有些还会有 TLS/SSL 协议，这些都会导致连接的耗时。使用 Preconnect 可以帮助你告诉浏览器：“我有一些资源会用到某个源（origin），你可以帮我预先建立连接。”</p>
<p>根据规范，当你使用 Preconnect 时，浏览器大致做了如下处理：</p>
<ul>
<li>首先，解析 Preconnect 的 url；</li>
<li>其次，根据当前 link 元素中的属性进行 cors 的设置；</li>
<li>然后，默认先将 credential 设为 true，如果 cors 为 Anonymous 并且存在跨域，则将 credential 置为 false；</li>
<li>最后，进行连接。</li>
</ul>
<p>使用 Preconnect 只需要将 rel 属性设为 preconnect 即可：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"preconnect"</span> href=<span class="string">"//sample.com"</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>当然，你也可以设置 CORS：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"preconnect"</span> href=<span class="string">"//sample.com"</span> crossorigin&gt;</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，标准并没有硬性规定浏览器一定要（而是 SHOULD）完成整个连接过程，与 DNS Prefetch 类似，浏览器可以视情况完成部分工作。</p>
<p>4) .服务器应该避免过多重定向</p>
<p>重定向是一个比较常用的技术手段。在一些情况下，你可能进行了服务迁移，修改了原有的 url。这时候就可以使用重定向，把访问原网址的用户重定向到新的 url。还有是在一些登录场景下，会使用到重定向技术。</p>
<p>重定向分为 301 的永久重定向和 302 的临时重定向。建议贴合语义，例如服务迁移的情况下，使用 301 重定向。对 SEO 也会更友好。</p>
<p>运维同学需要注意在配置反向代理服务器时，不要滥用重定向。曾今也见过有业务在访问后重定向 3 次的情况，其实里面有些是不必要的。每次重定向都是有请求耗时的，建议避免过多的重定向。</p>
<p>5) .静态资源使用CDN服务</p>
<p>当我们实际把网络包发向我们的目标地址时，肯定希望越快到达目的地越好（对应的，也会希望越快获得响应）。而网络传输是有极限的，同样一个北京的用户，访问北京的服务器显然要比广州快很多。同时，服务的负载也会影响响应的速度。</p>
<p>对于静态资源，我们可以考虑通过 CDN 来降低时延。</p>
<p>对于使用 CDN 的资源，DNS 解析会将 CDN 资源的域名解析到 CDN 服务的负载均衡器上，负载均衡器可以通过请求的信息获取用户对应的地理区域，从而通过负载均衡算法，在背后的诸多服务器中，综合选择一台地理位置近、负载低的机器来提供服务。例如为北京联通用户解析北京的服务器 IP。这样，用户在之后访问 CDN 资源时都是访问北京服务器，距离近，速度快。</p>
<p>想了解更多 CDN 的工作方式可以阅读<a href="https://developer.aliyun.com/article/577708" target="_blank" rel="noopener">这篇文章</a></p>
<h1 id="BFF-amp-SSR"><a href="#BFF-amp-SSR" class="headerlink" title="BFF&amp;SSR"></a>BFF&amp;SSR</h1><p>许多大厂的组织架构都有大前端部门的存在，随着 NodeJS 的兴起，很多业务都引入了基于 NodeJS 的 BFF 来为前端（客户端端）提供服务或者是为了SEO需要使用服务器渲染框架SSR比如next.js(React)，nuxt.js(Vue)</p>
<p>1.BFF层</p>
<ul>
<li><p>Nodejs BFF 模式下，整体分工很清晰，后端通过 php,go 等语言负责服务实现，理想情况下给前端提供的是基于领域模型的 RPC 接口，前端则在 BFF 层直接调用服务端 RPC 接口拿到数据，按需加工消费数据。基于 BFF 模式的研发，很适合拥有前端技术背景的全栈型工程师。这种模式的好处很明显，后端可以专注于业务领域，更多从领域模型的视角去思考问题，页面视角的数据则交给前端型全栈工程师去搞定。领域模型与页面数据是两种思维模式，通过 BFF 可以很好地解耦开，后端的service可以在Node这层分发成多端接口(app,小程序,h5等)，省去了字段撕逼问题，让彼此更专业高效。</p>
</li>
<li><p>适合新项目孵化，类似前端小程序，用Node开发接口。1个前端人员就能搞定，节省人力成本，快速迭代上线。</p>
</li>
<li><p>Nodejs人才问题，前端会Node.js后端的人才特别多，虽然不能算专业但至少是能做业务，稍加熟悉也能成为不错的人才。类似Golang，Python基本想要招直接可用的人才，比Node.js成本高。可以让前端人员投入更多的全栈开发需求项目中，动态平衡人员紧缺问题。</p>
</li>
<li><p>Nodejs 语言的优势，由于 Node.js 遵循事件驱动的非阻塞I/O模型，与传统的后端技术相比，Node.js 能够处理大量的服务器请求，支持高并发。</p>
</li>
<li><p>服务端设计的API接口，面向通用服务，不需要面向UI。各种端的UI差异，由BFF层负责适配。这样的话，可以让后端更加专注于业务逻辑和数据服务，不需要操心各种端的差异</p>
</li>
<li><p>在toB业务需求里，很多时候前后端工作量经常匹配不到一起去，Node 增加了这中间的弹性，避免出现一个需求前端过度依赖后端开发进度的情况</p>
</li>
<li><p>原来的模式是由后端推着前端走，现在的模式是产品和前端拉着后端走，思维模式是完全不一样的。</p>
</li>
</ul>
<p>2.SSR</p>
<ul>
<li><p>Next.js 是 React 服务端渲染（SSR）应用框架. 用于构建 SEO 友好的 SPA 应用.</p>
<p>支持两种预渲染方式, 静态生成和服务器端渲染.<br>基于页面的路由系统, 路由零配置<br>自动代码拆分. 优化页面加载速度.<br>支持静态导出, 可将应用导出为静态网站.<br>内置 CSS-in-JS 库 styled-jsx<br>方案成熟, 可用于生产环境, 世界许多公司都在使用<br>应用部署简单, 拥有专属部署环境 Vercel, 也可以部署在其他环境</p>
</li>
</ul>
<ul>
<li><p>SSR预渲染概述</p>
<p>预渲染是指数据和HTML的拼接在服务器端提前完成.<br>预渲染可以使 SEO 更加友好.<br>预渲染会带来更好的用户体验, 可以无需运行 JavaScript 即可查看应用程序UI.<br>预渲染的两种形式</p>
<p>在 Next.js 中支持两种形式的预渲染: 静态生成和服务器端渲染.<br>静态生成和服务器端渲染是生成 HTML 的时机不同.<br>静态生成: 静态生成是在构建时生成 HTML. 以后的每个请求都共用构建时生成好的 HTML.<br>服务器端渲染: 服务器端渲染是在请求时生成 HTML. 每个请求都会重新生成 HTML.<br>两种预渲染方式的选择</p>
<p>Next.js 允许开发者为每个页面选择不同的预渲染方式. 不同的预渲染方式拥有不同的特点. 应根据场景进行渲染.<br>但建议大多数页面建议使用静态生成.<br>静态生成一次构建, 反复使用, 访问速度快. 因为页面都是事先生成好的.<br>适用场景：营销页面、博客文章、电子商务产品列表、帮助和文档<br>服务器端渲染访问速度不如静态生成快, 但是由于每次请求都会重新渲染, 所以适用数据频繁更新的页面或页面内容随请求变化而变化的页面</p>
</li>
</ul>
<p>以下是前端同学在写服务端时，遇到的比较常见问题,我们应该怎样快速排查Nodejs作为服务端产生的问题呢？</p>
<ul>
<li>使用中间件没有调用next()方法，导致不能执行下一个中间件，请求超时；</li>
<li>async await 的不当使用导致并行请求被串行化了；</li>
<li>频繁地 JSON.parse 和 JSON.stringify 大对象，使CPU使用率上升；</li>
<li>正则表达式的灾难性回溯，使CPU使用率上升，阻塞运算；</li>
<li>闭包导致的内存泄漏，导致内存溢出；</li>
<li>CPU 密集型任务导致事件循环 delay 严重；</li>
<li>未捕获的异常导致进程频繁退出，守护进程（pm2/supervisor）又将进程重启，频繁启停非常消耗资源；</li>
</ul>
<h2 id="利用node-clinic工具"><a href="#利用node-clinic工具" class="headerlink" title="利用node-clinic工具"></a>利用node-clinic工具</h2><p>node-clinic（简称 clinic） 是一个开箱即用的 Node.js 应用诊断工具。</p>
<p>首先，安装 Node.js@9+<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nvm install <span class="number">9</span></span><br></pre></td></tr></table></figure></p>
<p>全局安装 clinic：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm i clinic -g</span><br></pre></td></tr></table></figure></p>
<p>创建测试代码：app.js</p>
<p>使用 clinic doctor 启动并诊断 Node.js 应用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ clinic doctor -- node app.js</span><br></pre></td></tr></table></figure>
<p>使用 ab 压测：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ab -c <span class="number">10</span> -n <span class="number">200</span> <span class="string">"http://localhost:3000/"</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ clinic flame -- node app.js</span><br></pre></td></tr></table></figure>
<p>可以用以下命令代替：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ clinic flame --collect-only -- node app.js # 收集数据</span><br><span class="line">$ clinic flame --visualize-only PID.flamegraph # 将数据生成fire图</span><br></pre></td></tr></table></figure></p>
<h2 id="alinode（Node-js-性能平台）"><a href="#alinode（Node-js-性能平台）" class="headerlink" title="alinode（Node.js 性能平台）"></a>alinode（Node.js 性能平台）</h2><p>Node.js 性能平台（Node.js Performance Platform）是面向中大型 Node.js 应用提供性能监控、安全提醒、故障排查、性能优化等服务的整体性解决方案。凭借对 Node.js 内核深入的理解，我们提供完善的工具链和服务，协助客户主动、快速发现和定位线上问题。</p>
<p>推荐访问官网了解更多alinode性能平台 <a href="https://www.aliyun.com/product/nodejs" target="_blank" rel="noopener">https://www.aliyun.com/product/nodejs</a></p>
<h1 id="浏览器页面渲染"><a href="#浏览器页面渲染" class="headerlink" title="浏览器页面渲染"></a>浏览器页面渲染</h1><p>在前面的缓存章节，我们有提到对index.html的缓存，确保我们能加载正确的静态资源。我们在这个章节，开始聊聊index.html被请求回来后，是怎么触发浏览器页面渲染流程的</p>
<ul>
<li><p>浏览器的渲染机制⼀般分为以下⼏个步骤</p>
<ol>
<li>处理 HTML 并构建 DOM 树。</li>
<li>处理 CSS 构建 CSSOM 树。</li>
<li>将 DOM 与 CSSOM 合并成⼀个渲染树。</li>
<li>根据渲染树来布局，计算每个节点的位置。</li>
<li>调⽤ GPU 绘制，合成图层，显示在屏幕上。<br><img src="/images/pasted-34.png" alt="upload successful"></li>
</ol>
</li>
<li><p>标签执行顺序</p>
<p>当 HTML 解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地⽅重新开始。也就是说，如果你想⾸屏渲染的越快，就越不应该在⾸屏就加载过多JS ⽂件。并且 CSS 也会影响JS 的执⾏，只有当解析完样式表才会执⾏ JS，所以也可以认为这种情况下，CSS 也会暂停构建 DOM。</p>
<p>但是我们可以script 标签上添加defer或者async。defer 会在 HTML 解析完成后，按照脚本出现的次序再顺序执行；而 async 则是下载完成就立即开始执行，同时阻塞页面解析，不保证脚本间的执行顺序。</p>
<p>所以如果我们的页面首屏渲染慢，可以把 CSS 样式表放在 <head><meta name="generator" content="Hexo 3.8.0"> 之中（即页面的头部），把 JavaScript 脚本放在 </head><body> 的最后（即页面的尾部），还可以尝试让没那么重要的js脚本添加defer属性来避免阻塞页面解析。  </body></p>
</li>
<li><p>运维可以利用Nginx开启文档压缩</p>
<p>使用文本压缩算法（例如 gzip）进行文本的压缩</p>
<p>  <img src="/images/pasted-37.png" alt="upload successful"></p>
<p>  可以看到home这个html请求的真实资源 size是154KB,经过gzip压缩后缩减为了30KB<br>  <img src="/images/pasted-36.png" alt="upload successful"></p>
</li>
</ul>
<h1 id="页面静态资源"><a href="#页面静态资源" class="headerlink" title="页面静态资源"></a>页面静态资源</h1><p>  网页上的静态资源包括，JavaScript，css,image,font,audio,video等等，但他们的优化方向都比较相似</p>
<ul>
<li>压缩静态资源的体积大小</li>
<li>减少不必要的请求，比如对列表图片做懒加载，滚动到可视区域才发起真是的静态资源网络请求</li>
<li><p>cdn的分发加速，缓存机制</p>
<p>前端工程化，目前模块化打包，用得最多的就是webpack。webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。<br>我们可以使用webpack提供的各种plugin工具，来对我们的静态资源做优化：压缩，模块打包，Tree Shaking等等。比如，可以使用按需加载功能，尤其在当下组件化盛行的潮流里，哪些页面需要该组件才会发起一个网络请求静态资源，不会全部一次性加载完，组件的按需加载就可能会包括了 JavaScript 脚本、CSS 样式表、图标图片等。<br>对图片的优化，我们可以利用cdn提供的裁剪和格式转化功能进行页面渲染优化，比如：<a href="https://cdn.weipaitang.com/skywebp/fapai/tupian/image/20220726/77341d9a31a04681bdee06b754070b49-W3024H3024/w/320" target="_blank" rel="noopener">https://cdn.weipaitang.com/skywebp/fapai/tupian/image/20220726/77341d9a31a04681bdee06b754070b49-W3024H3024/w/320</a><br>这张图片就使用了cdn的webp格式转换，并且把3024<em>3024像素裁剪为了320</em>320尺寸，总体积压缩了50倍，极大减少了网络请求，加快了图片的展示，提高了用户体验。所以，对于其它类型的静态资源优化可以举一反三。</p>
</li>
</ul>
<p><img src="/images/pasted-43.png" alt="upload successful"></p>
<p>参考资料： <a href="https://www.webpackjs.com/" target="_blank" rel="noopener">https://www.webpackjs.com/</a></p>
<h1 id="客户端优化的案例"><a href="#客户端优化的案例" class="headerlink" title="客户端优化的案例"></a>客户端优化的案例</h1><p> 在我们电商APP日常开发中，经常会有一些分享图片给好友的需求。要求分享的图片和客户端当前展示的效果差不多。这个时候我们往往会让服务端去做一个海报服务接口，让每个用户在分享的时候调用生成海报服务接口，合成一张分享图片。这个时候我们的性能问题就出现了，如果一个活动分享的人够多，那么我们海报服务的服务器CPU占用率会直线飙升，甚至让挂掉。<br> 在2022年，我们自己手里的手机，其实已经有非常强大的算力。像这种合成图片的功能，我们实际上是可以把算力分散到客户端的，不要让请求海报服务造成瓶颈，让用户长时间等待服务端合成图片，造成非常不好的用户体验。<br> 此例子只是抛砖迎玉，提醒我们应该把此类需要大量运算的功能做到客户端中，不应该让服务器性能成为阻塞。<br><img src="/images/pasted-39.png" alt="upload successful">此图出自微拍堂APP</p>
<h1 id="为什么要做预加载"><a href="#为什么要做预加载" class="headerlink" title="为什么要做预加载"></a>为什么要做预加载</h1><ol>
<li><p>当一个项目越来越大的时候，往往会导致项目的首屏加载时间越来越长，我们可以应用 ssr，懒加载等方案来减少首屏的加载时间。</p>
<p>随之带来的问题就是非首屏会有一定的初始化时间。我们可能会应用 loading 或者骨架屏来优化加载时的体验。在混合开发中，我们希望尽可能地与原生体验接近。在不同页面间切换的时候尽可能地减少 loading 时间。</p>
<p>通过预加载资源可以减少页面切换时的等待时间。与纯页面应用有所区别的是，在纯网页应用中，一个页面就是一个进程，只包含一个 webview。而在混合开发中，我们可以借助主进程来开启多个渲染进程。对于网页来说即开启多个 webview。我们可以创建一个新的 webview 进程来加载即将打开的页面，在新的 webview 中，我们完成了页面的预加载和预渲染。在跳转的时候，通过切换 webview 的层级即可跳转到新页面。在回退页面的时候，也可以通过切换 webview 层级来回到原来的页面。</p>
<p>每次发布的时候 app 中存在一定数量的缓存 webview，所以我们在发布新项目的时候需要注意兼容旧版本的代码。</p>
<p>一般情况下 webview 的底色是白色的，但是有些页面的背景是深色的，在页面加载完之前，可能会显示 webview 的底色，通过调用 jsbridge，我们可以修改 webview 的底色。在业务页面中，我们可以配置当前页面的 webview 底色，到达渲染过程更丝滑的目的，不会出现从白屏到有底色的界面的突兀感觉。</p>
<p>具体效果可以参考微拍堂APP,从原生首页点击商品 跳转到H5商品详情页的一个体验过程。</p>
</li>
<li><p>我们在之前的网络请求章节提到DNS prefetch技术，我们的静态资源也可以有相似的预加载优化</p>
<ul>
<li><p>Prefetch</p>
<p>用于标识下一个页面可能需要的资源，以及浏览器端应获取的资源，以便浏览器端可以在将来请求资源时提供更快的响应。由于仅仅是提前获取资源，因此浏览器不会对资源进行预处理，像 CSS 样式表、JavaScript 脚本这样的资源是不会自动执行并应用于当前文档的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"prefetch"</span> href=<span class="string">"/prefetch.js"</span> <span class="keyword">as</span>=<span class="string">"script"</span>&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>Prerender</p>
<p>用于标识下一个页面可能需要的资源，以及浏览器端应获取的资源，以便浏览器端可以在将来请求资源时提供更快的响应，同Prefetch不一样的点在于Prerender还会执行该资源。指定浏览器应该在后台预呈现(加载)指定的网页。因此，如果用户访问到这个页面，它会加速页面加载(因为页面已经加载了)。警告!这浪费了用户的带宽!只有在你绝对确定网页在用户旅途中的某个时刻是必需的时候才使用预渲染</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"prerender"</span> href=<span class="string">"//sample.com/nextpage.html"</span>&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>Preload</p>
<p>指定浏览器必须根据“as”属性给出的类型(以及与该类型关联的优先级)抢先获取和缓存指定的目标资源。同Prefetch的区别在于，Preload优先级更高。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"preload"</span> href=<span class="string">"./nextpage.js"</span> <span class="keyword">as</span>=<span class="string">"script"</span>&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Prefetch 和 Preload 区别 ？</p>
<ul>
<li>preload chunk 会在父 chunk 加载时，以并行方式开始加载。prefetch chunk 会在父 chunk 加载结束后开始加载。</li>
<li>preload chunk 具有中等优先级，并立即下载。prefetch chunk 在浏览器闲置时下载。</li>
<li>preload chunk 会在父 chunk 中立即请求，用于当下时刻。prefetch chunk 会用于未来的某个时刻。</li>
<li>浏览器支持程度不同。</li>
</ul>
</li>
</ul>
<pre><code>参考资料：https://www.w3.org/TR/resource-hints/，https://www.w3schools.com/tags/att_link_rel.asp
</code></pre><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>   前端的性能指标，现在有非常多的工具可以进行统计，浏览器也提供了Performance方法来检测页面性能的能力，完全可以自主开发一套前端性能监控平台。在这里推荐Google的一个网页性能分析工具pagespeed，输入<a href="https://pagespeed.web.dev/" target="_blank" rel="noopener">https://pagespeed.web.dev/</a>, 进入页面，输入想要分析的网址稍等片刻，便会有需要详细的分析，比如：网页的LCP,FID,CLS,FCP,INP,TTFB等指标</p>
<p><img src="/images/pasted-40.png" alt="upload successful"></p>
<p>并且还能给出网页的一个性能分析评分</p>
<p><img src="/images/pasted-41.png" alt="upload successful"></p>
<p>还能给出一些优化建议</p>
<p><img src="/images/pasted-42.png" alt="upload successful"></p>
<p>   最后，希望运维小伙伴们在阅读了《前端性能优化(偏运维篇)》后对前端的性能优化有更深入的了解</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-正则表达式" class="article article-type-post" itemscope="" itemprop="blogPost" data-scroll-reveal="">

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/02/21/正则表达式/">常用正则</a>
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2022/02/21/正则表达式/" class="article-date">
  <time datetime="2022-02-21T06:59:09.000Z" itemprop="datePublished">2022-02-21</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>今天胖头鱼试着把前端面试中常见的正则表达式相关的题都捞一遍，希望以后正则这个点直接过<br>1.提取连续重复的字符<br>币安原题 将有重复的字符提取出来，例如12323454545666，提取[ ‘23’, ‘45’, ‘6’ ]<br>正则结果</p>
<p>const collectRepeatStr = (str) =&gt; {<br>  let repeatStrs = []<br>  const repeatRe = /(.+)\1+/g</p>
<p>  str.replace(repeatRe, ($0, $1) =&gt; {<br>    $1 &amp;&amp; repeatStrs.push($1)<br>  })</p>
<p>  return repeatStrs<br>}</p>
<p>分析过程</p>
<p>题目中有几个关键信息是<br>连续重复的字符<br>连续重复的字符数的长度是不限的（如23、45是两位、6是一位）<br>那什么是连续重复呢？<br>11是连续重复、22也是连续重复、111当然也是。也就是说某些字符X之后一定也是跟着X，就叫连续重复。如果很明确知道X就是1，那么/11+/也就可以匹配了，但关键是这里的X是不明确的，怎么办呢？。<br>使用反向引用的正则知识可以很方便解决这个问题。<br>第一步，写出表示有一个字符重复的正则<br>// 这里的X可用.来表示，即所有的字符，并用括号进行引用，紧跟着反向应用\1，也就是体现了连续重复的意思啦<br>let repeatRe = /(.)\1/</p>
<p>console.log(repeatRe.test(‘11’)) // true<br>console.log(repeatRe.test(‘22’)) // true<br>console.log(repeatRe.test(‘333’)) // true<br>console.log(repeatRe.test(‘123’)) // false</p>
<p>第二步，写出表示有n个字符重复的正则<br>因为并不确定是要匹配11还是45 45所以括号内需要用量词+来体现n个重复字符，而反向引用本身也可以是大于一个的，例如 45 45 45</p>
<p>let repeatRe = /(.+)\1+/</p>
<p>console.log(repeatRe.test(‘11’)) // true<br>console.log(repeatRe.test(‘22’)) // true<br>console.log(repeatRe.test(‘333’)) // true<br>console.log(repeatRe.test(‘454545’)) // true<br>console.log(repeatRe.test(‘124’)) // false</p>
<p>第三步，提取所有连续重复的字符</p>
<p>const collectRepeatStr = (str) =&gt; {<br>  let repeatStrs = []<br>  const repeatRe = /(.+)\1+/g<br>  // 很多时候replace并不是用来做替换，而是做数据提取用<br>  str.replace(repeatRe, ($0, $1) =&gt; {<br>    $1 &amp;&amp; repeatStrs.push($1)<br>  })</p>
<p>  return repeatStrs<br>}</p>
<p>console.log(collectRepeatStr(‘11’)) // [“1”]<br>console.log(collectRepeatStr(‘12323’)) // [“23”]<br>console.log(collectRepeatStr(‘12323454545666’)) // [“23”, “45”, “6”]</p>
<ol start="2">
<li>实现一个trim函数<br>老生常谈的题了，这里我们用两种思路实现 去除字符串的首尾空格<br>正则结果</li>
</ol>
<p>// 去除空格法<br>const trim = (str) =&gt; {<br>  return str.replace(/^\s<em>|\s</em>$/g, ‘’)<br>}<br>// 提取非空格法<br>const trim = (str) =&gt; {<br>  return str.replace(/^\s<em>(.</em>?)\s*$/g, ‘$1’)<br>}</p>
<p>图片</p>
<p><img src="/images/pasted-13.png" alt="upload successful"><br>图片</p>
<p><img src="/images/pasted-14.png" alt="upload successful"><br>分析过程</p>
<p>初看题目我们脑海中闪过的做法是把空格部分删除掉，保留非空格的部分，但是也可以换一种思路，也可以把非空格的部分提取出来，不管空格的部分。接下来我们来写一下两种trim方法的实现<br>方式一、去除空格法</p>
<p>const trim = (str) =&gt; {<br>  return str.replace(/^\s<em>|\s</em>$/g, ‘’)<br>}</p>
<p>console.log(trim(‘  前端胖头鱼’)) // 前端胖头鱼<br>console.log(trim(‘前端胖头鱼  ‘)) // 前端胖头鱼<br>console.log(trim(‘  前端胖头鱼  ‘)) // 前端胖头鱼<br>console.log(trim(‘  前端 胖头鱼  ‘)) // 前端 胖头鱼</p>
<p>方式二、提取非空格法</p>
<p>const trim = (str) =&gt; {<br>  return str.replace(/^\s<em>(.</em>?)\s*$/g, ‘$1’)<br>}</p>
<p>console.log(trim(‘  前端胖头鱼’)) // 前端胖头鱼<br>console.log(trim(‘前端胖头鱼  ‘)) // 前端胖头鱼<br>console.log(trim(‘  前端胖头鱼  ‘)) // 前端胖头鱼<br>console.log(trim(‘  前端 胖头鱼  ‘)) // 前端 胖头鱼</p>
<ol start="3">
<li>数字价格千分位分割<br>将123456789变成123,456,789<br>这道题估计大家在面试和工作中也经常遇到，出现频率比较高。<br>正则结果</li>
</ol>
<p>‘123456789’.replace(/(?!^)(?=(\d{3})+$)/g, ‘,’) // 123,456,789<br>图片</p>
<p><img src="/images/pasted-15.png" alt="upload successful"><br>补充小数千分位支持<br>图片</p>
<p><img src="/images/pasted-16.png" alt="upload successful"><br>分析过程</p>
<p>题目意思大概是：<br>从后往前每三个数字前加一个逗号<br>开头不能加逗号(比如：123 最后不能变成,123)<br>是不是很符合(?=p)的规律呢？p可以表示每三个数字，要添加的逗号所处的位置正好是(?=p)匹配出来的位置。<br>第一步，尝试先把后面第一个逗号弄出来</p>
<p>let price = ‘123456789’<br>let priceReg = /(?=\d{3}$)/</p>
<p>console.log(price.replace(proceReg, ‘,’)) // 123456,789<br>第二步，把所有的逗号都弄出来<br>要把所有的逗号都弄出来，主要要解决的问题是怎么表示三个数字一组,也就是3的倍数。我们知道正则中括号可以把一个p模式变成一个小整体，所以利用括号的特性，可以这样写</p>
<p>let price = ‘123456789’<br>let priceReg = /(?=(\d{3})+$)/g</p>
<p>console.log(price.replace(priceReg, ‘,’)) // ,123,456,789</p>
<p>第三步，去掉首位的逗号，<br>上面已经基本上实现需求了，但是还不够，首位还会出现逗号，那怎么把首位的逗号去除呢？想想是不是有一个知识正好满足这个场景？没错(?!p)，就是他了，两者结合就是从后往前每三个数字的位置前添加逗号，但是这个位置不能是^首位。</p>
<p>let price = ‘123456789’<br>let priceReg = /(?!^)(?=(\d{3})+$)/g</p>
<p>console.log(price.replace(priceReg, ‘,’)) // 123,456,789</p>
<ol start="4">
<li>手机号3-4-4分割<br>将手机号18379836654转化为183-7983-6654<br>表单搜集场景，经常遇到的手机格式化<br>正则结果</li>
</ol>
<p>let mobile = ‘18379836654’<br>let mobileReg = /(?=(\d{4})+$)/g </p>
<p>console.log(mobile.replace(mobileReg, ‘-‘)) // 183-7983-6654</p>
<p>图片</p>
<p><img src="/images/pasted-17.png" alt="upload successful"><br>分析过程</p>
<p>有了上面数字的千分位分割法，做这个题相信会简单很多，也就是从后往前找到这样的位置：<br>每四个数字前的位置，并把这个位置替换为-</p>
<p>let mobile = ‘18379836654’<br>let mobileReg = /(?=(\d{4})+$)/g</p>
<p>console.log(mobile.replace(mobileReg, ‘-‘)) // 183-7983-6654</p>
<ol start="5">
<li>将字符串驼峰化<br>如下规则，将对应字符串变成驼峰写法</li>
<li><p>foo Bar =&gt; fooBar</p>
</li>
<li><p>foo-bar—- =&gt; fooBar</p>
</li>
<li><p>foo_bar__ =&gt; fooBar</p>
</li>
</ol>
<p>正则结果</p>
<p>const camelCase = (string) =&gt; {<br>  const camelCaseRegex = /[-_\s]+(.)?/g</p>
<p>  return string.replace(camelCaseRegex, (match, char) =&gt; {<br>    return char ? char.toUpperCase() : ‘’<br>  })<br>}</p>
<p>图片</p>
<p><img src="/images/pasted-18.png" alt="upload successful"><br>分析过程</p>
<p>分析题目的规律<br>每个单词的前面都有0个或者多个- 空格 _ 如(Foo、–foo、__FOO、_BAR、Bar)</p>
<ul>
<li><p>空格 <em>后面有可能不跟任何东西 如(__、–)<br>const camelCase = (string) =&gt; {<br>// 注意(.)?这里的?是为了满足条件2<br>const camelCaseRegex = /[-</em>\s]+(.)?/g</p>
<p>return string.replace(camelCaseRegex, (match, char) =&gt; {<br>  return char ? char.toUpperCase() : ‘’<br>})<br>}</p>
</li>
</ul>
<p>console.log(camelCase(‘foo Bar’)) // fooBar<br>console.log(camelCase(‘foo-bar–’)) // fooBar<br>console.log(camelCase(‘foo_bar__’)) // fooBar</p>
<ol start="6">
<li>将字符串首字母转化为大写，剩下为小写<br>例如 hello world 转为为Hello World<br>正则结果</li>
</ol>
<p>const capitalize = (string) =&gt; {<br>  const capitalizeRegex = /(?:^|\s+)\w/g</p>
<p>  return string.toLowerCase().replace(capitalizeRegex, (match) =&gt; match.toUpperCase())<br>}</p>
<p><img src="/images/pasted-12.png" alt="upload successful"></p>
<p>找到单词的首字母然后将其转化为大写字母就可以，单词前面可能是开头也可能是多个空格。</p>
<p>const capitalize = (string) =&gt; {<br>  const capitalizeRegex = /(?:^|\s+)\w/g</p>
<p>  return string.toLowerCase().replace(capitalizeRegex, (match) =&gt; match.toUpperCase())<br>}</p>
<p>console.log(capitalize(‘hello world’)) // Hello World<br>console.log(capitalize(‘hello WORLD’)) // Hello World</p>
<p>7.通过name获取url query参数<br>正则结果</p>
<p>const getQueryByName = (name) =&gt; {<br>  const queryNameRegex = new RegExp(<code>[?&amp;]${name}=([^&amp;]*)(&amp;|$)</code>)<br>  const queryNameMatch = window.location.search.match(queryNameRegex)<br>  // 一般都会通过decodeURIComponent解码处理<br>  return queryNameMatch ? decodeURIComponent(queryNameMatch[1]) : ‘’<br>}</p>
<p>分析过程</p>
<p>url query上的参数 name=前端胖头鱼 所处的位置可能是<br>紧跟着问号 ?name=前端胖头鱼&amp;sex=boy<br>在最后的位置 ?sex=boy&amp;name=前端胖头鱼<br>在1和2之间 ?sex=boy&amp;name=前端胖头鱼&amp;age=100<br>所以只要处理三个地方基本就可以通过正则来取了<br>name前面只能是?或者&amp;<br>value的值可以除了是&amp;以为的任意东西<br>value后面只能是跟着&amp;或者是结束位置</p>
<p>const getQueryByName = (name) =&gt; {<br>  const queryNameRegex = new RegExp(<code>[?&amp;]${name}=([^&amp;]*)(?:&amp;|$)</code>)<br>  const queryNameMatch = window.location.search.match(queryNameRegex)<br>  // 一般都会通过decodeURIComponent解码处理<br>  return queryNameMatch ? decodeURIComponent(queryNameMatch[1]) : ‘’<br>}<br>// 1. name在最前面<br>// <a href="https://juejin.cn/?name=前端胖头鱼&amp;sex=boy" target="_blank" rel="noopener">https://juejin.cn/?name=前端胖头鱼&amp;sex=boy</a><br>console.log(getQueryByName(‘name’)) // 前端胖头鱼</p>
<p>// 2. name在最后<br>// <a href="https://juejin.cn/?sex=boy&amp;name=前端胖头鱼" target="_blank" rel="noopener">https://juejin.cn/?sex=boy&amp;name=前端胖头鱼</a><br>console.log(getQueryByName(‘name’)) // 前端胖头鱼</p>
<p>// 2. name在中间<br>// <a href="https://juejin.cn/?sex=boy&amp;name=前端胖头鱼&amp;age=100" target="_blank" rel="noopener">https://juejin.cn/?sex=boy&amp;name=前端胖头鱼&amp;age=100</a><br>console.log(getQueryByName(‘name’)) // 前端胖头鱼</p>
<p>与其他语言中的正则表达式类似，模式中使用的所有元字符都必须转义。正则表达式中的元字符包括：</p>
<h1 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h1><p>( [ { \ ^ $ | ) ? * + .] }<br>这些元字符在正则表达式中都有一或多种特殊用途，因此如果想要匹配字符串中包含的这些字符，就必须对它们进行转义。</p>
<p>// 匹配 .docx<br>var exp = /.docx/gi ;</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-git操作" class="article article-type-post" itemscope="" itemprop="blogPost" data-scroll-reveal="">

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/11/02/git操作/">git操作</a>
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2021/11/02/git操作/" class="article-date">
  <time datetime="2021-11-02T12:10:57.000Z" itemprop="datePublished">2021-11-02</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h1><p>在 Git 开发中通常会控制主干分支的质量，但有时还是会把错误的代码合入到远程主干。 虽然可以直接回滚远程分支， 但有时新的代码也已经合入，直接回滚后最近的提交都要重新操作。 那么有没有只移除某些 Commit 的方式呢？可以一次 revert操作来完成。</p>
<p>考虑这个例子，我们提交了 6 个版本，其中 3-4 包含了错误的代码需要被回滚掉。 同时希望不影响到后续的 5-6。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* 982d4f6 (HEAD -&gt; master) version 6</span><br><span class="line">* 54cc9dc version 5</span><br><span class="line">* 551c408 version 4, harttle screwed it up again</span><br><span class="line">* 7e345c9 version 3, harttle screwed it up</span><br><span class="line">* f7742cd version 2</span><br><span class="line">* 6c4db3f version 1</span><br></pre></td></tr></table></figure></p>
<p>这种情况在团队协作的开发中会很常见：可能是流程或认为原因不小心合入了错误的代码， 也可能是合入一段时间后才发现存在问题。 总之已经存在后续提交，使得直接回滚不太现实。</p>
<p>下面的部分就开始介绍具体操作了，同时我们假设远程分支是受保护的（不允许 Force Push）。 思路是从产生一个新的 Commit 撤销之前的错误提交。</p>
<p>使用 git revert <commit> 可以撤销指定的提交， 要撤销一串提交可以用 <commit1>..<commit2> 语法。 注意这是一个前开后闭区间，即不包括 commit1，但包括 commit2。</commit2></commit1></commit></p>
<p>git revert –no-commit f7742cd..551c408<br>git commit -a -m ‘This reverts commit 7e345c9 and 551c408’<br>其中 f7742cd 是 version 2，551c408 是 version 4，这样被移除的是 version 3 和 version 4。 注意 revert 命令会对每个撤销的 commit 进行一次提交，–no-commit 后可以最后一起手动提交。</p>
<p>此时 Git 记录是这样的：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* 8fef80a (HEAD -&gt; master) This reverts commit 7e345c9 and 551c408</span><br><span class="line">* 982d4f6 version 6</span><br><span class="line">* 54cc9dc version 5</span><br><span class="line">* 551c408 version 4, harttle screwed it up again</span><br><span class="line">* 7e345c9 version 3, harttle screwed it up</span><br><span class="line">* f7742cd version 2</span><br><span class="line">* 6c4db3f version 1</span><br></pre></td></tr></table></figure></p>
<p>现在的 HEAD（8fef80a）就是我们想要的版本，把它 Push 到远程即可。</p>
<p>确认 diff<br>如果你像不确定是否符合预期，毕竟批量干掉了别人一堆 Commit，可以做一下 diff 来确认。 首先产生 version 4（551c408）与 version 6（982d4f6）的 diff，这些是我们想要保留的：</p>
<p>git diff 551c408..982d4f6<br>然后再产生 version 2（f7742cd）与当前状态（HEAD）的 diff：</p>
<p>git diff f7742cd..HEAD<br>如果 version 3, version 4 都被 version 6 撤销的话，上述两个 diff 为空。 可以人工确认一下，或者 grep 掉 description 之后做一次 diff。 下面介绍的另一种方法可以容易地确认 diff。</p>
<p>示例</p>
<p>bd1b80cb 和0f2f7e4a 是错误的提交可以通过git revert bd1b80cb 0f2f7e4a 来进行单独提交的回滚</p>
<h1 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h1><p>重新复习，这个变基线命令，很多公司是不允许提交代码的时候变基的，但我们公司例外，在提交pr的时候需要执行变基操作，原因？</p>
<ul>
<li>git checkout master</li>
<li>git pull origin master –rebase</li>
<li>git checkout currentBranch</li>
<li>git rebase master    //这一步就是在执行变基操作，但在这之前会执行一个操作，就是找到同master分支相同的commit号，然后整理commit：git reset –soft xxxxhash</li>
</ul>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-useragent" class="article article-type-post" itemscope="" itemprop="blogPost" data-scroll-reveal="">

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/07/09/useragent/">User-agent</a>
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2021/07/09/useragent/" class="article-date">
  <time datetime="2021-07-09T06:54:58.000Z" itemprop="datePublished">2021-07-09</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>User-agent</p>
<p>iOS</p>
<p>iOS环境下，小程序原生和微信公众号H5的UA一致，无法通过UA对环境进行区分。小程序内的H5页面可通过miniProgram来判断。app中区分全屏页面和弹窗两种内嵌H5的场景，modalWebview为true为弹窗模式，否则则为全屏页面模式。wptFullScreen可理解为是否需要navigate-bar</p>
<p>小程序原生：<br>Mozilla/5.0 (iPhone; CPU iPhone OS 13_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Mobile/15E148 MicroMessenger/8.0.6(0x18000633) NetType/WIFI Language/zh_CN</p>
<p>小程序内H5:<br>Mozilla/5.0 (iPhone; CPU iPhone OS 13_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Mobile/15E148 MicroMessenger/8.0.6(0x18000633) NetType/WIFI Language/zh_CN miniProgram</p>
<p>公众号H5：<br>Mozilla/5.0 (iPhone; CPU iPhone OS 13_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Mobile/15E148 MicroMessenger/8.0.6(0x18000633) NetType/4G Language/zh_CN</p>
<p>iOS原生：<br>NetType/ Language/zh_CN WptMessenger/4.5.8 DeviceId/78CCE389-7C9E-409D-825F-A886305A5591 Idfa/78CCE389-7C9E-409D-825F-A886305A5591 Uuid/46D4AFCD-C7DA-4529-8278-68CF6E7E5F96 Channel/default OS/iOS Ar/1 PhoneModel/iPhone11 ver/13.6 wptAid/default identity/c7c64ba3176686ce86fbf1d3e90797e9 secretKey/secretKey wifiName/d3B0LW1hYzIwMTg=</p>
<p>安卓：<br>安卓环境下，小程序原生比公众号H5多一个MiniProgramEnv/android的标示，可用于区分是小程序还是公众号H5。小程序内H5同ios，可通过miniProgram进行判断。app中区分全屏页面和弹窗两种内嵌H5的场景，modalWebview为true为弹窗模式，wptfullscreen为true则为全屏页面模式，statusBarHeight用于statusBar高度。</p>
<p>小程序原生：<br>Mozilla/5.0 (Linux; Android 10; EML-AL00 Build/HUAWEIEML-AL00; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/78.0.3904.62 XWEB/2853 MMWEBSDK/20210501 Mobile Safari/537.36 MMWEBID/9235 MicroMessenger/8.0.6.1900(0x28000651) Process/appbrand0 WeChat/arm64 Weixin NetType/WIFI Language/zh_CN ABI/arm64 MiniProgramEnv/android</p>
<p>小程序内H5:<br>Mozilla/5.0 (Linux; Android 10; EML-AL00 Build/HUAWEIEML-AL00; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/78.0.3904.62 XWEB/2853 MMWEBSDK/20210501 Mobile Safari/537.36 MMWEBID/9235 MicroMessenger/8.0.6.1900(0x28000651) Process/appbrand0 WeChat/arm64 Weixin NetType/WIFI Language/zh_CN ABI/arm64 miniProgram</p>
<p>H5：<br>Mozilla/5.0 (Linux; Android 10; EML-AL00 Build/HUAWEIEML-AL00; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/77.0.3865.120 MQQBrowser/6.2 TBS/045617 Mobile Safari/537.36 MMWEBID/9235 MicroMessenger/8.0.6.1900(0x28000651) Process/tools WeChat/arm64 Weixin NetType/WIFI Language/zh_CN ABI/arm64</p>
<p>安卓原生：<br>NetType/NETWORK_WIFI Language/zh_CN WptMessenger/4.5.9 Channel/wpt DeviceId/fe717b86a4c04380 DeviceIdType/androidId os/android oVersion/10 cVersion/4.5.9 ua/EML-AL00 brand/HUAWEI Ar/1 wifiName/d3B0LW1hYzIwMTg= secretKey/secretKey oaid/d42edfa5-f5ff-0186-fd47-ff9ffa65dbae androidId/fe717b86a4c04380</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-手写promise" class="article article-type-post" itemscope="" itemprop="blogPost" data-scroll-reveal="">

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/04/02/手写promise/">手写promise</a>
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2021/04/02/手写promise/" class="article-date">
  <time datetime="2021-04-02T02:40:44.000Z" itemprop="datePublished">2021-04-02</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 先定义三个常量表示状态</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'pending'</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">'fulfilled'</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'rejected'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建 MyPromise 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(executor)&#123;</span><br><span class="line">    <span class="comment">// executor 是一个执行器，进入会立即执行</span></span><br><span class="line">    <span class="comment">// 并传入resolve和reject方法</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      executor(<span class="keyword">this</span>.resolve, <span class="keyword">this</span>.reject)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="keyword">this</span>.reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 储存状态的变量，初始值是 pending</span></span><br><span class="line">  status = PENDING;</span><br><span class="line">  <span class="comment">// 成功之后的值</span></span><br><span class="line">  value = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 失败之后的原因</span></span><br><span class="line">  reason = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存储成功回调函数</span></span><br><span class="line">  onFulfilledCallbacks = [];</span><br><span class="line">  <span class="comment">// 存储失败回调函数</span></span><br><span class="line">  onRejectedCallbacks = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更改成功后的状态</span></span><br><span class="line">  resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 只有状态是等待，才执行状态修改</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.status === PENDING) &#123;</span><br><span class="line">      <span class="comment">// 状态修改为成功</span></span><br><span class="line">      <span class="keyword">this</span>.status = FULFILLED;</span><br><span class="line">      <span class="comment">// 保存成功之后的值</span></span><br><span class="line">      <span class="keyword">this</span>.value = value;</span><br><span class="line">      <span class="comment">// resolve里面将所有成功的回调拿出来执行</span></span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">this</span>.onFulfilledCallbacks.length) &#123;</span><br><span class="line">        <span class="comment">// Array.shift() 取出数组第一个元素，然后（）调用，shift不是纯函数，取出后，数组将失去该元素，直到数组为空</span></span><br><span class="line">        <span class="keyword">this</span>.onFulfilledCallbacks.shift()(value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更改失败后的状态</span></span><br><span class="line">  reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 只有状态是等待，才执行状态修改</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.status === PENDING) &#123;</span><br><span class="line">      <span class="comment">// 状态成功为失败</span></span><br><span class="line">      <span class="keyword">this</span>.status = REJECTED;</span><br><span class="line">      <span class="comment">// 保存失败后的原因</span></span><br><span class="line">      <span class="keyword">this</span>.reason = reason;</span><br><span class="line">      <span class="comment">// resolve里面将所有失败的回调拿出来执行</span></span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">this</span>.onRejectedCallbacks.length) &#123;</span><br><span class="line">        <span class="keyword">this</span>.onRejectedCallbacks.shift()(reason)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  then(onFulfilled, onRejected) &#123;</span><br><span class="line">    <span class="keyword">const</span> realOnFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line">    <span class="keyword">const</span> realOnRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> ? onRejected : <span class="function"><span class="params">reason</span> =&gt;</span> &#123;<span class="keyword">throw</span> reason&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了链式调用这里直接创建一个 MyPromise，并在后面 return 出去</span></span><br><span class="line">    <span class="keyword">const</span> promise2 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> fulfilledMicrotask = <span class="function"><span class="params">()</span> =&gt;</span>  &#123;</span><br><span class="line">        <span class="comment">// 创建一个微任务等待 promise2 完成初始化</span></span><br><span class="line">        queueMicrotask(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取成功回调函数的执行结果</span></span><br><span class="line">            <span class="keyword">const</span> x = realOnFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">            <span class="comment">// 传入 resolvePromise 集中处理</span></span><br><span class="line">            resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            reject(error)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> rejectedMicrotask = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个微任务等待 promise2 完成初始化</span></span><br><span class="line">        queueMicrotask(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用失败回调，并且把原因返回</span></span><br><span class="line">            <span class="keyword">const</span> x = realOnRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">            <span class="comment">// 传入 resolvePromise 集中处理</span></span><br><span class="line">            resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            reject(error)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 判断状态</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === FULFILLED) &#123;</span><br><span class="line">        fulfilledMicrotask()</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.status === REJECTED) &#123;</span><br><span class="line">        rejectedMicrotask()</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.status === PENDING) &#123;</span><br><span class="line">        <span class="comment">// 等待</span></span><br><span class="line">        <span class="comment">// 因为不知道后面状态的变化情况，所以将成功回调和失败回调存储起来</span></span><br><span class="line">        <span class="comment">// 等到执行成功失败函数的时候再传递</span></span><br><span class="line">        <span class="keyword">this</span>.onFulfilledCallbacks.push(fulfilledMicrotask);</span><br><span class="line">        <span class="keyword">this</span>.onRejectedCallbacks.push(rejectedMicrotask);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> promise2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// resolve 静态方法</span></span><br><span class="line">  <span class="keyword">static</span> resolve (parameter) &#123;</span><br><span class="line">    <span class="comment">// 如果传入 MyPromise 就直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (parameter <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">      <span class="keyword">return</span> parameter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转成常规方式</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="params">resolve</span> =&gt;</span>  &#123;</span><br><span class="line">      resolve(parameter);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// reject 静态方法</span></span><br><span class="line">  <span class="keyword">static</span> reject (reason) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      reject(reason);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果相等了，说明return的是自己，抛出类型错误并返回</span></span><br><span class="line">  <span class="keyword">if</span> (promise2 === x) &#123;</span><br><span class="line">    <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Chaining cycle detected for promise #&lt;Promise&gt;'</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断x是不是 MyPromise 实例对象</span></span><br><span class="line">  <span class="keyword">if</span>(x <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">    <span class="comment">// 执行 x，调用 then 方法，目的是将其状态变为 fulfilled 或者 rejected</span></span><br><span class="line">    <span class="comment">// x.then(value =&gt; resolve(value), reason =&gt; reject(reason))</span></span><br><span class="line">    <span class="comment">// 简化之后</span></span><br><span class="line">    x.then(resolve, reject)</span><br><span class="line">  &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">// 普通值</span></span><br><span class="line">    resolve(x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = MyPromise;</span><br></pre></td></tr></table></figure>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-关系数据库和非关系数据库的-区别" class="article article-type-post" itemscope="" itemprop="blogPost" data-scroll-reveal="">

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/03/06/关系数据库和非关系数据库的-区别/">SQL 和 NoSQL 的区别</a>
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2021/03/06/关系数据库和非关系数据库的-区别/" class="article-date">
  <time datetime="2021-03-06T00:26:11.000Z" itemprop="datePublished">2021-03-06</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="SQL-和-NoSQL-的区别"><a href="#SQL-和-NoSQL-的区别" class="headerlink" title="SQL 和 NoSQL 的区别"></a>SQL 和 NoSQL 的区别</h1><h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><p>　　SQL (Structured Query Language) 数据库，指关系型数据库。主要代表：SQL Server，Oracle，MySQL(开源)，PostgreSQL(开源)。</p>
<p>　　NoSQL（Not Only SQL）泛指非关系型数据库。主要代表：MongoDB，Redis，CouchDB。</p>
<h2 id="二、区别"><a href="#二、区别" class="headerlink" title="二、区别"></a>二、区别</h2><p>1、存储方式</p>
<p>　　SQL数据存在特定结构的表中；而NoSQL则更加灵活和可扩展，存储方式可以省是JSON文档、哈希表或者其他方式。SQL通常以数据库表形式存储数据。举个栗子，存个学生借书数据：</p>
<p>而NoSQL存储方式比较灵活，比如使用类JSON文件存储上表中熊大的借阅数据：</p>
<p>2、表/数据集合的数据的关系</p>
<p>　　在SQL中，必须定义好表和字段结构后才能添加数据，例如定义表的主键(primary key)，索引(index),触发器(trigger),存储过程(stored procedure)等。表结构可以在被定义之后更新，但是如果有比较大的结构变更的话就会变得比较复杂。在NoSQL中，数据可以在任何时候任何地方添加，不需要先定义表。例如下面这段代码会自动创建一个新的”借阅表”数据集合：</p>
<p>NoSQL也可以在数据集中建立索引。以MongoDB为例，会自动在数据集合创建后创建唯一值_id字段，这样的话就可以在数据集创建后增加索引。</p>
<p>从这点来看，NoSQL可能更加适合初始化数据还不明确或者未定的项目中。</p>
<p>3、外部数据存储</p>
<p>　　SQL中如何需要增加外部关联数据的话，规范化做法是在原表中增加一个外键，关联外部数据表。例如需要在借阅表中增加审核人信息，先建立一个审核人表：</p>
<p>再在原来的借阅人表中增加审核人外键：</p>
<p>这样如果我们需要更新审核人个人信息的时候只需要更新审核人表而不需要对借阅人表做更新。而在NoSQL中除了这种规范化的外部数据表做法以外，我们还能用如下的非规范化方式把外部数据直接放到原数据集中，以提高查询效率。缺点也比较明显，更新审核人数据的时候将会比较麻烦。</p>
<p>4、SQL中的JOIN查询</p>
<p>　　SQL中可以使用JOIN表链接方式将多个关系数据表中的数据用一条简单的查询语句查询出来。NoSQL暂未提供类似JOIN的查询方式对多个数据集中的数据做查询。所以大部分NoSQL使用非规范化的数据存储方式存储数据。</p>
<p>5、数据耦合性</p>
<p>　　SQL中不允许删除已经被使用的外部数据，例如审核人表中的”熊三”已经被分配给了借阅人熊大，那么在审核人表中将不允许删除熊三这条数据，以保证数据完整性。而NoSQL中则没有这种强耦合的概念，可以随时删除任何数据。</p>
<p>6、事务</p>
<p>　　SQL中如果多张表数据需要同批次被更新，即如果其中一张表更新失败的话其他表也不能更新成功。这种场景可以通过事务来控制，可以在所有命令完成后再统一提交事务。而NoSQL中没有事务这个概念，每一个数据集的操作都是原子级的。</p>
<p>7、增删改查语法</p>
<p>8、查询性能</p>
<p>　　在相同水平的系统设计的前提下，因为NoSQL中省略了JOIN查询的消耗，故理论上性能上是优于SQL的。</p>
<h2 id="三、补充"><a href="#三、补充" class="headerlink" title="三、补充"></a>三、补充</h2><p>　　目前许多大型互联网项目都会选用MySQL（或任何关系型数据库） + NoSQL的组合方案。</p>
<p>关系型数据库适合存储结构化数据，如用户的帐号、地址：</p>
<p>　　1）这些数据通常需要做结构化查询（嗯，好像是废话），比如join，这时候，关系型数据库就要胜出一筹</p>
<p>　　2）这些数据的规模、增长的速度通常是可以预期的</p>
<p>　　3）事务性、一致性</p>
<p>NoSQL适合存储非结构化数据，如文章、评论：</p>
<p>　　1）这些数据通常用于模糊处理，如全文搜索、机器学习</p>
<p>　　2）这些数据是海量的，而且增长的速度是难以预期的，</p>
<p>　　3）根据数据的特点，NoSQL数据库通常具有无限（至少接近）伸缩性</p>
<p>　　4）按key获取数据效率很高，但是对join或其他结构化查询的支持就比较差</p>
<p>　　基于它们的适用范围不同，目前主流架构才会采用组合方案，一个也不能少。目前为止，还没有出现一个能够通吃各种场景的数据库，而且根据CAP理论，这样的数据库是不存在的。�</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-同构SSR" class="article article-type-post" itemscope="" itemprop="blogPost" data-scroll-reveal="">

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/01/04/同构SSR/">关于同构SSR</a>
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2021/01/04/同构SSR/" class="article-date">
  <time datetime="2021-01-04T06:25:48.000Z" itemprop="datePublished">2021-01-04</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="关于同构SSR"><a href="#关于同构SSR" class="headerlink" title="关于同构SSR"></a>关于同构SSR</h1><p>虽然使用了服务端渲染，但是这个只能叫同构SSR，和传统的服务端渲染还是有区别的。目前同构SSR的本质就是集成页面组件，路由，前端状态，在服务端中运行生成快照，将生成的快照HTML传给客户端。需要注意的是，由于同构的这种快照所需的计算量远大于传统服务端渲染，所以单机性能上，可能要弱于传统服务端渲染。<br>同构SSR的实现得意于虚拟DOM的出现，虚拟DOM的最大好处并非Diff算法而是为前端赋能，把HTML的DOM抽象化，可以在服务端、IOS、安卓甚至智能家电上运行。<br>同构SSR的实质是当用户首次请求时，通过node端生成一个HTML快照给前端，之后用户在当前页面上的操作，其实都是一个SPA的操作交互，前端的路由交互还是依靠history路由去处理，而非传统路由，所以其实还是一个“SPA”。这样的处理，可以在保证首屏速度时，同时，减少服务器压力，提升用户体验，弥补同构渲染性能问题。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-JS-emoji-转码-解码" class="article article-type-post" itemscope="" itemprop="blogPost" data-scroll-reveal="">

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/12/11/JS-emoji-转码-解码/">将emoji转成UTF-16</a>
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/12/11/JS-emoji-转码-解码/" class="article-date">
  <time datetime="2020-12-11T06:03:17.000Z" itemprop="datePublished">2020-12-11</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>将emoji转成UTF-16<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toUTF16</span>(<span class="params">codePoint</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> TEN_BITS = <span class="built_in">parseInt</span>(<span class="string">'1111111111'</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">u</span>(<span class="params">codeUnit</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'\\u'</span>+codeUnit.toString(<span class="number">16</span>).toUpperCase();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (codePoint &lt;= <span class="number">0xFFFF</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> u(codePoint);</span><br><span class="line">  &#125;</span><br><span class="line">  codePoint -= <span class="number">0x10000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Shift right to get to most significant 10 bits</span></span><br><span class="line">  <span class="keyword">var</span> leadSurrogate = <span class="number">0xD800</span> + (codePoint &gt;&gt; <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Mask to get least significant 10 bits</span></span><br><span class="line">  <span class="keyword">var</span> tailSurrogate = <span class="number">0xDC00</span> + (codePoint &amp; TEN_BITS);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> u(leadSurrogate) + u(tailSurrogate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>// using codePointAt, it’s easy to go from emoji<br>// to decimal and back.<br>// Emoji to decimal representation<br>“😀”.codePointAt(0)</p>
<blockquote>
<p>128512</p>
</blockquote>
<p>// Decimal to emoji<br>String.fromCodePoint(128512)</p>
<blockquote>
<p>“😀”</p>
</blockquote>
<p>// going from emoji to hexadecimal is a little<br>// bit trickier. To convert from decimal to hexadecimal,<br>// we can use toUTF16.<br>// Decimal to hexadecimal<br>toUTF16(128512)</p>
<blockquote>
<p>“\uD83D\uDE00”</p>
</blockquote>
<p>// Hexadecimal to emoji<br>“\uD83D\uDE00”</p>
<blockquote>
<p>“😀”</p>
</blockquote>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-GPU" class="article article-type-post" itemscope="" itemprop="blogPost" data-scroll-reveal="">

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/11/03/GPU/">css GPU硬件加速原理</a>
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/11/03/GPU/" class="article-date">
  <time datetime="2020-11-03T13:55:30.000Z" itemprop="datePublished">2020-11-03</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>满世界的动画性能优化技巧，例如：</p>
<p>只允许改变transform、opacity，其它属性不要动，避免重新计算布局（reflow）</p>
<p>对动画元素应用transform: translate3d(0, 0, 0)、will-change: transform等，开启硬件加速</p>
<p>动画元素尽量用fixed、absolute定位方式，避免reflow</p>
<p>对动画元素应用高一点的z-index，减少复合层数量</p>
<p>。。。其它可能有用的规则</p>
<p>那么问题是：已经小心遵守这些规则了，为什么动画还会卡顿、跳帧？还能优化吗？要从哪里入手？</p>
<p>一.硬件加速是非规范的<br>The most important thing I’d like to tell you before we dive deep into GPU compositing is this: It’s a giant hack. You won’t find anything (at least for now) in the W3C‘s specifications about how compositing works, about how to explicitly put an element on a compositing layer or even about compositing itself. It’s just an optimization that the browser applies to perform certain tasks and that each browser vendor implements in its own way.</p>
<p>很多情况下，开启硬件加速确实能带来明显的性能提升，但是，这部分内容是非规范的，W3C并没有相关规范说明其中细节，所以通过一些技巧（例如transform: translate3d(0, 0, 0)）开启硬件加速是规范之外的行为，可能得到性能提升，也可能带来严重的性能问题</p>
<p>也许在将来会形成规范，依照规范去做肯定能获得性能提升，但在这之前，除了必须遵从各项性能优化原则外，还要考虑实际渲染流程，从原理上解决性能问题</p>
<p>硬件加速（Hardware Acceleration） 硬件加速在CSS动画上是指GPU合成（GPU compositing），浏览器不直接通过CPU生成图像数据显示出来，而是把相关层数据发送给GPU，而GPU在图像数据运算方面有天生优势，所以算是加速</p>
<p>那么当硬件加速不可用时，浏览器怎样渲染页面？</p>
<p>在没有硬件加速的情况下，浏览器通常是依赖于CPU来渲染生成网页的内容，大致的做法是遍历这些层，然后按照顺序把这些层的内容依次绘制在一个内部存储空间上（例如bitmap），最后把这个内部表示显示出来，这种做法就是软件渲染（software rendering）</p>
<p>二.transform和opacity的特殊性 以前通过改变布局相关属性形成动画，例如：</p>
<p>@keyframes move { from { left: 30px; } to { left: 100px; } } 对于动画的每一帧，浏览器都要重新计算元素的形状位置（reflow），把新状态渲染出来（repaint），再显示到屏幕上</p>
<p>整页reflow和repaint想想就觉得很慢，那么如果把动画元素抽出来作为前景，每帧其它部分作为背景不变，只重新渲染动画元素，再把前景背景合成起来，是不是会更快？当然会，因为GPU能快速地进行亚像素级图层合成</p>
<p>但是这样做的前提是能够按照动的，不动的划分出前景背景层，如果动画元素或者受布局影响，或者动的过程中影响到了布局，就会打破前景背景的界限，这样简单分为2层就有问题。那么，应用position: fixed | absolute是不是就能保证不会影响布局了？</p>
<p>不行，因为left可以接受百分比值、相对单位（em、vw等等），浏览器不能百分百肯定该属性的变化与布局无关，所以不能简单的分出前景背景层，例如：</p>
<p>@keyframes move { from { left: 30px; } to { left: 100%; } } 但浏览器能百分百肯定transform和opacity的变化与布局无关，不受布局影响，其变化也不会影响现有布局，所以这两个属性的特殊性是：</p>
<p>does not affect the document’s flow,</p>
<p>does not depend on the document’s flow,</p>
<p>does not cause a repaint.</p>
<p>如果不影响布局，且不受布局影响，其变化不会导致其它部分需要repaint，那么这个东西肯定可以抽出去单独作为一层，放心交给GPU去处理，享受硬件加速带来的好处；</p>
<p>细腻（GPU能做到亚像素级精度，且对GPU来说不费劲）</p>
<p>流畅（不受其它运算密集的JS任务影响，动画交给GPU了，与CPU无关）</p>
<p>三.GPU合成的代价 It might surprise you, but the GPU is a separate computer. That’s right: An essential part of every modern device is actually a standalone unit with its own processors and its own memory- and data-processing models. And the browser, like any other app or game, has to talk with the GPU as it would with an external device.</p>
<p>GPU是独立的一部分，有自己的处理器、内存核数据处理模型，那么意味着通过CPU在内存里创建的图像数据无法直接与GPU共享，需要打包发送给GPU，GPU收到后才能执行我们期望的一系列操作，这个过程需要时间，而打包数据需要内存</p>
<p>需要的内存取决于：</p>
<p>复合层的数量</p>
<p>复合层的大小</p>
<p>相对于数量，复合层的大小影响更大一些，例如：</p>
<p>.rect { width: 320px; height: 240px; background: #f00; } 这个红块如果要发送给GPU的话，需要的存储空间是：320 × 240 × 3 = 230400B = 225KB（rgb需要3个字节），如果图像含有透明部分，就需要320 × 240 × 4 = 307200B = 300KB</p>
<p>这样一个不起眼的小红块就需要2、300KB，页面动辄几十上百个元素，占全屏半屏的元素也不少，如果都作为复合层，交给GPU，内存消耗可想而知，所以一些很极端的硬件加速场景性能非常差：</p>
<p>技术分享</p>
<p>gpu compositing issue</p>
<p>对于1GB RAM的设备，去掉系统和后台进程的1/3，再去掉浏览器和当前页面的1/3，实际能用的只有200到300MB，如果复合层太多太大，内存会被迅速消耗，然后掉帧（卡顿、闪烁）现象，甚至浏览器/应用崩溃也就很合理了</p>
<p>P.S.详细见CSS3硬件加速也有坑！！！</p>
<p>四.创建复合层 浏览器在一些情况下会创建复合层，例如：</p>
<p>3D transforms: translate3d, translateZ and so on;</p>
<p>, and <iframe> elements;</iframe></p>
<p>animation of transform and opacity via Element.animate();</p>
<p>animation of transform and opacity via СSS transitions and animations;</p>
<p>position: fixed;</p>
<p>will-change;</p>
<p>filter;</p>
<p>。。。</p>
<p>还有很多，详细见CompositingReasons.h中定义的常量，分为几类：</p>
<p>这些大多是我们期望的，算是显式创建的复合层，而另一些情况也会创建复合层：</p>
<p>位于复合层之上的元素会被创建复合层（B的z-index大于A，对A做动画，B也会被**独立的复合层）</p>
<p>很容易理解，A在动画过程中可能会与B产生重叠，被B遮住，那么GPU需要每帧对A图层做动画，然后再与B图层合成，才能得到正确结果，所以B无论如何都要被**复合层，连同A一起交给GPU</p>
<p>隐式创建复合层主要出于重叠考虑，如果浏览器不确定会不会发生重叠，那么就要把不确定的东西都**复合层，所以，从这个角度看，高z-index原则是有道理的</p>
<p>五.硬件加速的优缺点 优点 动画非常流畅，能达到60fps</p>
<p>动画执行过程在独立线程里，不受计算密集的JS任务影响</p>
<p>缺点 把元素**复合层时需要额外重绘，有时很慢（可能需要整页重绘）</p>
<p>复合层数据传递给GPU有额外时耗，取决于复合层的数量和大小，这在中低端设备可能会导致闪烁</p>
<p>每个复合层都要消耗一部分内存，移动设备上内存很贵，过多占用会导致浏览器/应用崩溃</p>
<p>存在隐式复合层的问题，不注意的话内存飙升</p>
<p>文字模糊，元素有时会变形</p>
<p>最主要的问题集中在内存消耗和repaint上，所以动画性能优化目标是降低内存消耗，减少repaint</p>
<p>六.性能优化技巧 1.尽量避免隐式复合层 复合层直接影响repaint、内存消耗：动画开始时创建复合层、结束时删除复合层，都会引起repaint，而动画开始时必须把图层数据发送给GPU，内存消耗集中在这里。两条建议：</p>
<p>给动画元素应用高z-index，最好直接作为body的子元素，对于嵌套很深的动画元素，可以复制一个到body下，仅用于实现动画效果</p>
<p>给动画元素应用will-change，浏览器会提前把这些元素**复合层，可以让动画开始/结束时更流畅些，但不能滥用，在不需要的时候赶紧去掉，减少内存消耗</p>
<p>2.只改变transform和opacity 能用transform、opacity优先用，不能用的话想办法用，比如背景色渐变，可以用盖在上面的伪元素背景色opacity动画模拟；box-shadow动画可以用铺在下面的伪元素opacity动画模拟，这些曲折的实现方式能带来显著性能提升</p>
<p>3.减少复合层的大小 小元素放大展示，减小width、height，减少传递给GPU的数据，由GPU做scale放大展示，视觉效果无差异（多用于纯色背景元素，对不太重要的图片也可以进行5%到10%的宽高压缩），例如：</p>
<p><style> #a, #b { will-change: transform; background-color: #f00; } #a { width: 100px; height: 100px; } #b { width: 10px; height: 10px; transform: scale(10); } </style><br>最终显示的两个红色块在视觉上没有差异，但减小了90%的内存消耗</p>
<p>4.考虑对子元素动画与容器动画 容器动画可能存在不必要的内存消耗，比如子元素之间的空隙，也会被当做有效数据发送给GPU，如果对各个子元素分别应用动画，就能避免这部分的内存消耗</p>
<p>例如12道太阳光线旋转，转容器就把容器整张图都发送给GPU，单独转12道光线就去掉了光线之间的11条空隙，能够节省一半内存</p>
<p>5.早早关注复合层的数量和大小 从一开始就关注复合层，尤其是隐式创建的复合层，避免后期优化影响布局</p>
<p>复合层的大小比数量影响更大，但浏览器会做一些优化操作，把几个复合层整合成一个，叫Layer Squashing，但有时一个大复合层比几个小复合层消耗的内存更多，有必要的话可以手动去掉这种优化：</p>
<p>// 给每个元素应用不同的translateZ translateZ(0.0001px), translateZ(0.0002px) 6.不要滥用硬件加速 没事不要乱加transform: translateZ(0)、will-change: transform等强制开启硬件加速的属性，GPU合成存在缺点和不足，而且是非标准的行为，最好情况能带来显著性能提升，最坏情况可能会让浏览器崩溃</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-react-组件" class="article article-type-post" itemscope="" itemprop="blogPost" data-scroll-reveal="">

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/11/03/react-组件/">如何封装react 组件</a>
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/11/03/react-组件/" class="article-date">
  <time datetime="2020-11-03T12:43:27.000Z" itemprop="datePublished">2020-11-03</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>由于公司需要一套自己的前端UI公共组件，所以有这次分享</p>
<p>本篇文章重点阐述 SRP，即单一职责原则。<br>React组件式开发方式。你可以将复杂的用户界面分割为一个个组件，利用组件的可重用性和抽象的DOM操作。<br>基于组件的开发是高效的：一个复杂的系统是由专门的、易于管理的组件构建的。然而，只有设计良好的组件才能确保组合和复用的好处。<br>尽管应用程序很复杂，但为了满足最后期限和意外变化的需求，你必须不断地走在架构正确性的细线上。你必须将组件分离为专注于单个任务，并经过良好测试。<br>不幸的是，遵循错误的路径总是更加容易：编写具有许多职责的大型组件、紧密耦合组件、忘记单元测试。这些增加了技术债务，使得修改现有功能或创建新功能变得越来越困难。<br>编写React应用程序时，经常问自己：<br>• 如何正确构造组件？<br>• 在什么时候，一个大的组件应该拆分成更小的组件？<br>• 如何设计防止紧密耦合的组件之间的通信？<br>幸运的是，可靠的组件具有共同的特性。让我们来研究以下有用的标准，并将其详细到案例研究中。</p>
<h1 id="单一职责"><a href="#单一职责" class="headerlink" title="单一职责"></a>单一职责</h1><p>当一个组件只有一个改变的原因时，它有一个单一的职责。<br>编写React组件时要考虑的基本准则是单一职责原则。单一职责原则(缩写：SRP)要求组件有一个且只有一个变更的原因。<br>组件的职责可以是呈现列表，或者显示日期选择器，或者发出 HTTP 请求，或者绘制图表，或者延迟加载图像等。你的组件应该只选择一个职责并实现它。当你修改组件实现其职责的方式（例如，更改渲染的列表的数量限制），它有一个更改的原因。<br>为什么只有一个理由可以改变很重要？因为这样组件的修改隔离并且受控。单一职责原则制了组件的大小，使其集中在一件事情上。集中在一件事情上的组件便于编码、修改、重用和测试。<br>下面我们来举几个例子<br>实例1：一个组件获取远程数据，相应地，当获取逻辑更改时，它有一个更改的原因。<br>发生变化的原因是：<br>• 修改服务器URL<br>• 修改响应格式<br>• 要使用其他HTTP请求库<br>• 或仅与获取逻辑相关的任何修改。<br>示例2：表组件将数据数组映射到行组件列表，因此在映射逻辑更改时有一个原因需要更改。<br>发生变化的原因是：<br>• 你需要限制渲染行组件的数量（例如，最多显示25行）<br>• 当没有要显示的项目时，要求显示提示信息“列表为空”<br>• 或仅与数组到行组件的映射相关的任何修改。<br>你的组件有很多职责吗？如果答案是“是”，则按每个单独的职责将组件分成若干块。<br>如果您发现SRP有点模糊，请阅读本文。<br>在项目早期阶段编写的单元将经常更改，直到达到发布阶段。这些更改通常要求组件在隔离状态下易于修改：这也是 SRP 的目标。</p>
<h2 id="1-1-多重职责陷阱"><a href="#1-1-多重职责陷阱" class="headerlink" title="1.1 多重职责陷阱"></a>1.1 多重职责陷阱</h2><p>当一个组件有多个职责时，就会发生一个常见的问题。乍一看，这种做法似乎是无害的，并且工作量较少：<br>• 你立即开始编码：无需识别职责并相应地规划结构<br>• 一个大的组件可以做到这一切：不需要为每个职责创建组成部分<br>• 无拆分-无开销：无需为拆分组件之间的通信创建 props 和 callbacks<br>这种幼稚的结构在开始时很容易编码。但是随着应用程序的增加和变得复杂，在以后的修改中会出现困难。同时实现多个职责的组件有许多更改的原因。现在出现的主要问题是：出于某种原因更改组件会无意中影响同一组件实现的其它职责。<br>不要关闭电灯开关，因为它同样作用于电梯。<br>这种设计很脆弱。意外的副作用是很难预测和控制的。<br>例如，<chartandform> 同时有两个职责，绘制图表，并处理为该图表提供数据的表单。<chartandform> 就会有两个更改原因：绘制图表和处理表单。<br>当你更改表单字段（例如，将 <input> 修改为 <select> 时，你无意中中断图表的渲染。此外，图表实现是不可重用的，因为它与表单细节耦合在一起。<br>解决多重责任问题需要将 <chartandform> 分割为两个组件：<chart> 和<form>。每个组件只有一个职责：绘制图表或处理表单。组件之间的通信是通过props 实现。<br>多重责任问题的最坏情况是所谓的上帝组件（上帝对象的类比）。上帝组件倾向于了解并做所有事情。你可能会看到它名为 <application>、<manager> 、<bigcontainer> 或 <page>，代码超过500行。<br>在组合的帮助下使其符合SRP，从而分解上帝组件。(组合（composition）是一种通过将各组件联合在一起以创建更大组件的方式。组合是 React 的核心。)</page></bigcontainer></manager></application></form></chart></chartandform></select></chartandform></chartandform></p>
<h2 id="1-2-案例研究：使组件只有一个职责"><a href="#1-2-案例研究：使组件只有一个职责" class="headerlink" title="1.2 案例研究：使组件只有一个职责"></a>1.2 案例研究：使组件只有一个职责</h2><p>设想一个组件向一个专门的服务器发出 HTTP 请求，以获取当前天气。成功获取数据时，该组件使用响应来展示天气信息：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;</span><br><span class="line"><span class="comment">// 问题: 一个组件有多个职责</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Weather</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123; <span class="attr">temperature</span>: <span class="string">'N/A'</span>, <span class="attr">windSpeed</span>: <span class="string">'N/A'</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; temperature, windSpeed &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div className=<span class="string">"weather"</span>&gt;</span><br><span class="line">                &lt;div&gt;Temperature: &#123;temperature&#125;°C&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">                &lt;div&gt;Wind: &#123;windSpeed&#125;km/</span>h&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        axios.get(<span class="string">'http://weather.com/api'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> &#123; current &#125; = response.data;</span><br><span class="line">            <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">                temperature: current.temperature,</span><br><span class="line">                windSpeed: current.windSpeed</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在处理类似的情况时，问问自己：是否必须将组件拆分为更小的组件？通过确定组件可能会如何根据其职责进行更改，可以最好地回答这个问题。<br>这个天气组件有两个改变原因：</p>
<ol>
<li>componentDidMount() 中的 fetch 逻辑：服务器URL或响应格式可能会改变。</li>
<li>render() 中的天气展示：组件显示天气的方式可以多次更改。<br>解决方案是将 <weather> 分为两个组件：每个组件只有一个职责。命名为 <weatherfetch> 和 <weatherinfo>。<br><weatherfetch> 组件负责获取天气、提取响应数据并将其保存到 state 中。它改变原因只有一个就是获取数据逻辑改变。</weatherfetch></weatherinfo></weatherfetch></weather></li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;</span><br><span class="line"><span class="comment">// 解决措施: 组件只有一个职责就是请求数据</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeatherFetch</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123; <span class="attr">temperature</span>: <span class="string">'N/A'</span>, <span class="attr">windSpeed</span>: <span class="string">'N/A'</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; temperature, windSpeed &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;WeatherInfo temperature=&#123;temperature&#125; windSpeed=&#123;windSpeed&#125; /&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        axios.get(<span class="string">'http://weather.com/api'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> &#123; current &#125; = response.data;</span><br><span class="line">            <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">                temperature: current.temperature,</span><br><span class="line">                windSpeed: current.windSpeed</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种结构有什么好处？<br>例如，你想要使用 async/await 语法来替代 promise 去服务器获取响应。更改原因：修改获取逻辑<br>// 改变原因: 使用 async/await 语法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeatherFetch</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ..... //</span></span><br><span class="line">    <span class="keyword">async</span> componentDidMount() &#123;</span><br><span class="line">        <span class="keyword">const</span> response = <span class="keyword">await</span> axios.get(<span class="string">'http://weather.com/api'</span>);</span><br><span class="line">        <span class="keyword">const</span> &#123; current &#125; = response.data;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            temperature: current.temperature,</span><br><span class="line">            windSpeed: current.windSpeed</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为 <weatherfetch> 只有一个更改原因：修改 fetch 逻辑，所以对该组件的任何修改都是隔离的。使用 async/await 不会直接影响天气的显示。</weatherfetch></p>
<p><weatherfetch> 渲染 <weatherinfo>。后者只负责显示天气，改变原因只可能是视觉显示改变。<br>// 解决方案: 组件只有一个职责，就是显示天气</weatherinfo></weatherfetch></p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">WeatherInfo</span>(<span class="params">&#123; temperature, windSpeed &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div className=<span class="string">"weather"</span>&gt;</span><br><span class="line">            &lt;div&gt;Temperature: &#123;temperature&#125;°C&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">            &lt;div&gt;Wind: &#123;windSpeed&#125; km/</span>h&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们更改<weatherinfo>，如不显示 “wind:0 km/h” 而是显示 “wind:calm”。这就是天气视觉显示发生变化的原因：<br>// 改变原因: 无风时的显示<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">WeatherInfo</span>(<span class="params">&#123; temperature, windSpeed &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> windInfo = windSpeed === <span class="number">0</span> ? <span class="string">'calm'</span> : <span class="string">`<span class="subst">$&#123;windSpeed&#125;</span> km/h`</span>;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div className=<span class="string">"weather"</span>&gt;</span><br><span class="line">            &lt;div&gt;Temperature: &#123;temperature&#125;°C&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">            &lt;div&gt;Wind: &#123;windInfo&#125;&lt;/</span>div&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></weatherinfo></p>
<p>同样，对 <weatherinfo> 的修改是隔离的，不会影响 <weatherfetch> 组件。</weatherfetch></weatherinfo></p>
<p><weatherfetch> 和 <weatherinfo> 有各自的职责。一种组件的变化对另一种组件的影响很小。这就是单一职责原则的作用：修改隔离，对系统的其他组件产生影响很轻微并且可预测。</weatherinfo></weatherfetch></p>
<h2 id="1-3-案例研究：HOC-偏好单一责任原则"><a href="#1-3-案例研究：HOC-偏好单一责任原则" class="headerlink" title="1.3 案例研究：HOC 偏好单一责任原则"></a>1.3 案例研究：HOC 偏好单一责任原则</h2><p>按职责使用分块组件的组合并不总是有助于遵循单一责任原则。另外一种有效实践是高阶组件(缩写为 HOC)<br>高阶组件是一个接受一个组件并返回一个新组件的函数。<br>HOC 的一个常见用法是为封装的组件增加新属性或修改现有的属性值。这种技术称为属性代理：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withNewFunctionality</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">NewFunctionality</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">        render() &#123;</span><br><span class="line">            <span class="keyword">const</span> newProp = <span class="string">'Value'</span>;</span><br><span class="line">            <span class="keyword">const</span> propsProxy = &#123;</span><br><span class="line">                ...this.props,</span><br><span class="line">                <span class="comment">// 修改现有属性:</span></span><br><span class="line">                ownProp: <span class="keyword">this</span>.props.ownProp + <span class="string">' was modified'</span>,</span><br><span class="line">                <span class="comment">// 增加新属性:</span></span><br><span class="line">                newProp</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> &lt;WrappedComponent &#123;...propsProxy&#125; /&gt;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const MyNewComponent = withNewFunctionality(MyComponent);</span><br></pre></td></tr></table></figure></p>
<p>你还可以通过控制输入组件的渲染过程从而控制渲染结果。这种 HOC 技术被称为渲染劫持：<br>通过return cloneElement(rootElement=super.render(),rootElement.props,newChildren)<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withModifiedChildren</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">ModifiedChildren</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">        render() &#123;</span><br><span class="line">            <span class="keyword">const</span> rootElement = <span class="keyword">super</span>.render();</span><br><span class="line">            <span class="keyword">const</span> newChildren = [</span><br><span class="line">                ...rootElement.props.children,</span><br><span class="line">                <span class="comment">// 插入一个元素</span></span><br><span class="line">                &lt;div&gt;New child&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">            ];</span></span><br><span class="line"><span class="regexp">            return cloneElement(</span></span><br><span class="line"><span class="regexp">                rootElement,</span></span><br><span class="line"><span class="regexp">                rootElement.props,</span></span><br><span class="line"><span class="regexp">                newChildren</span></span><br><span class="line"><span class="regexp">            );</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">const MyNewComponent = withModifiedChildren(MyComponent);</span></span><br></pre></td></tr></table></figure></p>
<p>如果您想深入了解HOCS实践，我建议您阅读“深入响应高阶组件”。<br>让我们通过一个例子来看看HOC的属性代理技术如何帮助分离职责。<br>组件 <persistentform> 由 input 输入框和按钮 save to storage 组成。更改输入值后，点击 save to storage 按钮将其写入到 localStorage 中。<br>input 的状态在 handlechange(event) 方法中更新。点击按钮，值将保存到本地存储，在 handleclick() 中处理：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersistentForm</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123; <span class="attr">inputValue</span>: localStorage.getItem(<span class="string">'inputValue'</span>) &#125;;</span><br><span class="line">        <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; inputValue &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div className=<span class="string">"persistent-form"</span>&gt;</span><br><span class="line">                &lt;input type=<span class="string">"text"</span> value=&#123;inputValue&#125;</span><br><span class="line">                    onChange=&#123;<span class="keyword">this</span>.handleChange&#125; /&gt;</span><br><span class="line">                &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;Save to storage&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    handleChange(event) &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            inputValue: event.target.value</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    handleClick() &#123;</span><br><span class="line">        localStorage.setItem(<span class="string">'inputValue'</span>, <span class="keyword">this</span>.state.inputValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></persistentform></p>
<p>遗憾的是： <persistentform> 有2个职责：管理表单字段；将输入只保存中 localStorage。<br>让我们重构一下 <persistentform> 组件，使其只有一个职责：展示表单字段和附加的事件处理程序。它不应该知道如何直接使用存储：<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersistentForm</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123; <span class="attr">inputValue</span>: props.initialValue &#125;;</span><br><span class="line">        <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; inputValue &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div className=<span class="string">"persistent-form"</span>&gt;</span><br><span class="line">                &lt;input type=<span class="string">"text"</span> value=&#123;inputValue&#125;</span><br><span class="line">                    onChange=&#123;<span class="keyword">this</span>.handleChange&#125; /&gt;</span><br><span class="line">                &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;Save to storage&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    handleChange(event) &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            inputValue: event.target.value</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    handleClick() &#123;</span><br><span class="line">        <span class="keyword">this</span>.props.saveValue(<span class="keyword">this</span>.state.inputValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></persistentform></persistentform></p>
<p>组件从属性初始值接收存储的输入值，并使用属性函数 saveValue(newValue) 来保存输入值。这些props 由使用属性代理技术的 withpersistence() HOC提供。<br>现在 <persistentform> 符合 SRP。更改的唯一原因是修改表单字段。<br>查询和保存到本地存储的职责由 withPersistence() HOC承担：<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withPersistence</span>(<span class="params">storageKey, storage</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">PersistentComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">            <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">                <span class="keyword">super</span>(props);</span><br><span class="line">                <span class="keyword">this</span>.state = &#123; <span class="attr">initialValue</span>: storage.getItem(storageKey) &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            render() &#123;</span><br><span class="line">                <span class="keyword">return</span> (</span><br><span class="line">                    &lt;WrappedComponent</span><br><span class="line">                        initialValue=&#123;<span class="keyword">this</span>.state.initialValue&#125;</span><br><span class="line">                        saveValue=&#123;<span class="keyword">this</span>.saveValue&#125;</span><br><span class="line">                        &#123;...this.props&#125;</span><br><span class="line">                    /&gt;</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">            saveValue(value) &#123;</span><br><span class="line">                storage.setItem(storageKey, value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></persistentform></p>
<p>withPersistence()是一个 HOC，其职责是持久的。它不知道有关表单域的任何详细信息。它只聚焦一个工作：为传入的组件提供 initialValue 字符串和 saveValue() 函数。<br>将 <persistentform> 和 withpersistence() 一起使用可以创建一个新组件<localstoragepersistentform>。它与本地存储相连，可以在应用程序中使用：<br>const LocalStoragePersistentForm<br>    = withPersistence(‘key’, localStorage)(PersistentForm);<br>const instance = <localstoragepersistentform>;<br>只要 <persistentform> 正确使用 initialValue 和 saveValue()属性，对该组件的任何修改都不能破坏 withPersistence() 保存到存储的逻辑。<br>反之亦然：只要 withPersistence() 提供正确的 initialValue 和 saveValue()，对 HOC 的任何修改都不能破坏处理表单字段的方式。<br>SRP的效率再次显现出来：修改隔离，从而减少对系统其他部分的影响。<br>此外，代码的可重用性也会增加。你可以将任何其他表单 <myotherform> 连接到本地存储：<br>const LocalStorageMyOtherForm<br>    = withPersistence(‘key’, localStorage)(MyOtherForm);<br>const instance = <localstoragemyotherform>;<br>你可以轻松地将存储类型更改为 session storage：<br>const SessionStoragePersistentForm<br>    = withPersistence(‘key’, sessionStorage)(PersistentForm);<br>const instance = <sessionstoragepersistentform>;<br>初始版本 <persistentform> 没有隔离修改和可重用性好处，因为它错误地具有多个职责。<br>在不好分块组合的情况下，属性代理和渲染劫持的 HOC 技术可以使得组件只有一个职责。</persistentform></sessionstoragepersistentform></localstoragemyotherform></myotherform></persistentform></localstoragepersistentform></localstoragepersistentform></persistentform></p>
<h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>一个封装组件提供 props 控制其行为而不是暴露其内部结构。<br>耦合是决定组件之间依赖程度的系统特性。根据组件的依赖程度，可区分两种耦合类型：<br>• 当应用程序组件对其他组件知之甚少或一无所知时，就会发生松耦合。<br>• 当应用程序组件知道彼此的许多详细信息时，就会发生紧耦合。<br>松耦合是我们设计应用结构和组件之间关系的目标。<br>松耦合应用(封装组件)<br>松耦合会带来以下好处：<br>• 可以在不影响应用其它部分的情况下对某一块进行修改。、<br>• 任何组件都可以替换为另一种实现<br>• 在整个应用程序中实现组件复用，从而避免重复代码<br>• 独立组件更容易测试，增加了测试覆盖率<br>相反，紧耦合的系统会失去上面描述的好处。主要缺点是很难修改高度依赖于其他组件的组件。即使是一处修改，也可能导致一系列的依赖组件需要修改。<br>紧耦合应用(组件无封装)<br>封装 或 信息隐藏 是如何设计组件的基本原则，也是松耦合的关键。</p>
<h2 id="信息隐藏"><a href="#信息隐藏" class="headerlink" title="信息隐藏"></a>信息隐藏</h2><p>封装良好的组件隐藏其内部结构，并提供一组属性来控制其行为。<br>隐藏内部结构是必要的。其他组件没必要知道或也不依赖组件的内部结构或实现细节。<br>React 组件可能是函数组件或类组件、定义实例方法、设置 ref、拥有 state 或使用生命周期方法。这些实现细节被封装在组件内部，其他组件不应该知道这些细节。<br>隐藏内部结构的组件彼此之间的依赖性较小，而降低依赖度会带来松耦合的好处。</p>
<h2 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h2><p>细节隐藏是隔离组件的关键。此时，你需要一种组件通信的方法：props。porps 是组件的输入。<br>建议 prop 的类型为基本数据（例如，string 、 number 、boolean）：</p>
<p><message text="Hello world!" modal="{false}">;<br>必要时，使用复杂的数据结构，如对象或数组：</message></p>
<p>&lt;MoviesList items={[‘Batman Begins’, ‘Blade Runner’]} /&gt;<br>prop 可以是一个事件处理函数和异步函数：</p>
<p><input type="text" onchange="{handleChange}"><br>prop 甚至可以是一个组件构造函数。组件可以处理其他组件的实例化：<br>function If({ component: Component, condition }) {<br>    return condition ? <component> : null;<br>}</component></p>
<p><if condition="{false}" component="{LazyComponent}"><br>为了避免破坏封装，请注意通过 props 传递的内容。给子组件设置 props 的父组件不应该暴露其内部结构的任何细节。例如，使用 props 传输整个组件实例或 refs 都是一个不好的做法。<br>访问全局变量同样也会对封装产生负面影响。</if></p>
<h2 id="案例研究：封装修复"><a href="#案例研究：封装修复" class="headerlink" title="案例研究：封装修复"></a>案例研究：封装修复</h2><p>组件的实例和状态对象是封装在组件内部的实现细节。因此，将状态管理的父组件实例传递给子组件会破坏封装。<br>我们来研究一下这种情况。<br>一个简单的应用程序显示一个数字和两个按钮。第一个按钮增加数值，第二个按钮减少数值：<br>这个应用由两个组件组成：<app> 和 <controls>.<br>number 是 <app> 的 state 对象，<app> 负责 将这个数字渲染到页面。<br>// 问题: 封装被破坏<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123; <span class="attr">number</span>: <span class="number">0</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div className=<span class="string">"app"</span>&gt;</span><br><span class="line">                &lt;span className=<span class="string">"number"</span>&gt;&#123;<span class="keyword">this</span>.state.number&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">                &lt;Controls parent=&#123;this&#125; /</span>&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></app></app></controls></app></p>
<p><controls> 负责渲染按钮，并为其设置事件处理函数，当用户点击按钮时，父组件的状态将会被更新：number 加1或者减1((updateNumber()方法`)<br>// 问题: 使用父组件的内部结构<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Controls</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div className=<span class="string">"controls"</span>&gt;</span><br><span class="line">                &lt;button onClick=&#123;() =&gt; <span class="keyword">this</span>.updateNumber(+<span class="number">1</span>)&#125;&gt;</span><br><span class="line">                    Increase</span><br><span class="line">          &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">                &lt;button onClick=&#123;() =&gt; this.updateNumber(-1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">                    Decrease</span></span><br><span class="line"><span class="regexp">          &lt;/</span>button&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    updateNumber(toAdd) &#123;</span></span><br><span class="line"><span class="regexp">        this.props.parent.setState(prevState =&gt; (&#123;</span></span><br><span class="line"><span class="regexp">            number: prevState.number + toAdd</span></span><br><span class="line"><span class="regexp">        &#125;));</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></controls></p>
<p>当前的实现有什么问题？<br>• 第一个问题是： <app> 的封装被破坏，因为它的内部结构在应用中传递。<app> 错误地允许 <controls> 直接去修改其 state。<br>• 第二个问题是: 子组件 Controls 知道了太多父组件 <app> 的内部细节，它可以访问父组件的实例，知道父组件是一个有状态组件，知道父组件的 state 对象的细节(知道 number 是父组件 state 的属性)，并且知道怎么去更新父组件的 state.<br>一个麻烦的结果是： <controls> 将很难测试和重用。对 <app> 结构的细微修改会导致需要对 <controls> 进行修改（对于更大的应用程序，也会导致类似耦合的组件需要修改）。<br>解决方案是设计一个方便的通信接口，考虑到松耦合和封装。让我们改进两个组件的结构和属性，以便恢复封装。<br>只有组件本身应该知道它的状态结构。<app> 的状态管理应该从 <controls>（updateNumber()方法）移到正确的位置：即 <app> 组件中。</app></controls></app></controls></app></controls></app></controls></app></app></p>
<p><app> 被修改为 <controls> 设置属性 onIncrease 和 onDecrease。这些是更新 <app> 状态的回调函数:<br>// 解决: 恢复封装<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123; <span class="attr">number</span>: <span class="number">0</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div className=<span class="string">"app"</span>&gt;</span><br><span class="line">                &lt;span className=<span class="string">"number"</span>&gt;&#123;<span class="keyword">this</span>.state.number&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">                &lt;Controls</span></span><br><span class="line"><span class="regexp">                    onIncrease=&#123;() =&gt; this.updateNumber(+1)&#125;</span></span><br><span class="line"><span class="regexp">                    onDecrease=&#123;() =&gt; this.updateNumber(-1)&#125;</span></span><br><span class="line"><span class="regexp">                /</span>&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    updateNumber(toAdd) &#123;</span></span><br><span class="line"><span class="regexp">        this.setState(prevState =&gt; (&#123;</span></span><br><span class="line"><span class="regexp">            number: prevState.number + toAdd</span></span><br><span class="line"><span class="regexp">        &#125;));</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></app></controls></app></p>
<p>现在，<controls> 接收用于增加和减少数值的回调，注意解耦和封装恢复时：<controls> 不再需要访问父组件实例。也不会直接去修改父组件的状态。<br>而且，<controls> 被修改为了一个函数式组件:<br>// 解决方案: 使用回调函数去更新父组件的状态<br>              <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Controls</span>(<span class="params">&#123; onIncrease, onDecrease &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div className=<span class="string">"controls"</span>&gt;</span><br><span class="line">            &lt;button onClick=&#123;onIncrease&#125;&gt;Increase&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">            &lt;button onClick=&#123;onDecrease&#125;&gt;Decrease&lt;/</span>button&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></controls></controls></controls></p>
<p><app> 组件的封装已经恢复，状态由其本身管理，也应该如此。<br>此外，<controls> 不在依赖 <app> 的实现细节，onIncrease 和 onDecrease 在按钮被点击的时候调用，<controls> 不知道(也不应该知道)这些回调的内部实现。</controls></app></controls></app></p>
<p><controls> 组件的可重用性和可测试性显著增加。</controls></p>
<p><controls> 的复用变得很容易，因为它除了需要回调，没有其它依赖。测试也变得简单，只需验证单击按钮时，回调是否执行。</controls></p>
<h1 id="组成结构和权威组成部分。只需将它们分成较小的块，然后使用合成将整个背面粘合在一起，即可使复杂的过程变得简单。"><a href="#组成结构和权威组成部分。只需将它们分成较小的块，然后使用合成将整个背面粘合在一起，即可使复杂的过程变得简单。" class="headerlink" title="组成结构和权威组成部分。只需将它们分成较小的块，然后使用合成将整个背面粘合在一起，即可使复杂的过程变得简单。"></a>组成结构和权威组成部分。只需将它们分成较小的块，然后使用合成将整个背面粘合在一起，即可使复杂的过程变得简单。</h1><h2 id="单一责任"><a href="#单一责任" class="headerlink" title="单一责任"></a>单一责任</h2><p>组成的一个重要方面是能够由较小的专用组件组成复杂的组件。这种分而治之的方法有助于授权机构遵循单一责任原则。<br>回顾以前的代码片段。<application>负责呈现页眉，页脚，侧边栏和主要区域。<br>有意义的划分这个责任为四个子的责任，每个由专门的组件来实现<header>，<sidebar>，<content>和<footer>。后来的合成<application>从这些专用组件重新粘合。<br>现在带来好处。组合<application>通过允许其子级执行子职责而使其遵循单一职责原则。</application></application></footer></content></sidebar></header></application></p>
<h2 id="可重用性"><a href="#可重用性" class="headerlink" title="可重用性"></a>可重用性</h2><p>使用组合的组件可以重用通用逻辑。这就是可重用性的好处。<br>例如，组件<composed1>和<composed2>共享通用代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> instance1 = (</span><br><span class="line">  &lt;Composed1&gt;</span><br><span class="line">    <span class="comment">/* Specific to Composed1 code... */</span></span><br><span class="line">    <span class="comment">/* Common code... */</span></span><br><span class="line">  &lt;<span class="regexp">/Composed1&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp">const instance2 = (</span></span><br><span class="line"><span class="regexp">  &lt;Composed2&gt;</span></span><br><span class="line"><span class="regexp">    /</span>* Common code... *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">    /</span>* Specific to Composed2 code... *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">  &lt;/</span>Composed2&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></composed2></composed1></p>
<p>由于重复代码是一种不好的做法，因此如何使组件重用通用代码？<br>首先，将通用代码封装在一个新组件中<common>。其次，<composed1>并<composed2>应使用组成包括<common>，修复代码重复：<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> instance1 = (</span><br><span class="line">  &lt;Composed1&gt;</span><br><span class="line">    &lt;Piece1 /&gt;</span><br><span class="line">    &lt;Common /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Composed1&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp">const instance2 = (</span></span><br><span class="line"><span class="regexp">  &lt;Composed2&gt;</span></span><br><span class="line"><span class="regexp">    &lt;Common /</span>&gt;</span><br><span class="line">    &lt;Piece2 /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Composed2&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure></common></composed2></composed1></common></p>
<p>可重用组件有利于“不要重复自己（DRY）”原则。这种有益的做法节省了精力和时间。</p>
<h1 id="可重用的组件是设计良好的系统的结果。尽可能重复使用代码，以避免重复。"><a href="#可重用的组件是设计良好的系统的结果。尽可能重复使用代码，以避免重复。" class="headerlink" title="可重用的组件是设计良好的系统的结果。尽可能重复使用代码，以避免重复。"></a>可重用的组件是设计良好的系统的结果。尽可能重复使用代码，以避免重复。</h1><p>一个可重用的组件写入一次，但多次使用。<br>想象一个幻想世界，其中软件开发主要是在重新发明轮子。<br>编码时，不能使用任何现有的库或实用程序。即使在整个应用程序中，您也无法使用已经编写的代码。<br>在这种环境下，是否可以在合理的时间内编写应用程序？当然不。<br>欢迎重用。使事情起作用，而不是重新发明它们的工作方式。</p>
<h2 id="4-1跨应用程序重用"><a href="#4-1跨应用程序重用" class="headerlink" title="4.1跨应用程序重用"></a>4.1跨应用程序重用</h2><p>根据“不要重复自己（DRY）”原则，每条知识在系统中必须具有唯一，明确，权威的表示形式。该原则建议避免重复。<br>代码重复会增加复杂性和维护工作，而不会增加重大价值。逻辑的更新迫使您修改应用程序中的所有克隆。<br>重复性问题通过可重用的组件解决。一次编写，多次使用：高效省时的策略。<br>但是，您不会免费获得可重用性属性。如果组件符合单一职责原则并具有正确的封装，则可以重用。<br>遵守单一责任至关重要：<br>重用组件实际上意味着重用其责任实现。<br>仅负责一项的组件最容易重用。<br>但是，当一个组件错误地承担多个职责时，其重用会增加沉重的开销。您只想重用一个职责实施，还可以获取不适当的职责不必要的实施。<br>您想要一个香蕉，就得到一个香蕉，再加上所有的丛林。<br>正确的封装会创建一个不依赖于依赖项的组件。隐藏的内部结构和集中的支柱使组件可以很好地适合要重用的多个位置。</p>
<h2 id="4-2重用第三方库"><a href="#4-2重用第三方库" class="headerlink" title="4.2重用第三方库"></a>4.2重用第三方库</h2><p>一个正常的工作日。您已经阅读了向应用程序添加新功能的任务。启动文本编辑器之前，请等待几分钟……<br>您开始解决的问题很有可能已经解决。由于React的受欢迎程度和强大的开源社区，值得寻找现有的解决方案。<br>请查看brillout / awesome-react-components存储库，该存储库具有可重用组件的已编译列表。<br>好的图书馆会对架构决策产生积极影响，并倡导最佳实践。以我的经验，最有影响力的人物是react-router和redux。<br>react-router使用声明性路由来构建单页应用程序。<br>使用将URL路径与您的组件相关联<route>。然后，当用户访问匹配的URL时，路由器将为您呈现该组件。<br>redux和react-redux HOC引入了单向和可预测的应用程序状态管理。它从组件中提取异步和不纯净的代码（例如HTTP请求），支持单一职责原则并创建纯净或几乎纯净的组件。</route></p>
<h1 id="诸如网络请求或全局变量之类的副作用使组件取决于环境。通过为相同的prop值返回相同的输出来使其纯净。"><a href="#诸如网络请求或全局变量之类的副作用使组件取决于环境。通过为相同的prop值返回相同的输出来使其纯净。" class="headerlink" title="诸如网络请求或全局变量之类的副作用使组件取决于环境。通过为相同的prop值返回相同的输出来使其纯净。"></a>诸如网络请求或全局变量之类的副作用使组件取决于环境。通过为相同的prop值返回相同的输出来使其纯净。</h1><p>甚至认为使用Redux都需要其他构造，例如动作，减速器和Sagas，它有助于使<fetchweather>纯净。<br>让我们进行修改<weatherfetch>以与Redux一起使用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; fetch &#125; <span class="keyword">from</span> <span class="string">'./action'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherFetch</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">   render() &#123;</span><br><span class="line">     <span class="keyword">const</span> &#123; temperature, windSpeed &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">     <span class="keyword">return</span> (</span><br><span class="line">       &lt;WeatherInfo temperature=&#123;temperature&#125; windSpeed=&#123;windSpeed&#125; /&gt;</span><br><span class="line">     );</span><br><span class="line">   &#125;</span><br><span class="line">   componentDidMount() &#123;</span><br><span class="line">     <span class="keyword">this</span>.props.fetch();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapStateToProps</span>(<span class="params">state</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    temperature: state.temperate,</span><br><span class="line">    windSpeed: state.windSpeed</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps, &#123; fetch &#125;);</span><br><span class="line">connect(mapStateToProps, &#123; fetch &#125;)HOC包装&lt;WeatherFetch&gt;。</span><br></pre></td></tr></table></figure></weatherfetch></fetchweather></p>
<h1 id="有意义的组件命名和表达性代码是可读性的关键。您的代码必须易于理解并且欢迎阅读。"><a href="#有意义的组件命名和表达性代码是可读性的关键。您的代码必须易于理解并且欢迎阅读。" class="headerlink" title="有意义的组件命名和表达性代码是可读性的关键。您的代码必须易于理解并且欢迎阅读。"></a>有意义的组件命名和表达性代码是可读性的关键。您的代码必须易于理解并且欢迎阅读。</h1><p>一个有意义的组件很容易理解它的作用。<br>很难低估可读代码的重要性。您多少次被代码遮住了？您看到字符，但看不到含义。<br>开发人员花费大量时间阅读和理解代码，而不是实际编写代码。编码活动占75％的时间理解代码，20％的时间修改现有代码和5％的代码编写新代码（源）。<br>花一点时间在可读性上会减少以后对队友和您自己的理解时间。随着应用程序的增长，命名实践变得很重要，因为理解的努力会随着代码量的增加而增加。<br>读取有意义的代码很容易。但是，有意义地编写代码需要简洁的代码实践和不断的努力以清晰地表达自己。</p>
<h2 id="帕斯卡案"><a href="#帕斯卡案" class="headerlink" title="帕斯卡案"></a>帕斯卡案</h2><p>组件名称是在pascal情况下一个或多个单词（主要是名词）的串联。例如<datepicker>，<griditem>，<application>，<header>。</header></application></griditem></datepicker></p>
<h2 id="专业化"><a href="#专业化" class="headerlink" title="专业化"></a>专业化</h2><p>组件越特殊，其名称可能包含的单词越多。<br>名为的组件<headermenu>建议在标题中显示菜单。名称<sidebarmenuitem>表示位于侧栏中的菜单项。<br>当名称有意义地暗示意图时，组件很容易理解。为此，通常必须使用冗长的名称。很好：冗长多于清晰。<br>假设您浏览一些项目文件并确定2个组件：<authors>和<authorslist>。仅根据名称，您能得出它们之间的区别吗？很有可能不会。<br>要获取详细信息，您必须打开<authors>源文件并浏览代码。完成此操作后，您将意识到<authors>从服务器获取作者列表并呈现<authorslist>表示性组件。<br>使用更专业的名称代替<authors>不会导致这种情况。更好的名称<fetchauthors>，<authorscontainer>或<authorspage>。<br>简洁胜于简洁。</authorspage></authorscontainer></fetchauthors></authors></authorslist></authors></authors></authorslist></authors></sidebarmenuitem></headermenu></p>
<h2 id="一个字-一个概念"><a href="#一个字-一个概念" class="headerlink" title="一个字-一个概念"></a>一个字-一个概念</h2><p>一个词代表一个概念。例如，呈现项目概念的集合由列表词表示。<br>每个概念选择一个词，然后在整个应用程序中保持关系的一致性。结果是可预测的单词心理映射-您已经习惯了概念。<br>当同一概念由许多单词表示时，可读性会受到影响。例如，您定义一个呈现订单列表的组件，<orderslist>另一个定义呈现费用列表的组件<expensestable>。<br>呈现项目集合的相同概念由两个不同的词表示：list和table。没有理由为同一概念使用不同的词。它增加了混乱并破坏了命名的一致性。<br>命名组件<orderslist>和<expenseslist>（使用列表词）或<orderstable>和<expensestable>（使用表词）。使用您认为更好的任何单词，只要保持一致即可。<br>测试不仅是自动检测错误的方法。如果您发现难以测试的组件，则很可能是设计错误的组件。</expensestable></orderstable></expenseslist></orderslist></expensestable></orderslist></p>
<h1 id="在封装一个组件的时候应该先思考什么"><a href="#在封装一个组件的时候应该先思考什么" class="headerlink" title="在封装一个组件的时候应该先思考什么?"></a>在封装一个组件的时候应该先思考什么?</h1><p>这个组件应该是做什么的<br>这个组件应该至少需要知道那些信息<br>这个组件会反馈什么东西<br>在设计一个组件的时候我们不应该仅限于实现当前的需求，<br>设计出一个只适用于单一项目的组件，而是应该是一个可以适应大部分同种需求的通用组件。<br>所以我们在碰到一个需求的时候应该首先对需求进行抽象，而不是看到设计稿就撸着袖子上。<br>例如碰到一个轮播图组件的需求的时候，我们拆分以下这个需求，可以得到：<br>（1） 这个组件要做什么：<br>可以展示多张图片<br>可以向左向右翻页，或者是可以是上下翻页<br>PageControl的状态会根据图片的滚动而相应改变 还有可能有一些隐藏的需求，类似于：<br>应该支持左右两侧或者上下无限循环滚动<br>可以选择的是否自动轮播<br>支持手动滑动切换图片<br>图片有点击事件，可以点击来进行相关的事件反应<br>（2）这个组件至少应该知道什么信息<br>一个好的组件应该是要像存在魔法一样，只需要极其少数的参数和条件就可以得到期望的效果。就像这个轮播图组件一样，组件应该至少知道的信息有：<br>图片的url地址数组<br>当图片不存在时候的占位图<br>其他可以知道也可以不知道的信息可以有：<br>是否开启自动轮播，默认是开启或者不开启<br>图片滚动是左右还是上下，默认是左右<br>等等 ………………………………<br>（3）这个组件会反馈什么<br>一个可用的轮播图效果</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2015-2022
        Steady
      </li>
      <li>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
        
        <span>
  <i>PV:<span id="busuanzi_value_page_pv"></span></i>
  <i>UV:<span id="busuanzi_value_site_uv"></span></i>
</span>
        
      </li>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
    <div class="to_top">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>
      </div>
    </main>
      <aside class="sidebar">
        <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Steady&#39;blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about.me/index.html">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
      </aside>
      <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
      <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>
<script src="/js/share.js"></script>

<script src="/fancybox/jquery.fancybox.min.js"></script>



<script>
  try {
    var typed = new Typed("#subtitle", {
    strings: ['面朝大海，春暖花开','愿你一生努力，一生被爱','想要的都拥有，得不到的都释怀'],
    startDelay: 0,
    typeSpeed: 200,
    loop: true,
    backSpeed: 100,
    showCursor: true
    });
  } catch (err) {
  }
  
</script>




<script>
  var ayerConfig = {
    mathjax: false
  }
</script>

<script src="/js/ayer.js"></script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>




<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>
  </div>
</body>

</html>