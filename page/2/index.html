<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     Steady&#39;blog
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  <link rel="stylesheet" href="/css/style.css">
  <script src="/js/pace.min.js"></script>

  

  

</head>

</html>

<body>
  <div id="app">
    <main class="content">
      


<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>

<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article id="post-Chrome-time-分析" class="article article-type-post" itemscope="" itemprop="blogPost" data-scroll-reveal="">

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/07/03/Chrome-time-分析/">Chrome time 分析</a>
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/07/03/Chrome-time-分析/" class="article-date">
  <time datetime="2020-07-03T02:18:39.000Z" itemprop="datePublished">2020-07-03</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="Stalled（阻塞）"><a href="#Stalled（阻塞）" class="headerlink" title="Stalled（阻塞）"></a>Stalled（阻塞）</h1><p>　　浏览器对同一个主机域名的并发连接数有限制，因此如果当前的连接数已经超过上限，那么其余请求就会被阻塞，等待新的可用连接；此外脚本也会阻塞其他组件的下载；</p>
<p>　　优化措施：</p>
<p>　　1、将资源合理分布到多台主机上，可以提高并发数，但是增加并行下载数量也会增大开销，这取决于带宽和CPU速度，过多的并行下载会降低性能；</p>
<p>　　2、脚本置于页面底部；</p>
<h1 id="DNS-Lookup（域名解析）"><a href="#DNS-Lookup（域名解析）" class="headerlink" title="DNS Lookup（域名解析）"></a>DNS Lookup（域名解析）</h1><p>　　请求某域名下的资源，浏览器需要先通过DNS解析器得到该域名服务器的IP地址。在DNS查找完成之前，浏览器不能从主机名那里下载到任何东西。</p>
<p>　　优化措施：</p>
<p>　　1、利用DNS缓存（设置TTL时间）；</p>
<p>　　2、利用Connection:keep-alive特性建立持久连接，可以在当前连接上进行多个请求，无需再进行域名解析；</p>
<h1 id="Initial-connection（初始化连接）"><a href="#Initial-connection（初始化连接）" class="headerlink" title="Initial connection（初始化连接）"></a>Initial connection（初始化连接）</h1><p>　　TCP建立连接的三次握手时间</p>
<h1 id="SSL（包含于HTTPS连接中）"><a href="#SSL（包含于HTTPS连接中）" class="headerlink" title="SSL（包含于HTTPS连接中）"></a>SSL（包含于HTTPS连接中）</h1><p>　　http是超文本传输协议，以明文方式发送内容，不提供任何方式的数据加密，如果被不法分子截取浏览器和服务器之间的传输报文，会获取其中的信息。</p>
<p>　　https 是安全套接字层超文本传输协议，就是在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</p>
<p>　　因此建立HTTPS连接的时间相当于三次握手的时间+SSL时间。</p>
<h1 id="Request-sent（发送请求）"><a href="#Request-sent（发送请求）" class="headerlink" title="Request sent（发送请求）"></a>Request sent（发送请求）</h1><p>　　发送HTTP请求的时间（从第一个bit到最后一个bit）</p>
<p>　　优化措施：</p>
<p>　　1、减少HTTP请求，可以使用CSS Sprites、内联图片、合并脚本和样式表等；</p>
<p>　　2、对不常变化的组件添加长久的Expires头（相当于设置久远的过期时间），在后续的页面浏览中可以避免不必要的HTTP请求；</p>
<h1 id="Waiting（等待响应）"><a href="#Waiting（等待响应）" class="headerlink" title="Waiting（等待响应）"></a>Waiting（等待响应）</h1><p>　　通常是耗费时间最长的。从发送请求到收到响应之间的空隙，会受到线路、服务器距离等因素的影响。</p>
<p>　　优化措施：</p>
<p>　　1、使用CDN，将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求，提高响应速度；</p>
<h1 id="Content-Download（下载）"><a href="#Content-Download（下载）" class="headerlink" title="Content Download（下载）"></a>Content Download（下载）</h1><p>　　下载HTTP响应的时间（包含头部和响应体）</p>
<p>　　优化措施：</p>
<p>　　1、通过条件Get请求，对比If-Modified-Since和Last-Modified时间，确定是否使用缓存中的组件，服务器会返回“304 Not Modified”状态码，减小响应的大小；</p>
<p>　　2、移除重复脚本，精简和压缩代码，如借助自动化构建工具grunt、gulp等；</p>
<p>　　3、压缩响应内容，服务器端启用gzip压缩，可以减少下载时间</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-nodejs相关记录" class="article article-type-post" itemscope="" itemprop="blogPost" data-scroll-reveal="">

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/06/30/nodejs相关记录/">nodejs相关记录</a>
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/06/30/nodejs相关记录/" class="article-date">
  <time datetime="2020-06-30T08:09:28.000Z" itemprop="datePublished">2020-06-30</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="nvm管理node-版本号"><a href="#nvm管理node-版本号" class="headerlink" title="nvm管理node 版本号"></a>nvm管理node 版本号</h1><p>在mac和liunx系统里边  nvm use 切换的是当次版本   下次打开终端  还是之前的node版本</p>
<p>要想永久切换   使用nvm alias default （版本号）</p>
<h1 id="path-resolve-路径"><a href="#path-resolve-路径" class="headerlink" title="path.resolve 路径"></a>path.resolve 路径</h1><p>// 当前工作目录与当前文件路径(F:/1/2/task6/test/dist)有区别<br>path.resolve();                               //  F:/1/2/task6/test 当前工作目录的绝对路径<br>path.resolve(‘./a’);                          //  F:/1/2/task6/test/a<br>path.resolve(‘../a’);                         //  F:/1/2/task6/a<br>path.resolve(‘.’);                            //  F:/1/2/task6/test<br>path.resolve(‘..’);                           //  F:/1/2/task6<br>path.resolve(‘/‘));                           //  F:/<br>path.resolve(‘./a’,’../c/d’);                 //  F:/1/2/task6/test/c/d<br>path.resolve(‘./a’,’./c/d’);                  //  F:/1/2/task6/test/a/c/d<br>path.resolve(‘/a’,’../c/d’);                  //  F:c/d<br>path.resolve(‘/a’,’./c/d’);                   //  F:/a/c/d<br>path.resolve(‘./a’,’/b’,’./c/d’);             //  F:/b/c/d<br>path.resolve(‘a’,’b’,’c/d’);                  //  F:/1/2/task6/test/a/b/c/d<br>path.resolve(‘./a’,’./b’,’c/d’);              //  F:/1/2/task6/test/a/b/c/d<br>path.resolve(‘./a’,’/b’,’c/d’);               //  F:/b/c/d<br>path.resolve(‘./a/b’,’..’,’c/d’);             //  F:/1/2/task6/test/a/c/d<br>path.resolve(‘./a’,’..’,’c/d’);               //  F:/1/2/task6/test/c/d<br>————————————————</p>
<h1 id="paht-join"><a href="#paht-join" class="headerlink" title="paht.join"></a>paht.join</h1><p>path.join(‘/foo’, ‘bar’, ‘baz/asdf’, ‘quux’, ‘.’);          //  返回 /foo/bar/baz/asdf/quux, “.”和”/“没什么影响<br>path.join(‘/foo’, ‘./bar’, ‘baz/asdf’, ‘.’, ‘quux’);        //  返回 /foo/bar/baz/asdf/quux<br>path.join(‘/foo’, ‘./bar’, ‘./baz/asdf’, ‘quux’, ‘..’);     //  返回 /foo/bar/baz/asdf<br>path.join(‘/foo’, ‘bar’, ‘baz/asdf’, ‘.’, ‘.’);             //  返回 /foo/bar/baz/asdf<br>path.join(‘/foo’, ‘bar’, ‘baz/asdf’, ‘quux’);               //  返回 /foo/bar/baz/asdf/quux<br>path.join(‘/foo’, ‘bar’, ‘baz/asdf’, ‘..’, ‘..’);           //  返回 /foo/bar<br>————————————————</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-React-HOC-ref-用法" class="article article-type-post" itemscope="" itemprop="blogPost" data-scroll-reveal="">

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/06/04/React-HOC-ref-用法/">React HOC ref 用法</a>
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/06/04/React-HOC-ref-用法/" class="article-date">
  <time datetime="2020-06-04T02:26:11.000Z" itemprop="datePublished">2020-06-04</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>昨天参加面试被问到hoc 父组件的static 方法的传递</p>
<p>关键点就是React.forwardRef的API中ref必须指向dom元素而不是React组件。</p>
<p>一、React.forwardRef使用示例<br>下面就是应用到React组件的错误示例：</p>
<p>const A=React.forwardRef((props,ref)=&gt;<b {...props}="" ref="{ref}/">)<br>这就是我之前经常犯的错误， 这里的ref是无法生效的。</b></p>
<p>前面提到ref必须指向dom元素，那么正确方法就应用而生：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>  A=React.forwardRef(<span class="function">(<span class="params">props,ref</span>)=&gt;</span>(</span><br><span class="line">&lt;div ref=&#123;ref&#125;&gt;</span><br><span class="line">&lt;B &#123;...props&#125; /&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">))</span></span><br></pre></td></tr></table></figure></p>
<p>二、React.forwardRef应用到高阶组件中<br>2.1. withComponent类型的高阶组件【1】<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;</span><br><span class="line">import A from &apos;./a.jsx&apos;</span><br><span class="line">import PropTypes from &apos;prop-types&apos;;</span><br><span class="line"></span><br><span class="line">function withA(Component)&#123;</span><br><span class="line">    const ForWardedComponent = React.forwardRef((props, ref) =&gt; &lt;div ref=&#123;ref&#125;&gt;</span><br><span class="line">               &lt;Component &#123;...props&#125; /&gt;</span><br><span class="line">           &lt;/div&gt;);</span><br><span class="line">     class MidComponent extends React.Component &#123;</span><br><span class="line">        render() &#123;</span><br><span class="line">            const props = this.props</span><br><span class="line">            return (</span><br><span class="line">                &lt;A &#123;...props&#125;&gt;</span><br><span class="line">                  &lt;ForWardedComponent  ref=&#123;props.forwardedRef&#125; &#123;...props&#125;/&gt;</span><br><span class="line">            &lt;/A&gt;</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //对MidComponent组件属性进行类型经查 </span><br><span class="line">    MidComponent.propTypes = &#123;</span><br><span class="line">        forwardedRef: PropTypes.object,</span><br><span class="line">    &#125;</span><br><span class="line">    return  MidComponent</span><br><span class="line">&#125;</span><br><span class="line">exports.withA=withA</span><br><span class="line">这样，在上述示例的组件A中，A的周期componentDidMount() 调用 this.props.forwardedRef.current ,指向的就是上述示例中ForWardedComponent对应的dom元素。</span><br><span class="line">是B组件对应的dom的父元素，而不是该dom</span><br><span class="line">在a.jsx中某处:</span><br><span class="line"></span><br><span class="line">    componentDidMount()&#123;</span><br><span class="line">     console.log(this.props.forwardedRef.current)</span><br><span class="line">    &#125;</span><br><span class="line">最后应用实例：</span><br><span class="line"></span><br><span class="line">import React from &apos;react&apos;</span><br><span class="line">import ReactDOM from  &apos;react-dom&apos;</span><br><span class="line">//假设withA存储于withA.js文件。</span><br><span class="line">import &#123;withA&#125;   from  &apos;./withA.js&apos;  </span><br><span class="line"> const B=()=&gt;&lt;h2&gt;hello world&lt;/h2&gt;</span><br><span class="line">const B2=withA(B)</span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">      constructor(props) &#123;</span><br><span class="line">        super(props)</span><br><span class="line">        this.forwardedRef=React.creactRef()        </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        render() &#123;</span><br><span class="line">           return  &lt;div&gt;</span><br><span class="line">               &lt;B2  forwardedRef=&#123;this.forwardedRef&#125;/&gt;</span><br><span class="line">           &lt;/div&gt;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;App/&gt;,document.getElementById(&apos;app&apos;))</span><br><span class="line">     </span><br><span class="line">2.2 纯粹的高阶组件（Parent-Child）</span><br><span class="line">【1】中并不是React组件，只是一个React组件为参数的函数，调用以后才成为React组件。那么直接写入一个Parent组件又该如何呢？</span><br><span class="line"></span><br><span class="line">import React from &apos;react&apos;</span><br><span class="line">import A from &apos;./a.jsx&apos;</span><br><span class="line">import PropTypes from &apos;prop-types&apos;;</span><br><span class="line"></span><br><span class="line">function AasParent(props)&#123;</span><br><span class="line">    const ForWardedComponent = React.forwardRef((props, ref) =&gt; &lt;div ref=&#123;ref&#125;&gt;</span><br><span class="line">               &#123;props.children&#125;</span><br><span class="line">           &lt;/div&gt;);</span><br><span class="line">      return (</span><br><span class="line">                &lt;A &#123;...props&#125;&gt;</span><br><span class="line">                  &lt;ForWardedComponent  ref=&#123;props.forwardedRef&#125; &#123;...props&#125;/&gt;</span><br><span class="line">            &lt;/A&gt;)</span><br><span class="line">&#125;</span><br><span class="line">AasParent.propTypes = &#123;</span><br><span class="line">        forwardedRef: PropTypes.object,</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">module.exports=AasParent</span><br><span class="line">最后应用实例：</span><br><span class="line"></span><br><span class="line">import React from &apos;react&apos;</span><br><span class="line">import ReactDOM from  &apos;react-dom&apos;</span><br><span class="line">//假设AasParent存储于AasParent.jsx文件。注意与【1】中的区别</span><br><span class="line">import AasParent   from  &apos;./AasParent.jsx&apos;  </span><br><span class="line"> const B=(props)=&gt;&lt;h2&gt;&#123;props.greetings&#125;&lt;/h2&gt;</span><br><span class="line"></span><br><span class="line">class App extends React.Component &#123;</span><br><span class="line">      constructor(props) &#123;</span><br><span class="line">        super(props)</span><br><span class="line">        this.forwardedRef=React.creactRef()        </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        render() &#123;</span><br><span class="line">           return  &lt;AasParent forwardedRef=&#123;this.forwardedRef&#125;&gt;</span><br><span class="line">               &lt;B2  greetings=&quot;你好，Melo&quot;/&gt;</span><br><span class="line">           &lt;/AasParent&gt;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;App/&gt;,document.getElementById(&apos;app&apos;))</span><br></pre></td></tr></table></figure></p>
<p>三、总结<br>1.React.forwardRef的API中ref必须指向dom元素而不是React组件。<br>2.在【1】的组件A中，A的周期componentDidMount() 调用 this.props.forwardedRef.current ,指向的就是【1】中ForWardedComponent对应的dom元素。是【1】中B组件对应的dom的父dom元素，而不是该dom。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-Http协议相关" class="article article-type-post" itemscope="" itemprop="blogPost" data-scroll-reveal="">

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/05/12/Http协议相关/">Http协议相关</a>
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/05/12/Http协议相关/" class="article-date">
  <time datetime="2020-05-12T09:16:40.000Z" itemprop="datePublished">2020-05-12</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>1.强缓存离不开两个响应头Expires与Cache-Control</p>
<p>Expires：Expires是http1.0提出的一个表示资源过期时间的header，它描述的是一个绝对时间，由服务器返回，Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效<br>Expires: Wed, 11 May 2018 07:20:00 GMT</p>
<p>Cache-Control: Cache-Control 出现于 HTTP / 1.1，优先级高于 Expires ,表示的是相对时间<br>Cache-Control: max-age=315360000<br>强制缓存</p>
<p>Expires<br>响应header中添加Expires字段来标明失效规则。它的值为服务器返回的到期时间，即下一次请求时，请求时间小于服务器返回的到期时间，直接使用缓存数据。<br>response.setDataHeader(“Expires”, “0”);//无缓存<br>复制代码</p>
<p>Cache-Control（优先级高于Expires）<br>Cache-Control是最重要的规则。常见的取值有private、public、no-cache、max-age、no-store,默认为private。</p>
<p>private：只能针对个人用户，而不能被代理服务器缓存；<br>public：指示响应可被任何缓存区缓存；<br>no-cache：强制客户端直接向服务器发送请求,也就是说每次请求都必须向服务器发送。服务器接收到请求，然后判断资源是否变更，是则返回新内容，否则返回304，未变更。<br>max-age：用来设置资源（representations）可以被缓存多长时间，单位为秒；<br>no-store：禁止一切缓存</p>
<p>2.协商缓存<br>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：</p>
<p>协商缓存生效，返回304和Not Modified<br>协商缓存失效，返回200和请求结果</p>
<p>协商缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag 。</p>
<p>ETag/If-None-Match（优先级高于Last-Modified/If-Modified-Since）<br>服务器响应请求时，通过Etag头部告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定），浏览器再次请求时，就会带上一个头If-None-Match，这个值就是服务器上一次给的Etag的值，服务器比对一下资源当前的Etag是否跟If-None-Match一致，不一致则说明资源修改过了，浏览器不能再使用缓存，否则浏览器可以继续使用缓存，并返回304状态码。</p>
<p>Last-Modified/Last-Modified-Since<br>服务器响应请求时，会告诉浏览器一个告诉浏览器资源的最后修改时间：Last-Modified，浏览器之后再请求的时候，会带上一个头：If-Modified-Since，这个值就是服务器上一次给的 Last-Modified 的时间，服务器会比对资源当前最后的修改时间，如果大于If-Modified-Since，则说明资源修改过了，浏览器不能再使用缓存，否则浏览器可以继续使用缓存，并返回304状态码。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-V2Ray断流异常" class="article article-type-post" itemscope="" itemprop="blogPost" data-scroll-reveal="">

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/15/V2Ray断流异常/">V2Ray断流异常</a>
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/15/V2Ray断流异常/" class="article-date">
  <time datetime="2020-03-15T15:54:38.000Z" itemprop="datePublished">2020-03-15</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <ol>
<li><p>问题描述<br>最近一段时间发现，代理十分不稳定，经常出现“断流”，具体表现为：打开需要代理的站点，需要访问两次，第一次访问失败，需要再刷新一次。<br>查看错误日志内容：</p>
</li>
<li><p>Proxy|HTTP: failed to read response from r16—sn-ni57dn7z.gvt1.com &gt; io: read/write on closed pipe</p>
</li>
<li><p>问题原因<br>后翻阅issue检查发现，我的代理服务器时间比客户端慢了3分钟，两端时间不一致。</p>
</li>
<li><p>解决办法<br>同步服务器时间</p>
</li>
</ol>
<p>查看当前服务当前时间</p>
<ol>
<li>date -R</li>
<li>timedatectl set-ntp no</li>
<li>timedatectl set-time ‘23:51:00’</li>
</ol>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-React-高阶组件-属性代理和反向继承-生命周期调研" class="article article-type-post" itemscope="" itemprop="blogPost" data-scroll-reveal="">

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/12/22/React-高阶组件-属性代理和反向继承-生命周期调研/">React 高阶组件 属性代理和反向继承 生命周期调研</a>
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2019/12/22/React-高阶组件-属性代理和反向继承-生命周期调研/" class="article-date">
  <time datetime="2019-12-21T17:43:58.000Z" itemprop="datePublished">2019-12-22</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h2 id="属性代理-Props-Proxy-：-HOC-对传给-WrappedComponent-W-的-porps-进行操作，反向继承-Inheritance-Inversion-：-HOC-继承-WrappedComponent-W。"><a href="#属性代理-Props-Proxy-：-HOC-对传给-WrappedComponent-W-的-porps-进行操作，反向继承-Inheritance-Inversion-：-HOC-继承-WrappedComponent-W。" class="headerlink" title="属性代理(Props Proxy)： HOC 对传给 WrappedComponent W 的 porps 进行操作，反向继承(Inheritance Inversion)： HOC 继承 WrappedComponent W。"></a>属性代理(Props Proxy)： HOC 对传给 WrappedComponent W 的 porps 进行操作，反向继承(Inheritance Inversion)： HOC 继承 WrappedComponent W。</h2><h3 id="1-属性代理"><a href="#1-属性代理" class="headerlink" title="1.属性代理"></a>1.属性代理</h3><p>使用 Props Proxy 可以做什么？</p>
<p>操作 props<br>通过 Refs 访问到组件实例<br>提取 state<br>用其他元素包裹 WrappedComponent<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.message = <span class="string">'World'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  componentWillMount()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"属性代理1 willmount"</span>);  </span><br><span class="line">        &#125;</span><br><span class="line">        componentDidMount()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"属性代理1 didmount"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (&lt;h1&gt;Hello &#123;this.message&#125;&lt;/h1&gt;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyContainer = <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span> </span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">        componentWillMount()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"HOC属性代理1 willmount"</span>);  </span><br><span class="line">        &#125;</span><br><span class="line">        componentDidMount()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"HOC属性代理1 didmount"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        render()&#123;</span><br><span class="line">            <span class="keyword">return</span> &lt;WrappedComponent &#123;...this.props&#125; /&gt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">const Hocfirst=MyContainer(App);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;Hocfirst/&gt;, window.root);</span><br><span class="line"></span><br><span class="line">\\\</span><br><span class="line"></span><br><span class="line">"HOC属性代理1 willmount"</span><br><span class="line">"属性代理1 willmount"</span><br><span class="line">"属性代理1 didmount"</span><br><span class="line">"HOC属性代理1 didmount"</span><br></pre></td></tr></table></figure></p>
<h3 id="2-反向继承"><a href="#2-反向继承" class="headerlink" title="2.反向继承"></a>2.反向继承</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replacer</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`function <span class="subst">$&#123;value.name&#125;</span>() &#123;...&#125;`</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stringify</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(value, replacer, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// II debug example</span></span><br><span class="line"><span class="comment">// We are using the Inheritance Inversion technique to display</span></span><br><span class="line"><span class="comment">// the current state and props of the WrappedComponent (the component you want to debug).</span></span><br><span class="line"><span class="comment">// This is based on the technique that Mickael Jackson and Ryan Florence recommend</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">IIHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">II</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;h2&gt;</span><br><span class="line">            HOC Debugger Component</span><br><span class="line">          &lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">          &lt;p&gt;</span></span><br><span class="line"><span class="regexp">            Props</span></span><br><span class="line"><span class="regexp">          &lt;/</span>p&gt;</span><br><span class="line">          &lt;pre&gt;&#123;stringify(<span class="keyword">this</span>.props)&#125;&lt;<span class="regexp">/pre&gt;</span></span><br><span class="line"><span class="regexp">          &lt;p&gt;</span></span><br><span class="line"><span class="regexp">            State</span></span><br><span class="line"><span class="regexp">          &lt;/</span>p&gt;</span><br><span class="line">          &lt;pre&gt;&#123;stringify(<span class="keyword">this</span>.state)&#125;&lt;<span class="regexp">/pre&gt;</span></span><br><span class="line"><span class="regexp">          &#123;super.render()&#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      name: <span class="string">'fran'</span>,</span><br><span class="line">      email: <span class="string">'franleplant@gmail.com'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;</span><br><span class="line">          Wrapped Component</span><br><span class="line">        &lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">        &lt;p&gt;Im a wrapped component&lt;/</span>p&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const EnhancedExample = IIHOC(Example)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;EnhancedExample date=&#123;(new Date).toISOString()&#125; callback=&#123;function test() &#123;&#125;&#125;/</span>&gt;, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">E2：</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComponentChild</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      num: <span class="number">2019</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"child component Did Mount"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  clickComponent() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Component click"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> ( &lt;div &gt; &#123;</span><br><span class="line">        this.state.num</span><br><span class="line">      &#125; &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> iihoc = <span class="function">(<span class="params">WrapComponet</span>) =&gt;</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">WrapComponet</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">super</span>(props)</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">this</span>.state = &#123;</span><br><span class="line"> </span><br><span class="line">          num: <span class="number">2000</span></span><br><span class="line"> </span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line"> </span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'iihoc componentDidMount'</span>)</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">this</span>.clickComponent()</span><br><span class="line"> </span><br><span class="line">  &#125;</span><br><span class="line">render()&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line"> </span><br><span class="line">    &lt;div&gt;</span><br><span class="line"> </span><br><span class="line">        &lt;div onClick=&#123;<span class="keyword">this</span>.clickComponent&#125;&gt;iiHoc 点击&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">       &#123;/</span>* &lt;div&gt;&lt;WrapComponet /&gt;&lt;/div&gt; *<span class="regexp">/&#125;/</span><span class="regexp">/用的是父组件的state；</span></span><br><span class="line"><span class="regexp">       &lt;div&gt;&#123;super.render()&#125;&lt;/</span>div&gt;<span class="comment">//反向继承，用的是子组件的state；并且会劫持父组件的生命周期钩子函数componentDidMount，不会执行父组件的componentDidMount</span></span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">)</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">var App = iihoc(ComponentChild)</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;App/</span>&gt;, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-h5-hybird-webview页面兼容性" class="article article-type-post" itemscope="" itemprop="blogPost" data-scroll-reveal="">

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/12/20/h5-hybird-webview页面兼容性/">h5 hybird webview页面兼容性</a>
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2019/12/20/h5-hybird-webview页面兼容性/" class="article-date">
  <time datetime="2019-12-20T14:53:07.000Z" itemprop="datePublished">2019-12-20</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>1.在滚动容器上增加滚动 touch 方法<br>将-webkit-overflow-scrolling 值设置为 touch</p>
<p>.wrapper {<br>    -webkit-overflow-scrolling: touch;<br>}</p>
<p>2.iOS 上拉边界下拉出现白色空白<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'touchmove'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(e._isScroller) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 阻止默认事件</span></span><br><span class="line">    e.preventDefault();</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    passive: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>3.软键盘将页面顶起来、收起未回落问题<br>表现<br>Android 手机中，点击 input 框时，键盘弹出，将页面顶起来，导致页面样式错乱。<br>移开焦点时，键盘收起，键盘区域空白，未回落。<br>产生原因<br>我们在app 布局中会有个固定的底部。安卓一些版本中，输入弹窗出来，会将解压 absolute 和 fixed 定位的元素。导致可视区域变小，布局错乱。<br>原理与解决方案<br>软键盘将页面顶起来的解决方案，主要是通过监听页面高度变化，强制恢复成弹出前的高度。<br>// 记录原有的视口高度<br>const originalHeight = document.body.clientHeight || document.documentElement.clientHeight;</p>
<p>window.onresize = function(){<br>  var resizeHeight = document.documentElement.clientHeight || document.body.clientHeight;<br>  if(resizeHeight &lt; originalHeight ){<br>    document.body.clientHeight = originalHeight;<br>  }<br>}<br>复制代码键盘不能回落问题出现在 iOS 12+ 和 wechat 6.7.4+ 中，而在微信 H5 开发中是比较常见的 Bug。<br>兼容原理，1.判断版本类型 2.更改滚动的可视区域<br>const isWechat = window.navigator.userAgent.match(/MicroMessenger\/([\d.]+)/i);<br>if (!isWechat) return;<br>const wechatVersion = wechatInfo[1];<br>const version = (navigator.appVersion).match(/OS (\d+)<em>(\d+)</em>?(\d+)?/);</p>
<p> // 如果设备类型为iOS 12+ 和wechat 6.7.4+，恢复成原来的视口<br>if (+wechatVersion.replace(/./g, ‘’) &gt;= 674 &amp;&amp; +version[1] &gt;= 12) {<br>  window.scrollTo(0, Math.max(document.body.clientHeight, document.documentElement.clientHeight));<br>}<br>复制代码<br>window.scrollTo(x-coord, y-coord)，其中window.scrollTo(0, clientHeight)恢复成原来的视口</p>
<p>4.微信公众号分享问题<br>表现<br>在微信公众号 H5 开发中，页面内部点击分享按钮调用 SDK，方法不生效。<br>解决方案<br>解决方法：添加一层蒙层，做分享引导。<br>因为页面内部点击分享按钮无法直接调用，而分享功能需要点击右上角更多来操作。<br>然后用户可能不知道通过右上角小标里面的功能分享。又想引导用户分享，这时应该怎么做呢？<br>技术无法实现的，从产品出发。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-React-16-新特性" class="article article-type-post" itemscope="" itemprop="blogPost" data-scroll-reveal="">

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/12/17/React-16-新特性/">React 16 新特性</a>
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2019/12/17/React-16-新特性/" class="article-date">
  <time datetime="2019-12-17T00:28:14.000Z" itemprop="datePublished">2019-12-17</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h3 id="useEffect-useState-useCallback-Suspense"><a href="#useEffect-useState-useCallback-Suspense" class="headerlink" title="useEffect, useState, useCallback,Suspense"></a>useEffect, useState, useCallback,Suspense</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useCallback, Suspense &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">"./styles.css"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> EmployeesList <span class="keyword">from</span> <span class="string">"./EmployeesList"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> debounce <span class="keyword">from</span> <span class="string">"debounce"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; employeesResource &#125; <span class="keyword">from</span> <span class="string">"./fake-resource"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialResource = employeesResource(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">EmployeesPage</span>(<span class="params">&#123; resource &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Suspense fallback=&#123;&lt;div&gt;Fetching employees....&lt;<span class="regexp">/div&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">      &lt;EmployeesFetch resource=&#123;resource&#125; /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/Suspense&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function EmployeesFetch(&#123; resource &#125;) &#123;</span></span><br><span class="line"><span class="regexp">  const employees = resource.employees.read();</span></span><br><span class="line"><span class="regexp">  return &lt;EmployeesList employees=&#123;employees&#125; /</span>&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [resource, setResource] = useState(initialResource);</span><br><span class="line">  <span class="keyword">const</span> setResourceByQuery = useCallback(</span><br><span class="line">    debounce(<span class="function"><span class="params">query</span> =&gt;</span> setResource(employeesResource(query)), <span class="number">500</span>),</span><br><span class="line">    []</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;h2&gt;Employees list&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">      &lt;label&gt;Filter:&lt;/</span>label&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        type=<span class="string">"text"</span></span><br><span class="line">        onChange=&#123;event =&gt; setResourceByQuery(event.target.value)&#125;</span><br><span class="line">        placeholder=<span class="string">"Type query..."</span></span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;EmployeesPage resource=&#123;resource&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const rootElement = document.getElementById("root");</span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;App /</span>&gt;, rootElement);</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<p>useEffect的执行时机都是每次渲染后触发，无论是首次渲染还是更新渲染。<br>useEffect只会有当然组件是函数组件才会执行，不能再非函数组件中使用。<br>useEffect可以在同一函数组件中使用多次，按调用顺序执行，这样我们可以将生命周期中需要做的事情更小粒度的去编写代码。<br>在useEffect传入的函数中，return一个函数，用作函数组件卸载时需要执行的操作。<br>控制useEffect什么时候执行可以传入第二参数，而且第二个参数必须是数组！react会对这次传入的数组中的每一项和上一次数组中的每一项进行对比，当发现不一样时会做对应记录，在渲染后就会触发对应符合触发的useEffect函数。<br>useEffect的触发是采用异步方式执行的。因为有可能存在多个useEffect的函数，如果像class组件那样在commit阶段最后触发的话，很容易导致阻塞线程。所以React利用setTimeout的方式，将useEffect异步执行。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-JavaScript-原生dom操作" class="article article-type-post" itemscope="" itemprop="blogPost" data-scroll-reveal="">

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/12/11/JavaScript-原生dom操作/">JavaScript 原生dom操作</a>
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2019/12/11/JavaScript-原生dom操作/" class="article-date">
  <time datetime="2019-12-11T14:52:35.000Z" itemprop="datePublished">2019-12-11</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h3 id="document-querySelector-document-querySelectorAll"><a href="#document-querySelector-document-querySelectorAll" class="headerlink" title="document.querySelector / document.querySelectorAll"></a>document.querySelector / document.querySelectorAll</h3><p>document.querySelector方法返回文档中与指定选择器或选择器组匹配的第一个 html 元素。 如果找不到匹配项，则返回null。<br>document.querySelectorAll 方法返回与指定的选择器组匹配的文档中的元素列表 (使用深度优先的先序遍历文档的节点)。返回的对象是 NodeList 。<br>// 返回第一个 ul 元素<br>const list = document.querySelector(‘ul’)<br>// 返回所有类名为 info 或者 warning 的 div 元素<br>const elements = document.querySelectorAll(‘div.info, div.warning’);</p>
<h3 id="Node-removeChild"><a href="#Node-removeChild" class="headerlink" title="Node.removeChild"></a>Node.removeChild</h3><p>Node.removeChild方法从DOM中删除一个子节点并返回删除的节点。 请注意，返回的节点不再是DOM的一部分，而是仍存在于内存中。 如果处理不当，可能会导致内存泄漏。<br>let list = document.querySelector(‘ul’);<br>let firstItem = list.querySelector(‘li’);<br>let removedItem = list.removeChild(firstItem);</p>
<h3 id="Node-replaceChild"><a href="#Node-replaceChild" class="headerlink" title="Node.replaceChild"></a>Node.replaceChild</h3><p>此方法替换父节点中的子节点(并返回替换后的旧子节点)。请注意，如果处理不当，此方法可能导致与Node.removeChild类似的内存泄漏问题。<br>let list = document.querySelector(‘ul’);<br>let oldItem = list.querySelector(‘li’);<br>let newItem = document.createElement(‘li’);<br>newItem.innerHTML = ‘前端小智’;<br>let replacedItem = list.replaceChild(newItem, oldItem);<br>复</p>
<h3 id="Element-insertAdjacentHTML"><a href="#Element-insertAdjacentHTML" class="headerlink" title="Element.insertAdjacentHTML"></a>Element.insertAdjacentHTML</h3><p>element.insertAdjacentHTML(position, text) 将指定的文本解析为HTML或XML，并将结果节点插入到DOM树中的指定位置。它不会重新解析它正在使用的元素，因此它不会破坏元素内的现有元素。这避免了额外的序列化步骤，使其比直接innerHTML操作更快。<br>position是相对于元素的位置，并且必须是以下字符串之一：<br>beforebegin：元素自身的前面。<br>afterbegin：插入元素内部的第一个子节点之前。<br>beforeend：插入元素内部的最后一个子节点之后。<br>afterend：元素自身的后面。<br>text是要被解析为HTML或XML,并插入到DOM树中的字符串。<br><!-- beforebegin --></p>
<p><div><br>  <!-- afterbegin --><br>  <p>Hello World</p><br>  <!-- beforeend --><br></div><br><!-- afterend --><br>复制代码<br>示例：<br>var list = document.querySelector(‘ul’);<br>list.insertAdjacentHTML(‘afterbegin’, ‘<li id="first-item">First</li>‘);</p>
<h3 id="Element-hasAttribute-Element-removeAttribute"><a href="#Element-hasAttribute-Element-removeAttribute" class="headerlink" title="Element.hasAttribute / Element.removeAttribute"></a>Element.hasAttribute / Element.removeAttribute</h3><p>Element.hasAttribute方法检查给定元素是否具有指定的属性，返回值为boolean。 通过调用Element.removeAttribute方法，我们可以从元素中删除具有给定名称的属性。<br>let list = document.querySelector(‘ul’);<br>if (list.hasAttribute(‘id’)) {<br>    console.log(‘list has an id’);<br>    list.removeAttribute(‘id’);<br>};</p>
<h3 id="Element-getAttribute-Element-setAttribute"><a href="#Element-getAttribute-Element-setAttribute" class="headerlink" title="Element.getAttribute / Element.setAttribute"></a>Element.getAttribute / Element.setAttribute</h3><p>Element.getAttribute方法返回元素上给定属性的值，反之亦然，Element.setAttribute设置给定元素上属性的值。<br>let list = document.querySelector(‘ul’);<br>list.setAttribute(‘id’, ‘my-list’);<br>let id = list.getAttribute(‘id’);<br>console.log(id); // outputs my-list</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-vue生命周期" class="article article-type-post" itemscope="" itemprop="blogPost" data-scroll-reveal="">

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/12/02/vue生命周期/">vue生命周期</a>
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2019/12/02/vue生命周期/" class="article-date">
  <time datetime="2019-12-01T18:05:07.000Z" itemprop="datePublished">2019-12-02</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p><img src="/images/pasted-8.png" alt="upload successful"></p>
<p><img src="/images/pasted-9.png" alt="upload successful"></p>
<p>beforeCreate:在实例初始化之后，数据观测data observer(props、data、computed) 和 event/watcher 事件配置之前被调用。</p>
<p>created:实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。</p>
<p>beforeMount:在挂载开始之前被调用：相关的 render 函数首次被调用。</p>
<p>mounted: el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。</p>
<p>beforeUpdate:数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。 你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。</p>
<p>updated：无论是组件本身的数据变更，还是从父组件接收到的 props 或者从vuex里面拿到的数据有变更，都会触发虚拟 DOM 重新渲染和打补丁，并在之后调用 updated。</p>
<p>beforeDestroy:实例销毁之前调用。在这一步，实例仍然完全可用。</p>
<p>destroyed:Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用。<br>注意:</p>
<p>created阶段的ajax请求与mounted请求的区别：前者页面视图未出现，如果请求信息过多，页面会长时间处于白屏状态。</p>
<p>单个组件的生命周期</p>
<p>初始化组件时，仅执行了beforeCreate/Created/beforeMount/mounted四个钩子函数<br>当改变data中定义的变量（响应式变量）时，会执行beforeUpdate/updated钩子函数<br>当切换组件（当前组件未缓存）时，会执行beforeDestory/destroyed钩子函数<br>初始化和销毁时的生命钩子函数均只会执行一次，beforeUpdate/updated可多次执行</p>
<h2 id="Vue-nextTick-："><a href="#Vue-nextTick-：" class="headerlink" title="Vue.nextTick()："></a>Vue.nextTick()：</h2><p>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。</p>
<p>获取更新后的DOM言外之意就是什么操作需要用到了更新后的DOM而不能使用之前的DOM或者使用更新前的DOM会出问题，所以就衍生出了这个获取更新后的 DOM的Vue方法。所以放在Vue.nextTick()回调函数中的执行的应该是会对DOM进行操作的 js代码，比如Swiper扩展包的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var swiper = new Swiper(&apos;.swiper-container&apos;, &#123;</span><br><span class="line">                    pagination: &apos;.swiper-pagination&apos;,</span><br><span class="line">                    nextButton: &apos;.swiper-button-next&apos;,</span><br><span class="line">                    prevButton: &apos;.swiper-button-prev&apos;,</span><br><span class="line">                    paginationClickable: true,</span><br><span class="line">                    spaceBetween: 30,</span><br><span class="line">                    centeredSlides: true,</span><br><span class="line">                    autoplay: 2500,</span><br><span class="line">                    autoplayDisableOnInteraction: false</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="什么时候需要用Vue-nextTick"><a href="#什么时候需要用Vue-nextTick" class="headerlink" title="什么时候需要用Vue.nextTick():"></a>什么时候需要用Vue.nextTick():</h2><p>你在Vue生命周期的created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调函数中。原因是什么呢，原因是在created()钩子函数执行的时候DOM 其实并未进行任何渲染，而此时进行DOM操作无异于徒劳，所以此处一定要将DOM操作的js代码放进Vue.nextTick()的回调函数中。与之对应的就是mounted钩子函数，因为该钩子函数执行时所有的DOM挂载和渲染都已完成，此时在该钩子函数中进行任何DOM操作都不会有问题 。<br>在数据变化后要执行的某个操作，当你设置 vm.someData = ‘new value’，DOM并不会马上更新，而是在异步队列被清除，也就是下一个事件循环开始时执行更新时才会进行必要的DOM更新。如果此时你想要根据更新的 DOM 状态去做某些事情，就会出现问题。。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 Vue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用。<br>mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 vm.$nextTick 替换掉 mounted：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mounted: function () &#123;</span><br><span class="line">this.$nextTick(function () &#123;</span><br><span class="line"></span><br><span class="line">// Code that will run only after the</span><br><span class="line">// entire view has been rendered</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/">上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2015-2022
        Steady
      </li>
      <li>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
        
        <span>
  <i>PV:<span id="busuanzi_value_page_pv"></span></i>
  <i>UV:<span id="busuanzi_value_site_uv"></span></i>
</span>
        
      </li>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
    <div class="to_top">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>
      </div>
    </main>
      <aside class="sidebar">
        <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Steady&#39;blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about.me/index.html">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
      </aside>
      <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
      <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>
<script src="/js/share.js"></script>

<script src="/fancybox/jquery.fancybox.min.js"></script>



<script>
  try {
    var typed = new Typed("#subtitle", {
    strings: ['面朝大海，春暖花开','愿你一生努力，一生被爱','想要的都拥有，得不到的都释怀'],
    startDelay: 0,
    typeSpeed: 200,
    loop: true,
    backSpeed: 100,
    showCursor: true
    });
  } catch (err) {
  }
  
</script>




<script>
  var ayerConfig = {
    mathjax: false
  }
</script>

<script src="/js/ayer.js"></script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>




<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>
  </div>
</body>

</html>