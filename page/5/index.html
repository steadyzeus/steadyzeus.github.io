<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     Steady&#39;blog
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  <link rel="stylesheet" href="/css/style.css">
  <script src="/js/pace.min.js"></script>

  

  

</head>

</html>

<body>
  <div id="app">
    <main class="content">
      


<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>

<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article id="post-react-生命周期" class="article article-type-post" itemscope="" itemprop="blogPost" data-scroll-reveal="">

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2018/11/21/react-生命周期/">react 生命周期</a>
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2018/11/21/react-生命周期/" class="article-date">
  <time datetime="2018-11-21T14:05:39.000Z" itemprop="datePublished">2018-11-21</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="react-生命周期函数"><a href="#react-生命周期函数" class="headerlink" title="react 生命周期函数"></a>react 生命周期函数</h1><p>初始化阶段：</p>
<p>getDefaultProps:获取实例的默认属性</p>
<p>getInitialState:获取每个实例的初始化状态</p>
<p>componentWillMount：组件即将被装载、渲染到页面上</p>
<p>render:组件在这里生成虚拟的 DOM 节点</p>
<p>componentDidMount:组件真正在被装载之后</p>
<p>运行中状态：</p>
<p>componentWillReceiveProps:组件将要接收到属性的时候调用</p>
<p>shouldComponentUpdate:组件接受到新属性或者新状态的时候（可以返回 false，接收数据后不更新，阻止 render 调用，后面的函数不会被继续执行了）</p>
<p>componentWillUpdate:组件即将更新不能修改属性和状态</p>
<p>render:组件重新描绘</p>
<p>componentDidUpdate:组件已经更新</p>
<p>销毁阶段：</p>
<p>componentWillUnmount:组件即将销毁</p>
<h1 id="shouldComponentUpdate-是做什么的，（react-性能优化是哪个周期函数？）"><a href="#shouldComponentUpdate-是做什么的，（react-性能优化是哪个周期函数？）" class="headerlink" title="shouldComponentUpdate 是做什么的，（react 性能优化是哪个周期函数？）"></a>shouldComponentUpdate 是做什么的，（react 性能优化是哪个周期函数？）</h1><p>shouldComponentUpdate 这个方法用来判断是否需要调用 render 方法重新描绘 dom。因为 dom 的描绘非常消耗性能，如果我们能在 shouldComponentUpdate 方法中能够写出更优化的 dom diff 算法，可以极大的提高性能。</p>
<p>参考react 性能优化-sf</p>
<h1 id="为什么虚拟-dom-会提高性能-必考"><a href="#为什么虚拟-dom-会提高性能-必考" class="headerlink" title="为什么虚拟 dom 会提高性能?(必考)"></a>为什么虚拟 dom 会提高性能?(必考)</h1><p>虚拟 dom 相当于在 js 和真实 dom 中间加了一个缓存，利用 dom diff 算法避免了没有必要的 dom 操作，从而提高性能。</p>
<p>用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异把 2 所记录的差异应用到步骤 1 所构建的真正的 DOM 树上，视图就更新了。</p>
<p>参考 如何理解虚拟 DOM?-zhihu</p>
<h1 id="react-diff-原理（常考，大厂必考）"><a href="#react-diff-原理（常考，大厂必考）" class="headerlink" title="react diff 原理（常考，大厂必考）"></a>react diff 原理（常考，大厂必考）</h1><p>把树形结构按照层级分解，只比较同级元素。</p>
<p>给列表结构的每个单元添加唯一的 key 属性，方便比较。</p>
<p>React 只会匹配相同 class 的 component（这里面的 class 指的是组件的名字）</p>
<p>合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty.到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.</p>
<p>选择性子树渲染。开发人员可以重写 shouldComponentUpdate 提高 diff 的性能。</p>
<p>参考：React 的 diff 算法</p>
<h1 id="箭头函数设置-onClick事件"><a href="#箭头函数设置-onClick事件" class="headerlink" title="箭头函数设置 onClick事件"></a>箭头函数设置 onClick事件</h1><p><img src="/images/pasted-5.png" alt="upload successful"></p>
<h1 id="“React-connect-和-shouldComponentUpdate”-组件更新1次"><a href="#“React-connect-和-shouldComponentUpdate”-组件更新1次" class="headerlink" title="“React connect 和 shouldComponentUpdate” 组件更新1次"></a>“React connect 和 shouldComponentUpdate” 组件更新1次</h1><p>首先，因为connect使用的是HOC模式，所以他基本控制了你组件S的渲染。</p>
<p>其次，在connect中，每次父级传入的props发生改变的时候，都会经过一次shallow equal再决定是否有必要渲染S组件。</p>
<p>最后，虽然你的父组件Content的state发生了改变，但是传入S的props没有发生改变，所以在connect中被拦截，所以组件S就没有渲染。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-记一次大促页面性能优化" class="article article-type-post" itemscope="" itemprop="blogPost" data-scroll-reveal="">

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2018/11/13/记一次大促页面性能优化/">记一次大促页面性能优化</a>
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2018/11/13/记一次大促页面性能优化/" class="article-date">
  <time datetime="2018-11-12T17:25:02.000Z" itemprop="datePublished">2018-11-13</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="原始问题：使用iPhone在两个大促模板，通过-前进返回操作-来回点击次数过多，就会出现cpu暴涨到99-的情况，导致应用直接黑屏闪退"><a href="#原始问题：使用iPhone在两个大促模板，通过-前进返回操作-来回点击次数过多，就会出现cpu暴涨到99-的情况，导致应用直接黑屏闪退" class="headerlink" title="原始问题：使用iPhone在两个大促模板，通过 前进返回操作 来回点击次数过多，就会出现cpu暴涨到99%的情况，导致应用直接黑屏闪退"></a>原始问题：使用iPhone在两个大促模板，通过 前进<->返回操作 来回点击次数过多，就会出现cpu暴涨到99%的情况，导致应用直接黑屏闪退</-></h1><p>原因分析：iOS使用的是UIWebview，经过查询和测试，发现进入页面并立即返回上一页时，当前页面的代码逻辑（如alert、innerHTML等操作）仍在执行，频繁切换页面会可能导致网页占用的内存和CPU资源占用未被释放，进一步导致应用直接闪退</p>
<p>测试步骤：</p>
<p>本地新增两个测试页面test1.html和test2.html，启动一个本地服务器，并保证路由能够访问到两个测试页面（切换到对应文件目录，php -S localhost:9999 ），由于APP网页存在白名单，需要使用nginx配置一下代理<br>在测试页面导入客户端协议代码，支持使用客户端协议loadpage，编写逻辑代码，保证能从test1.html点击跳转到test2.html<br>频繁操作：test1.html点击跳转到test2.html -&gt; test2.hteml点击左上角返回按钮返回test1.html -&gt; test1.html点击跳转到test2.html<br>在test2.html页面足够简单的情况下，重复操作不会导致应用崩溃，可以在test2页面编写一下代码，返回足够快时可以在test1.html看见test2.html的弹窗执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">      alert(<span class="string">'alert from test2.html'</span>)</span><br><span class="line">&#125;, 1000);</span><br><span class="line">在test2.html页面编写渲染逻辑代码，模拟大促模板渲染逻辑</span><br><span class="line"></span><br><span class="line">// 每个模块每个deal的模板字符串</span><br><span class="line">var html = `&lt;div class=<span class="string">"deal module-item"</span> data-exposure=<span class="string">"313"</span> data-hit-type=<span class="string">"0"</span> data-dealid=<span class="string">"52046201"</span> data-zid=<span class="string">"ze181022124027966415"</span></span><br><span class="line">        data-type=<span class="string">"1"</span> data-goods-type=<span class="string">"6"</span> data-deal-type=<span class="string">"1"</span> data-begintime=<span class="string">"1541865600000"</span> data-endtime=<span class="string">"1542124799000"</span></span><br><span class="line">        data-offline=<span class="string">"1"</span> data-sellerid=<span class="string">"data-item-index=&amp;quot;1&amp;quot;"</span>&gt;</span><br><span class="line">        &lt;div class=<span class="string">"container"</span>&gt;</span><br><span class="line">            &lt;div class=<span class="string">"image"</span>&gt;</span><br><span class="line">                &lt;div class=<span class="string">"image-fade-in-viewer image-load-fade-in"</span> style=<span class="string">"opacity: 1; background-image: url(&amp;quot;https://z13.tuanimg.com/imagev2/trade/800x800.27859ac926bfe89888fe12750d7b4b2a.310x310.jpg&amp;quot;);"</span>&gt;&lt;/div&gt;</span><br><span class="line">                &lt;img class=<span class="string">"image-fade-in-loader"</span> src=<span class="string">"https://z13.tuanimg.com/imagev2/trade/800x800.27859ac926bfe89888fe12750d7b4b2a.310x310.jpg"</span></span><br><span class="line">                    style=<span class="string">"display: none;"</span>&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div class=<span class="string">"detail"</span>&gt;</span><br><span class="line">                &lt;h4 class=<span class="string">"title"</span>&gt;慵懒风毛衣2018秋冬季新款韩版宽松长袖羊毛毛衣纯色针织衫女潮&lt;/h4&gt;</span><br><span class="line">                &lt;p class=<span class="string">"price"</span>&gt;&lt;em&gt;52&lt;/em&gt;&lt;i&gt;398&lt;/i&gt;&lt;/p&gt; &lt;span class=<span class="string">"buy-now"</span> role=<span class="string">"button"</span>&gt;立即抢购 &amp;gt;&lt;/span&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;`;</span><br><span class="line">// 页面上配置了30个模块容器</span><br><span class="line">var <span class="variable">$modules</span> = $(<span class="string">".user-module"</span>);</span><br><span class="line">var repeatTime = 200;</span><br><span class="line"><span class="variable">$modules</span>.each(<span class="keyword">function</span> (index) &#123;</span><br><span class="line">    var element = $(this);</span><br><span class="line">    var rows = []</span><br><span class="line">    <span class="keyword">for</span> (var i = 0; i &lt; repeatTime; ++i) &#123;</span><br><span class="line">        rows.push(html)</span><br><span class="line">    &#125;</span><br><span class="line">    // 同大促模板使用innerHTML，插入拼接后的模块字符串</span><br><span class="line">    element.html(rows.join(<span class="string">''</span>));</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>再次进行频繁操作，就会复现上述闪退问题，可以通过调整$modules的数量，以及repeatTime(每个模块下deal的数量)来修改页面渲染的复杂度，数字越大则越容易出现闪退</p>
<p>经过上述分析和测试步骤，初步得出结论 ：在运营配置的模板页面过于复杂时（如模块过多，deal数量过多时），在切换到上一页时，由于webview容器没有及时释放web页面的资源，导致CPU及内存占用过高，导致页面闪退，CPU的资源占用点有</p>
<p>innerHTML，innerHTML会创建一个HTML解析器，效率高于手动调用createElement等方法，效率提升带来的问题是需要消耗大量的CPU，这在需要解析的html字符串过长时更为明显<br>每个模块的渲染都是等待接口返回，异步执行渲染的，可能存在在某个时间段内，多个模块连续调用innerHTML的情况，导致CPU占用时间过长；此外还会导致页面频繁的reflow等操作</p>
<p>查阅现在的大促模板渲染代码(/statics/activity/common/lib/render_modules.js)发现，对应的渲染代码是</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var <span class="variable">$modules</span> = $(<span class="string">'.user-module, .public-module'</span>, container);</span><br><span class="line"><span class="variable">$modules</span>.forEach(<span class="keyword">function</span> (element) &#123;</span><br><span class="line">    // ...</span><br><span class="line">    <span class="keyword">if</span> (moduleName) &#123;</span><br><span class="line">        var module;</span><br><span class="line">        try &#123;</span><br><span class="line">            module = requireModule(<span class="string">'statics/activity/modules/'</span> + moduleName + <span class="string">'/'</span> + styleCodeName + <span class="string">'.js'</span>);</span><br><span class="line">        &#125; catch (error) &#123;</span><br><span class="line">            console.error(error);</span><br><span class="line">        &#125;</span><br><span class="line">        element.rendered = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (typeof module === <span class="string">'function'</span>) &#123;</span><br><span class="line">            module.call(window.activitySettings, element, id ? moduleData[id] : null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>会遍历模块并加载对应的模块渲染函数，所有模块的逻辑函数都是同步执行的，在需要deal详细数据的接口会先调用Deal.load方法请求数据，并在回调中处理模块的渲染逻辑，调用innerHTML渲染到页面上。</p>
<p>此处可以优化为：通过节流函数控制每个模块的渲染间隔，页面靠后的模块间隔一定时间后再执行加载渲染逻辑，这样可以避免同一时间多个网络请求发出，并在某个很短的间隔内同时处理多个模块的渲染逻辑，错开innerHTML的渲染高峰期。</p>
<p>此外，在进入页面就立即离开的频繁操作中，取消掉未完成渲染模块的请求和渲染（通过$.calljs.goback注册原生方法），可以节省相关资源的浪费</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var isRendering = <span class="literal">true</span>;</span><br><span class="line">// 离开页面时修改标志符，清空当前页面，释放内存</span><br><span class="line">$.calljs.goback = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    isRendering = <span class="literal">false</span>;</span><br><span class="line">    document.body.innerHTML = <span class="string">''</span>;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$modules</span>.each(<span class="keyword">function</span> (index) &#123;</span><br><span class="line">    var element = $(this);</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">render</span></span>()&#123;</span><br><span class="line">        module.call(window.activitySettings, element, id ? moduleData[id] : null);</span><br><span class="line">    &#125;</span><br><span class="line">    // 首屏元素仍旧保持同步渲染</span><br><span class="line">    <span class="keyword">if</span> (index &lt; 3) &#123;</span><br><span class="line">        render()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            // 如果离开页面，则不进行后续模块的渲染</span><br><span class="line">            <span class="keyword">if</span> (isRendering) &#123;</span><br><span class="line">                render()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, index * 100);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="优先使用渲染层合并属性"><a href="#优先使用渲染层合并属性" class="headerlink" title="优先使用渲染层合并属性"></a>优先使用渲染层合并属性</h1><p>渲染层的合并，就是把页面中完成了绘制过程的部分合并成一层，然后显示在屏幕上。</p>
<p>使用transform/opacity来实现动画效果，目前只有transforms和opacity这两个属性不会触发浏览器的布局和绘制，对网页元素这两个属性的修改会直接触发渲染层合并。</p>
<h1 id="优化JavaScript的执行效率"><a href="#优化JavaScript的执行效率" class="headerlink" title="优化JavaScript的执行效率"></a>优化JavaScript的执行效率</h1><p>对于动画效果的实现，避免使用setTimeout或setInterval，请使用requestAnimationFrame。</p>
<p>把耗时长的JavaScript代码放到Web Workers中去做。</p>
<p>这里可以使用Chrome DevTools的Timeline和JavaScript Profiler来分析JavaScript的性能。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-屏幕height-width-获取" class="article article-type-post" itemscope="" itemprop="blogPost" data-scroll-reveal="">

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2018/11/12/屏幕height-width-获取/">屏幕height width 获取</a>
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2018/11/12/屏幕height-width-获取/" class="article-date">
  <time datetime="2018-11-11T17:48:25.000Z" itemprop="datePublished">2018-11-12</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">网页可见区域宽： document.body.clientWidth</span><br><span class="line">网页可见区域高： document.body.clientHeight</span><br><span class="line">网页可见区域宽： document.body.offsetWidth (包括边线的宽)</span><br><span class="line">网页可见区域高： document.body.offsetHeight (包括边线的高)</span><br><span class="line">网页正文全文宽： document.body.scrollWidth</span><br><span class="line">网页正文全文高： document.body.scrollHeight</span><br><span class="line">网页被卷去的高： document.body.scrollTop</span><br><span class="line">网页被卷去的左： document.body.scrollLeft</span><br><span class="line">网页正文部分上： window.screenTop</span><br><span class="line">网页正文部分左： window.screenLeft</span><br><span class="line">屏幕分辨率的高： window.screen.height</span><br><span class="line">屏幕分辨率的宽： window.screen.width</span><br><span class="line">屏幕可用工作区高度： window.screen.availHeight</span><br><span class="line">屏幕可用工作区宽度： window.screen.availWidth</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">JQuery:</span><br><span class="line">$(document).ready(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">alert($(window).height()); //浏览器当前窗口可视区域高度</span><br><span class="line">alert($(document).height()); //浏览器当前窗口文档的高度</span><br><span class="line">alert($(document.body).height());//浏览器当前窗口文档body的高度</span><br><span class="line">alert($(document.body).outerHeight(<span class="literal">true</span>));//浏览器当前窗口文档body的总高度 包括border padding margin</span><br><span class="line"></span><br><span class="line">alert($(window).width()); //浏览器当前窗口可视区域宽度</span><br><span class="line">alert($(document).width());//浏览器当前窗口文档对象宽度</span><br><span class="line">alert($(document.body).width());//浏览器当前窗口文档body的宽度</span><br><span class="line">alert($(document.body).outerWidth(<span class="literal">true</span>));//浏览器当前窗口文档body的总宽度 包括border padding margin</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 网页被卷起来的高度/宽度（即浏览器滚动条滚动后隐藏的页面内容高度）</span><br><span class="line"></span><br><span class="line">(javascript)        document.documentElement.scrollTop //firefox，chrome</span><br><span class="line"></span><br><span class="line">(javascript)        document.documentElement.scrollLeft //firefox，chrome </span><br><span class="line"></span><br><span class="line">(javascript)        document.body.scrollTop //IE</span><br><span class="line"></span><br><span class="line">(javascript)        document.body.scrollLeft //IE</span><br><span class="line"></span><br><span class="line">(jqurey)             $(window).scrollTop() </span><br><span class="line"></span><br><span class="line">(jqurey)             $(window).scrollLeft()</span><br><span class="line"></span><br><span class="line"> 网页工作区域的高度和宽度  </span><br><span class="line"></span><br><span class="line">(javascript)       document.documentElement.clientHeight// IE firefox       </span><br><span class="line"></span><br><span class="line">(jqurey)             $(window).height()</span><br><span class="line"></span><br><span class="line"> 元素距离文档顶端和左边的偏移值  </span><br><span class="line"></span><br><span class="line">(javascript)        document.documentElement.offsetTop //IE firefox</span><br><span class="line"></span><br><span class="line">(javascript)        document.documentElement.offsetLeft //IE firefox</span><br><span class="line"></span><br><span class="line">(jqurey)             jq对象.offset().top</span><br><span class="line"></span><br><span class="line">(jqurey)             jq对象.offset().left</span><br><span class="line"></span><br><span class="line">获取页面元素距离浏览器工作区顶端的距离</span><br><span class="line"> 页面元素距离浏览器工作区顶端的距离  =  元素距离文档顶端偏移值  -   网页被卷起来的高度  </span><br><span class="line"></span><br><span class="line">即：</span><br><span class="line"></span><br><span class="line"> 页面元素距离浏览器工作区顶端的距离 =  document.documentElement.offsetTop  -  document.documentElement.scrollTop</span><br></pre></td></tr></table></figure>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-抖动节流函数" class="article article-type-post" itemscope="" itemprop="blogPost" data-scroll-reveal="">

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2018/11/09/抖动节流函数/">抖动节流函数</a>
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2018/11/09/抖动节流函数/" class="article-date">
  <time datetime="2018-11-08T20:36:25.000Z" itemprop="datePublished">2018-11-09</time>
</a>
      
      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p>【前端性能】高性能滚动 scroll 及页面渲染优化<br>最近在研究页面渲染及web动画的性能问题，以及拜读《CSS SECRET》（CSS揭秘）这本大作。</p>
<p>本文主要想谈谈页面优化之滚动优化。</p>
<p>主要内容包括了为何需要优化滚动事件，滚动与页面渲染的关系，节流与防抖，pointer-events:none 优化滚动。因为本文涉及了很多很多基础，可以对照上面的知识点，选择性跳到相应地方阅读。</p>
<p>滚动优化的由来<br>滚动优化其实也不仅仅指滚动（scroll 事件），还包括了例如 resize 这类会频繁触发的事件。简单的看看：</p>
<p>var i = 0;<br>window.addEventListener(‘scroll’,function(){<br>    console.log(i++);<br>},false);<br>输出如下：</p>
<p>在绑定 scroll 、resize 这类事件时，当它发生时，它被触发的频次非常高，间隔很近。如果事件中涉及到大量的位置计算、DOM 操作、元素重绘等工作且这些工作无法在下一个 scroll 事件触发前完成，就会造成浏览器掉帧。加之用户鼠标滚动往往是连续的，就会持续触发 scroll 事件导致掉帧扩大、浏览器 CPU 使用率增加、用户体验受到影响。</p>
<p>在滚动事件中绑定回调应用场景也非常多，在图片的懒加载、下滑自动加载数据、侧边浮动导航栏等中有着广泛的应用。</p>
<p>当用户浏览网页时，拥有平滑滚动经常是被忽视但却是用户体验中至关重要的部分。当滚动表现正常时，用户就会感觉应用十分流畅，令人愉悦，反之，笨重不自然卡顿的滚动，则会给用户带来极大不舒爽的感觉。</p>
<p>滚动与页面渲染的关系<br>为什么滚动事件需要去优化？因为它影响了性能。那它影响了什么性能呢？额……这个就要从页面性能问题由什么决定说起。</p>
<p>我觉得搞技术一定要追本溯源，不要看到别人一篇文章说滚动事件会导致卡顿并说了一堆解决方案优化技巧就如获至宝奉为圭臬，我们需要的不是拿来主义而是批判主义，多去源头看看。</p>
<p>从问题出发，一步一步寻找到最后，就很容易找到问题的症结所在，只有这样得出的解决方法才容易记住。</p>
<p>说教了一堆废话，不喜欢的直接忽略哈，回到正题，要找到优化的入口就要知道问题出在哪里，对于页面优化而言，那么我们就要知道页面的渲染原理：</p>
<p>浏览器渲染原理我在我上一篇文章里也要详细的讲到，不过更多的是从动画渲染的角度去讲的：【Web动画】CSS3 3D 行星运转 &amp;&amp; 浏览器渲染原理 。</p>
<p>想了想，还是再简单的描述下，我发现每次 review 这些知识点都有新的收获，这次换一张图，以 chrome 为例子，一个 Web 页面的展示，简单来说可以认为经历了以下下几个步骤：</p>
<p>JavaScript：一般来说，我们会使用 JavaScript 来实现一些视觉变化的效果。比如做一个动画或者往页面里添加一些 DOM 元素等。</p>
<p>Style：计算样式，这个过程是根据 CSS 选择器，对每个 DOM 元素匹配对应的 CSS 样式。这一步结束之后，就确定了每个 DOM 元素上该应用什么 CSS 样式规则。</p>
<p>Layout：布局，上一步确定了每个 DOM 元素的样式规则，这一步就是具体计算每个 DOM 元素最终在屏幕上显示的大小和位置。web 页面中元素的布局是相对的，因此一个元素的布局发生变化，会联动地引发其他元素的布局发生变化。比如，<body> 元素的宽度的变化会影响其子元素的宽度，其子元素宽度的变化也会继续对其孙子元素产生影响。因此对于浏览器来说，布局过程是经常发生的。</body></p>
<p>Paint：绘制，本质上就是填充像素的过程。包括绘制文字、颜色、图像、边框和阴影等，也就是一个 DOM 元素所有的可视效果。一般来说，这个绘制过程是在多个层上完成的。</p>
<p>Composite：渲染层合并，由上一步可知，对页面中 DOM 元素的绘制是在多个层上进行的。在每个层上完成绘制过程之后，浏览器会将所有层按照合理的顺序合并成一个图层，然后显示在屏幕上。对于有位置重叠的元素的页面，这个过程尤其重要，因为一旦图层的合并顺序出错，将会导致元素显示异常。</p>
<p>这里又涉及了层（GraphicsLayer）的概念，GraphicsLayer 层是作为纹理(texture)上传给 GPU 的，现在经常能看到说 GPU 硬件加速，就和所谓的层的概念密切相关。但是和本文的滚动优化相关性不大，有兴趣深入了解的可以自行 google 更多。</p>
<p>简单来说，网页生成的时候，至少会渲染（Layout+Paint）一次。用户访问的过程中，还会不断重新的重排（reflow）和重绘（repaint）。</p>
<p>其中，用户 scroll 和 resize 行为（即是滑动页面和改变窗口大小）会导致页面不断的重新渲染。</p>
<p>当你滚动页面时，浏览器可能会需要绘制这些层(有时也被称为合成层)里的一些像素。通过元素分组，当某个层的内容改变时，我们只需要更新该层的结构，并仅仅重绘和栅格化渲染层结构里变化的那一部分，而无需完全重绘。显然，如果当你滚动时，像视差网站(戳我看看)这样有东西在移动时，有可能在多层导致大面积的内容调整，这会导致大量的绘制工作。</p>
<p>   防抖（Debouncing）和节流（Throttling）<br>scroll 事件本身会触发页面的重新渲染，同时 scroll 事件的 handler 又会被高频度的触发, 因此事件的 handler 内部不应该有复杂操作，例如 DOM 操作就不应该放在事件处理中。</p>
<p>针对此类高频度触发事件问题（例如页面 scroll ，屏幕 resize，监听用户输入等），下面介绍两种常用的解决方法，防抖和节流。</p>
<p>防抖（Debouncing）<br>防抖技术即是可以把多个顺序地调用合并成一次，也就是在一定时间内，规定事件被触发的次数。</p>
<p>通俗一点来说，看看下面这个简化的例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">// 简单的防抖动函数</span><br><span class="line"><span class="keyword">function</span> debounce(func, <span class="built_in">wait</span>, immediate) &#123;</span><br><span class="line">    // 定时器变量</span><br><span class="line">    var timeout;</span><br><span class="line">    <span class="built_in">return</span> <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        // 每次触发 scroll handler 时先清除定时器</span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        // 指定 xx ms 后触发真正想进行的操作 handler</span><br><span class="line">        timeout = setTimeout(func, <span class="built_in">wait</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">// 实际想绑定在 scroll 事件上的 handler</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">realFunc</span></span>()&#123;</span><br><span class="line">    console.log(<span class="string">"Success"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 采用了防抖动</span><br><span class="line">window.addEventListener(<span class="string">'scroll'</span>,debounce(realFunc,500));</span><br><span class="line">// 没采用防抖动</span><br><span class="line">window.addEventListener(<span class="string">'scroll'</span>,realFunc);</span><br><span class="line">上面简单的防抖的例子可以拿到浏览器下试一下，大概功能就是如果 500ms 内没有连续触发两次 scroll 事件，那么才会触发我们真正想在 scroll 事件中触发的函数。</span><br><span class="line"></span><br><span class="line">上面的示例可以更好的封装一下：</span><br><span class="line"></span><br><span class="line">// 防抖动函数</span><br><span class="line"><span class="keyword">function</span> debounce(func, <span class="built_in">wait</span>, immediate) &#123;</span><br><span class="line">    var timeout;</span><br><span class="line">    <span class="built_in">return</span> <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        var context = this, args = arguments;</span><br><span class="line">        var later = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">            timeout = null;</span><br><span class="line">            <span class="keyword">if</span> (!immediate) func.apply(context, args);</span><br><span class="line">        &#125;;</span><br><span class="line">        var callNow = immediate &amp;&amp; !timeout;</span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        timeout = setTimeout(later, <span class="built_in">wait</span>);</span><br><span class="line">        <span class="keyword">if</span> (callNow) func.apply(context, args);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">var myEfficientFn = debounce(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    // 滚动中的真正的操作</span><br><span class="line">&#125;, 250);</span><br><span class="line"> </span><br><span class="line">// 绑定监听</span><br><span class="line">window.addEventListener(<span class="string">'resize'</span>, myEfficientFn);</span><br></pre></td></tr></table></figure></p>
<p>节流（Throttling）<br>防抖函数确实不错，但是也存在问题，譬如图片的懒加载，我希望在下滑过程中图片不断的被加载出来，而不是只有当我停止下滑时候，图片才被加载出来。又或者下滑时候的数据的 ajax 请求加载也是同理。</p>
<p>这个时候，我们希望即使页面在不断被滚动，但是滚动 handler 也可以以一定的频率被触发（譬如 250ms 触发一次），这类场景，就要用到另一种技巧，称为节流函数（throttling）。</p>
<p>节流函数，只允许一个函数在 X 毫秒内执行一次。</p>
<p>与防抖相比，节流函数最主要的不同在于它保证在 X 毫秒内至少执行一次我们希望触发的事件 handler。</p>
<p>与防抖相比，节流函数多了一个 mustRun 属性，代表 mustRun 毫秒内，必然会触发一次 handler ，同样是利用定时器，看看简单的示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 简单的节流函数</span><br><span class="line"><span class="keyword">function</span> throttle(func, <span class="built_in">wait</span>, mustRun) &#123;</span><br><span class="line">    var timeout,</span><br><span class="line">        startTime = new Date();</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">return</span> <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        var context = this,</span><br><span class="line">            args = arguments,</span><br><span class="line">            curTime = new Date();</span><br><span class="line"> </span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        // 如果达到了规定的触发时间间隔，触发 handler</span><br><span class="line">        <span class="keyword">if</span>(curTime - startTime &gt;= mustRun)&#123;</span><br><span class="line">            func.apply(context,args);</span><br><span class="line">            startTime = curTime;</span><br><span class="line">        // 没达到触发间隔，重新设定定时器</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            timeout = setTimeout(func, <span class="built_in">wait</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">// 实际想绑定在 scroll 事件上的 handler</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">realFunc</span></span>()&#123;</span><br><span class="line">    console.log(<span class="string">"Success"</span>);</span><br><span class="line">&#125;</span><br><span class="line">// 采用了节流函数</span><br><span class="line">window.addEventListener(<span class="string">'scroll'</span>,throttle(realFunc,500,1000));</span><br></pre></td></tr></table></figure>
<p>throttle(realFunc,500,1000)的调用相当于var fn=throttle(realFunc,500,1000)；对fn引用调用</p>
<p>上面简单的节流函数的例子可以拿到浏览器下试一下，大概功能就是如果在一段时间内 scroll 触发的间隔一直短于 500ms ，那么能保证事件我们希望调用的 handler 至少在 1000ms 内会触发一次。</p>
<p>使用 rAF（requestAnimationFrame）触发滚动事件<br>上面介绍的抖动与节流实现的方式都是借助了定时器 setTimeout ，但是如果页面只需要兼容高版本浏览器或应用在移动端，又或者页面需要追求高精度的效果，那么可以使用浏览器的原生方法 rAF（requestAnimationFrame）。</p>
<p>requestAnimationFrame<br>window.requestAnimationFrame() 这个方法是用来在页面重绘之前，通知浏览器调用一个指定的函数。这个方法接受一个函数为参，该函数会在重绘前调用。</p>
<p>rAF 常用于 web 动画的制作，用于准确控制页面的帧刷新渲染，让动画效果更加流畅，当然它的作用不仅仅局限于动画制作，我们可以利用它的特性将它视为一个定时器。（当然它不是定时器）</p>
<p>通常来说，rAF 被调用的频率是每秒 60 次，也就是 1000/60 ，触发频率大概是 16.7ms 。（当执行复杂操作时，当它发现无法维持 60fps 的频率时，它会把频率降低到 30fps 来保持帧数的稳定。）</p>
<p>简单而言，使用 requestAnimationFrame 来触发滚动事件，相当于上面的：</p>
<p>throttle(func, xx, 1000/60) //xx 代表 xx ms内不会重复触发事件 handler<br>简单的示例如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var ticking = <span class="literal">false</span>; // rAF 触发锁</span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">onScroll</span></span>()&#123;</span><br><span class="line">  <span class="keyword">if</span>(!ticking) &#123;</span><br><span class="line">    requestAnimationFrame(realFunc);</span><br><span class="line">    ticking = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">realFunc</span></span>()&#123;</span><br><span class="line">    // <span class="keyword">do</span> something...</span><br><span class="line">    console.log(<span class="string">"Success"</span>);</span><br><span class="line">    ticking = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">// 滚动事件监听</span><br><span class="line">window.addEventListener(<span class="string">'scroll'</span>, onScroll, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>上面简单的使用 rAF 的例子可以拿到浏览器下试一下，大概功能就是在滚动的过程中，保持以 16.7ms 的频率触发事件 handler。</p>
<p>使用 requestAnimationFrame 优缺点并存，首先我们不得不考虑它的兼容问题，其次因为它只能实现以 16.7ms 的频率来触发，代表它的可调节性十分差。但是相比 throttle(func, xx, 16.7) ，用于更复杂的场景时，rAF 可能效果更佳，性能更好。</p>
<p>总结一下 </p>
<p>防抖动：防抖技术即是可以把多个顺序地调用合并成一次，也就是在一定时间内，规定事件被触发的次数。</p>
<p>节流函数：只允许一个函数在 X 毫秒内执行一次，只有当上一次函数执行后过了你规定的时间间隔，才能进行下一次该函数的调用。</p>
<p>rAF：16.7ms 触发一次 handler，降低了可控性，但是提升了性能和精确度。</p>
<p>   简化 scroll 内的操作<br>上面介绍的方法都是如何去优化 scroll 事件的触发，避免 scroll 事件过度消耗资源的。</p>
<p>但是从本质上而言，我们应该尽量去精简 scroll 事件的 handler ，将一些变量的初始化、不依赖于滚动位置变化的计算等都应当在 scroll 事件外提前就绪。</p>
<p>建议如下：</p>
<p>避免在scroll 事件中修改样式属性 / 将样式操作从 scroll 事件中剥离</p>
<p>输入事件处理函数，比如 scroll / touch 事件的处理，都会在 requestAnimationFrame 之前被调用执行。</p>
<p>因此，如果你在 scroll 事件的处理函数中做了修改样式属性的操作，那么这些操作会被浏览器暂存起来。然后在调用 requestAnimationFrame 的时候，如果你在一开始做了读取样式属性的操作，那么这将会导致触发浏览器的强制同步布局。</p>
<p>   滑动过程中尝试使用 pointer-events: none 禁止鼠标事件<br>大部分人可能都不认识这个属性，嗯，那么它是干什么用的呢？</p>
<p>pointer-events 是一个 CSS 属性，可以有多个不同的值，属性的一部分值仅仅与 SVG 有关联，这里我们只关注 pointer-events: none 的情况，大概的意思就是禁止鼠标行为，应用了该属性后，譬如鼠标点击，hover 等功能都将失效，即是元素不会成为鼠标事件的 target。</p>
<p>可以就近 F12 打开开发者工具面板，给 <body> 标签添加上 pointer-events: none 样式，然后在页面上感受下效果，发现所有鼠标事件都被禁止了。</body></p>
<p>那么它有什么用呢？</p>
<p>pointer-events: none 可用来提高滚动时的帧频。的确，当滚动时，鼠标悬停在某些元素上，则触发其上的 hover 效果，然而这些影响通常不被用户注意，并多半导致滚动出现问题。对 body 元素应用 pointer-events: none ，禁用了包括 hover 在内的鼠标事件，从而提高滚动性能。</p>
<p>.disable-hover {<br>    pointer-events: none;<br>}<br>大概的做法就是在页面滚动的时候, 给 <body> 添加上 .disable-hover 样式，那么在滚动停止之前, 所有鼠标事件都将被禁止。当滚动结束之后，再移除该属性。</body></p>
<p>可以查看这个 demo 页面。</p>
<p>上面说 pointer-events: none 可用来提高滚动时的帧频 的这段话摘自 pointer-events-MDN ，还专门有文章讲解过这个技术：</p>
<p>使用pointer-events:none实现60fps滚动 。</p>
<p>这就完了吗？没有，张鑫旭有一篇专门的文章，用来探讨 pointer-events: none 是否真的能够加速滚动性能，并提出了自己的质疑：</p>
<p>pointer-events:none提高页面滚动时候的绘制性能？</p>
<p>结论见仁见智，使用 pointer-events: none 的场合要依据业务本身来定夺，拒绝拿来主义，多去源头看看，动手实践一番再做定夺。</p>
<p>转自：<a href="https://www.cnblogs.com/coco1s/p/5499469.html" target="_blank" rel="noopener">https://www.cnblogs.com/coco1s/p/5499469.html</a></p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  

</article>
    
    <article id="post-es6语法" class="article article-type-post" itemscope="" itemprop="blogPost" data-scroll-reveal="">

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2018/11/08/es6语法/">es6语法</a>
</h2>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2018/11/08/es6语法/" class="article-date">
  <time datetime="2018-11-07T17:55:00.000Z" itemprop="datePublished">2018-11-08</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/es6/">es6</a>
  </div>

      
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      


      

      
      <h1 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h1><h2 id="for-in-遍历数组下标"><a href="#for-in-遍历数组下标" class="headerlink" title="for in 遍历数组下标"></a>for in 遍历数组下标</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function add(...values) &#123;</span><br><span class="line">  let sum = 0;</span><br><span class="line">console.log(values);</span><br><span class="line">  for (var val in values) &#123;console.log(val);</span><br><span class="line">    sum += values[val];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="for-of-遍历数组值"><a href="#for-of-遍历数组值" class="headerlink" title="for of 遍历数组值"></a>for of 遍历数组值</h2><p>##es6之扩展运算符 三个点（…）<br>对象的扩展运算符<br>理解对象的扩展运算符其实很简单，只要记住一句话就可以：</p>
<p>对象中的扩展运算符(…)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let bar = &#123; a: 1, b: 2 &#125;;</span><br><span class="line">let baz = &#123; ...bar &#125;; // &#123; a: 1, b: 2 &#125;</span><br><span class="line"></span><br><span class="line">上述方法实际上等价于:</span><br><span class="line"></span><br><span class="line">let bar = &#123; a: 1, b: 2 &#125;;</span><br><span class="line">let baz = Object.assign(&#123;&#125;, bar); // &#123; a: 1, b: 2 &#125;</span><br></pre></td></tr></table></figure></p>
<p>Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。</p>
<p>Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。(如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性)。</p>
<p>同样，如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let bar = &#123;a: 1, b: 2&#125;;</span><br><span class="line">let baz = &#123;...bar, ...&#123;a:2, b: 4&#125;&#125;;  // &#123;a: 2, b: 4&#125;</span><br></pre></td></tr></table></figure></p>
<p>利用上述特性就可以很方便的修改对象的部分属性。在redux中的reducer函数规定必须是一个纯函数（如果不是很清楚什么是纯函数的可以参考这里），reducer中的state对象要求不能直接修改，可以通过扩展运算符把修改路径的对象都复制一遍，然后产生一个新的对象返回。</p>
<p>这里有点需要注意的是扩展运算符对对象实例的拷贝属于一种浅拷贝。肯定有人要问什么是浅拷贝？我们知道javascript中有两种数据类型，分别是基础数据类型和引用数据类型。基础数据类型是按值访问的，常见的基础数据类型有Number、String、Boolean、Null、Undefined，这类变量的拷贝的时候会完整的复制一份；引用数据类型比如Array，在拷贝的时候拷贝的是对象的引用，当原对象发生变化的时候，拷贝对象也跟着变化，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let obj1 = &#123; a: 1, b: 2&#125;;</span><br><span class="line">let obj2 = &#123; ...obj1, b: &apos;2-edited&apos;&#125;;</span><br><span class="line">console.log(obj1); // &#123;a: 1, b: 2&#125;</span><br><span class="line">console.log(obj2); //  &#123;a: 1, b: &quot;2-edited&quot;&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面这个例子扩展运算符拷贝的对象是基础数据类型，因此对obj2的修改并不会影响obj1，如果改成这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let obj1 = &#123; a: 1, b: 2, c: &#123;nickName: &apos;d&apos;&#125;&#125;;</span><br><span class="line">let obj2 = &#123; ...obj1&#125;;</span><br><span class="line">obj2.c.nickName = &apos;d-edited&apos;;</span><br><span class="line">console.log(obj1); // &#123;a: 1, b: 2, c: &#123;nickName: &apos;d-edited&apos;&#125;&#125;</span><br><span class="line">console.log(obj2); // &#123;a: 1, b: 2, c: &#123;nickName: &apos;d-edited&apos;&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里可以看到，对obj2的修改影响到了被拷贝对象obj1，原因上面已经说了，因为obj1中的对象c是一个引用数据类型，拷贝的时候拷贝的是对象的引用。</p>
<p>数组的扩展运算符<br>扩展运算符同样可以运用在对数组的操作中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">可以将数组转换为参数序列</span><br><span class="line">function add(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const numbers = [4, 38];</span><br><span class="line">add(...numbers) // 42</span><br><span class="line"></span><br><span class="line">可以复制数组</span><br><span class="line">如果直接通过下列的方式进行数组复制是不可取的：</span><br><span class="line"></span><br><span class="line">const arr1 = [1, 2];</span><br><span class="line">const arr2 = arr1;</span><br><span class="line">arr2[0] = 2;</span><br><span class="line">arr1 // [2, 2]</span><br><span class="line"></span><br><span class="line">原因上面已经介绍过，用扩展运算符就很方便：</span><br><span class="line"></span><br><span class="line">const arr1 = [1, 2];</span><br><span class="line">const arr2 = [...arr1];</span><br><span class="line"></span><br><span class="line">还是记住那句话：扩展运算符(…)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中，这里参数对象是个数组，数组里面的所有对象都是基础数据类型，将所有基础数据类型重新拷贝到新的数组中。</span><br><span class="line"></span><br><span class="line">扩展运算符可以与解构赋值结合起来，用于生成数组</span><br><span class="line">const [first, ...rest] = [1, 2, 3, 4, 5];</span><br><span class="line">first // 1</span><br><span class="line">rest  // [2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">需要注意的一点是：</span><br><span class="line"></span><br><span class="line">如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</span><br><span class="line"></span><br><span class="line">const [...rest, last] = [1, 2, 3, 4, 5];</span><br><span class="line">// 报错</span><br><span class="line">const [first, ...rest, last] = [1, 2, 3, 4, 5];</span><br><span class="line">// 报错</span><br><span class="line"></span><br><span class="line">扩展运算符还可以将字符串转为真正的数组</span><br><span class="line">[...&apos;hello&apos;]</span><br><span class="line">// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">任何 Iterator 接口的对象（参阅 Iterator 一章），都可以用扩展运算符转为真正的数组</span><br><span class="line">这点说的比较官方，大家具体可以参考阮一峰老师的ECMAScript 6入门教程。</span><br><span class="line"></span><br><span class="line">比较常见的应用是可以将某些数据结构转为数组,比如：</span><br><span class="line"></span><br><span class="line">// arguments对象</span><br><span class="line">function foo() &#123;</span><br><span class="line">  const args = [...arguments];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>用于替换es5中的Array.prototype.slice.call(arguments)写法。</p>
<h1 id="promise-和-generator"><a href="#promise-和-generator" class="headerlink" title="promise 和 generator"></a>promise 和 generator</h1><p>function firstPromise(){<br>  return new Promise(function(resolve,reject){<br>       setTimeout(function(){<br>         resolve(“this is data”);<br>       },5000);<br>  });<br>}</p>
<p>function *foo() {<br>    var x = 1 + (yield firstPromise);<br>    console.log(x+”one”);<br>}<br>var action=foo();<br>var abc=action.next().value;</p>
<p>abc().then(function(data){console.log(data)});<br>var firstObj=action.next(10);<br>console.log(firstObj.value,firstObj)</p>
<h1 id="promise-搭配-async-function"><a href="#promise-搭配-async-function" class="headerlink" title="promise 搭配 async function"></a>promise 搭配 async function</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> callbackResolve=<span class="function"><span class="params">()</span>=&gt;</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">redireact</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">  callbackResolve=resolve;</span><br><span class="line">&#125;);</span><br><span class="line">  <span class="comment">//如果不执行 callbackResolve，后面的log 代码就被暂停了</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"in"</span>);</span><br><span class="line">&#125;</span><br><span class="line">redireact();</span><br><span class="line">callbackResolve();</span><br></pre></td></tr></table></figure>
      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  
  
  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/4/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2015-2022
        Steady
      </li>
      <li>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
        
        <span>
  <i>PV:<span id="busuanzi_value_page_pv"></span></i>
  <i>UV:<span id="busuanzi_value_site_uv"></span></i>
</span>
        
      </li>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
    <div class="to_top">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>
      </div>
    </main>
      <aside class="sidebar">
        <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="Steady&#39;blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2019/about.me/index.html">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search" title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
      </aside>
      <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
      <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.justifiedGallery.min.js"></script>
<script src="/js/lazyload.min.js"></script>
<script src="/js/busuanzi-2.3.pure.min.js"></script>
<script src="/js/share.js"></script>

<script src="/fancybox/jquery.fancybox.min.js"></script>



<script>
  try {
    var typed = new Typed("#subtitle", {
    strings: ['面朝大海，春暖花开','愿你一生努力，一生被爱','想要的都拥有，得不到的都释怀'],
    startDelay: 0,
    typeSpeed: 200,
    loop: true,
    backSpeed: 100,
    showCursor: true
    });
  } catch (err) {
  }
  
</script>




<script>
  var ayerConfig = {
    mathjax: false
  }
</script>

<script src="/js/ayer.js"></script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>




<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>
  </div>
</body>

</html>