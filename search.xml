<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>前端性能优化(偏运维篇) </title>
    <url>/2022/07/18/Untitled-1/</url>
    <content><![CDATA[<p>#前端性能优化(偏运维篇)</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>   在日常工作中，前端和运维沟通不会太频繁，大多数时候是前端项目在测试环境、生产环境部署、CI/CD集成的时候会做一些沟通，无非就是提供一些shell ci语句，配置一下Nginx转发。<br>   但实际上遇到性能优化的时候，前端和运维两个部门有太多优化点需要一起来治理和维护。前端的性能优化会更直接与用户的体验挂钩。从用户体验侧来说，前端服务 5s 的加载时间优化缩减 80%(1s) 与后端服务 50ms 的响应优化缩减 80%(10ms) 相比，用户的体验提升会更大。因此很多时候，与体验相关的性能的瓶颈会出现在前端。<br>   面试的一个经典题目：”从用户在浏览器地址栏输入网址，到看到整个页面，中间发生了哪些事情？” 这个问题看似简单，但实际要说明白这个过程，需要较强的技术能力。在这个过程中，也包含了众多前端优化的细节点。<br>   下面就由一个前端同学的视角来展开聊聊，如何优化前端性能。</p>
<h1 id="为什么要解决性能问题"><a href="#为什么要解决性能问题" class="headerlink" title="为什么要解决性能问题"></a>为什么要解决性能问题</h1><p>几个好的案例</p>
<ol>
<li>亚马逊（美国最大电商公司）：通过调查得出，网页打开的速度每快100毫秒，就会让网站增加1%的收益</li>
<li>Pinterest（世界最大图片社交分享平台）：重建了他们的页面以实现性能优化，使感知等待时间减少了40％，从而将搜索引擎流量和注册量提高了15％</li>
<li>COOK（医疗贸易公司）：通过将平均页面加载时间减少850毫秒，发现他们能够将转化率提高7％，将跳出率降低7％</li>
</ol>
<p>从以上例子中，我们可以得出结论，网站的性能极度影响业务结果。</p>
<h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><p>  前端缓存是解决性能的一把利刃，同时也是前端bug的重灾区，运维同学如果没有设置好缓存，那么就会导致前端缓存bug。所以有必要一起来学习下前端缓存</p>
<p>  1）.强缓存 </p>
<p>  我们先看图1<br>    <img src="/images/pasted-21.png" alt="upload successful"><br>   再看图2<br>    <img src="/images/pasted-22.png" alt="upload successful"><br>    图1的缓存使用了memory cache，而图2使用了disk cache</p>
<p>   谁决定这个资源「from disk cache」与「from memory cache」？<br>   当然，最终决定使用哪种缓存的应该是客户端，也就是浏览器了。浏览器对于缓存什么策略或者机制？</p>
<p>   三级缓存原理</p>
<ul>
<li><p>先去内存看，如果有，直接加载</p>
</li>
<li><p>如果内存没有，择取硬盘获取，如果有直接加载</p>
</li>
<li><p>如果硬盘也没有，那么就进行网络请求</p>
</li>
<li><p>加载到的资源缓存到硬盘和内存</p>
<p>比如：访问静态资源=&gt; 200 =&gt; 关闭tab栏；再次访问同样一个静态资源=&gt; 200(from disk cache) =&gt; 刷新页面 =&gt; 200(from memory cache);</p>
<p>已上两种浏览器缓存，都属于强缓存类型，遵守强缓存规则</p>
<p>在强缓存的情况下，浏览器不会向服务器发送请求，而是直接从本地缓存中读取内容，这个“本地”也就是我们在 Chrome DevTools 上看到的「from disk cache」与「from memory cache」<br>与其相关的响应头则是 Expires 和 Cache-Control。在 Expires 上可以设置一个过期时间，浏览器通过将其与当前本地时间对比，判断资源是否过期，未过期则直接从本地取即可。而 Cache-Control 则可以通过给它设置一个 max-age，来控制过期时间。例如，max-age=300 就是表示在响应成功后 300 秒内，资源请求会走强缓存。<br>运维同学，需要注意前端页面html的请求，大多数情况下都是不需要设置强缓存的，那么Cache-Control需要设置为no-store。</p>
</li>
<li><p>no-cache 和 no-store 的区别</p>
<p>no-cache 和 no-store 用作控制缓存，被服务器通过响应头 Cache-Control 传递给客户端<br>no-store永远都不要在客户端存储资源，永远都去原始服务器去获取资源。<br>no-cache可以在客户端存储资源，每次都必须去服务端做新鲜度校验，来决定从服务端获取新的资源（200）还是使用客户端缓存（304）。也就是所谓的协商缓存。</p>
<p>一般情况下对于 index.html 或者现代构建环境下不加 hash 的静态资源都需要设置 Cache-Control: no-cache，用来强制每次在服务器端的新鲜度校验。甚至直接设置no-store来及时保持html的新鲜度，为了任何情况下获取html文档head标签中最新的hash静态资源。比如，对于chrome，no-cache用于在重新访问时重新加载页面，但如果您返回历史记录（后退按钮），它仍然会缓存它，不会发起网络请求。比如下图就是生产环境index.html的响应头设置<br><img src="/images/pasted-24.png" alt="upload successful"></p>
</li>
</ul>
<p>  2）.协商缓存</p>
<p>  刚才我们设置的强缓存，也有过期失效的时候。这个时候就需要通过发起请求到服务器询问一下，该资源是否有过期，如果没有过期，就可以避免发起不必要的静态资源http请求，导致用户需要等待下载完成。<br>  一种协防缓存的方式是：服务器第一次响应时返回 Last-Modified，而浏览器在后续请求时带上其值作为 If-Modified-Since，相当于问服务端：XX 时间点之后，这个资源更新了么？服务器根据实际情况回答即可：更新了（状态码 200）或没更新（状态码 304）。</p>
<p>上面是通过时间来判断是否更新，如果更新时间间隔过短，例如 1s 一下，那么使用更新时间的方式精度就不够了。所以还有一种是通过标识 —— ETag。服务器第一次响应时返回 ETag，而浏览器在后续请求时带上其值作为 If-None-Match。一般会用文件的 MD5 作为 ETag。</p>
<p>  3）.一张图看懂强缓存和协商缓存如何工作的<br><img src="/images/pasted-23.png" alt="浏览器缓存流程图"></p>
<p>  4）.总结<br> 运维同学需要熟悉缓存的设置，才能在生产环境中帮助业务提升缓存的命中，减少网络请求</p>
<h1 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h1><p>访问一个页面第一步就是检查缓存，当缓存没有命中，我们才能真正发起一个网络请求。</p>
<p>1）.HTTP 2.0</p>
<p>HTTP 2.0 相⽐于 HTTP 1.X，可以说是⼤幅度提⾼了 web 的性能。<br>在 HTTP 1.X 中，为了性能考虑，我们会引⼊雪碧图、将⼩图内联、使⽤多个域名等等的⽅<br>式。这⼀切都是因为浏览器限制了同⼀个域名下的请求数量，当⻚⾯中需要请求很多资源的<br>时候，队头阻塞（Head of line blocking）会导致在达到最⼤请求数量时，剩余的资源需要等<br>待其他资源请求完成后才能发起请求。<br>你可以通过 <a href="https://http2.akamai.com/demo" target="_blank" rel="noopener">https://http2.akamai.com/demo</a> 感受下 HTTP 2.0 ⽐ HTTP 1.X 到底快了多少。</p>
<p><img src="/images/pasted-25.png" alt="upload successful"><br>在 HTTP 1.X 中，因为队头阻塞的原因，你会发现请求是这样的</p>
<p><img src="/images/pasted-28.png" alt="upload successful"></p>
<p>在 HTTP 2.0 中，因为引⼊了多路复⽤，你会发现请求是这样的</p>
<p><img src="/images/pasted-27.png" alt="upload successful"></p>
<p>⼆进制传输<br>HTTP 2.0 中所有加强性能的核⼼点在于此。在之前的 HTTP 版本中，我们是通过⽂本的⽅式<br>传输数据。在 HTTP 2.0 中引⼊了新的编码机制，所有传输的数据都会被分割，并采⽤⼆进制<br>格式编码</p>
<p><img src="/images/pasted-29.png" alt="upload successful"></p>
<p>运维同学们看到这里，是不是已经迫不及待要开启HTTP 2.0了</p>
<p>2）.DNS预解析</p>
<p>DNS 的作⽤就是通过域名查询到具体的 IP。<br>因为 IP 存在数字和英⽂的组合（IPv6），很不利于⼈类记忆，所以就出现了域名。你可以把<br>域名看成是某个 IP 的别名，DNS 就是去查询这个别名的真正名称是什么。<br>在 TCP 握⼿之前就已经进⾏了 DNS 查询，这个查询是操作系统⾃⼰做的。当你在浏览器中<br>想访问 <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a> 时，会进⾏⼀下操作：</p>
<ol>
<li>操作系统会⾸先在本地缓存中查询</li>
<li>没有的话会去系统配置的 DNS 服务器中查询</li>
<li>如果这时候还没得话，会直接去 DNS 根服务器查询，这⼀步查询会找出负责 com 这个<br>⼀级域名的服务器</li>
<li>然后去该服务器查询 google 这个⼆级域名</li>
<li>接下来三级域名的查询其实是我们配置的，你可以给 www 这个域名配置⼀个 IP，然后还<br>可以给别的三级域名配置⼀个 IP<br>以上介绍的是 DNS 迭代查询，还有种是递归查询，区别就是前者是由客户端去做请求，后者<br>是由系统配置的 DNS 服务器做请求，得到结果后将数据返回给客户端。<br>PS：DNS 是基于 UDP 做的查询</li>
</ol>
<p>这里我们需要了解的是：</p>
<p>首先，DNS 解析流程可能会很长，耗时很高，所以整个 DNS 服务，包括客户端都会有缓存机制，这个作为前端不好涉入；<br>其次，在 DNS 解析上，前端还是可以通过浏览器提供的其他手段来“加速”的。<br><a href="https://www.w3.org/TR/resource-hints/#dns-prefetch" target="_blank" rel="noopener">DNS Prefetch</a><br>就是浏览器提供给我们的一个 API。它是 Resource Hint 的一部分。它可以告诉浏览器：过会我就可能要去 yourwebsite.com 上下载一个资源啦，帮我先解析一下域名吧。这样之后用户点击某个按钮，触发了 yourwebsite.com 域名下的远程请求时，就略去了 DNS 解析的步骤。使用方式很简单：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"dns-prefetch"</span> href=<span class="string">"//yourwebsite.com"</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>当然，浏览器并不保证一定会去解析域名，可能会根据当前的网络、负载等状况做决定。标准里也明确写了,user agent SHOULD resolve as early as possible。</p>
<p>3）.预先建立连接</p>
<p>我们知道，建立连接不仅需要 DNS 查询，还需要进行 TCP 协议握手，有些还会有 TLS/SSL 协议，这些都会导致连接的耗时。使用 Preconnect 可以帮助你告诉浏览器：“我有一些资源会用到某个源（origin），你可以帮我预先建立连接。”</p>
<p>根据规范，当你使用 Preconnect 时，浏览器大致做了如下处理：</p>
<ul>
<li>首先，解析 Preconnect 的 url；</li>
<li>其次，根据当前 link 元素中的属性进行 cors 的设置；</li>
<li>然后，默认先将 credential 设为 true，如果 cors 为 Anonymous 并且存在跨域，则将 credential 置为 false；</li>
<li>最后，进行连接。</li>
</ul>
<p>使用 Preconnect 只需要将 rel 属性设为 preconnect 即可：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"preconnect"</span> href=<span class="string">"//sample.com"</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>当然，你也可以设置 CORS：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"preconnect"</span> href=<span class="string">"//sample.com"</span> crossorigin&gt;</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，标准并没有硬性规定浏览器一定要（而是 SHOULD）完成整个连接过程，与 DNS Prefetch 类似，浏览器可以视情况完成部分工作。</p>
<p>4) .服务器应该避免过多重定向</p>
<p>重定向是一个比较常用的技术手段。在一些情况下，你可能进行了服务迁移，修改了原有的 url。这时候就可以使用重定向，把访问原网址的用户重定向到新的 url。还有是在一些登录场景下，会使用到重定向技术。</p>
<p>重定向分为 301 的永久重定向和 302 的临时重定向。建议贴合语义，例如服务迁移的情况下，使用 301 重定向。对 SEO 也会更友好。</p>
<p>运维同学需要注意在配置反向代理服务器时，不要滥用重定向。曾今也见过有业务在访问后重定向 3 次的情况，其实里面有些是不必要的。每次重定向都是有请求耗时的，建议避免过多的重定向。</p>
<p>5) .静态资源使用CDN服务</p>
<p>当我们实际把网络包发向我们的目标地址时，肯定希望越快到达目的地越好（对应的，也会希望越快获得响应）。而网络传输是有极限的，同样一个北京的用户，访问北京的服务器显然要比广州快很多。同时，服务的负载也会影响响应的速度。</p>
<p>对于静态资源，我们可以考虑通过 CDN 来降低时延。</p>
<p>对于使用 CDN 的资源，DNS 解析会将 CDN 资源的域名解析到 CDN 服务的负载均衡器上，负载均衡器可以通过请求的信息获取用户对应的地理区域，从而通过负载均衡算法，在背后的诸多服务器中，综合选择一台地理位置近、负载低的机器来提供服务。例如为北京联通用户解析北京的服务器 IP。这样，用户在之后访问 CDN 资源时都是访问北京服务器，距离近，速度快。</p>
<p>想了解更多 CDN 的工作方式可以阅读<a href="https://developer.aliyun.com/article/577708" target="_blank" rel="noopener">这篇文章</a></p>
<h1 id="BFF-amp-SSR"><a href="#BFF-amp-SSR" class="headerlink" title="BFF&amp;SSR"></a>BFF&amp;SSR</h1><p>许多大厂的组织架构都有大前端部门的存在，随着 NodeJS 的兴起，很多业务都引入了基于 NodeJS 的 BFF 来为前端（客户端端）提供服务或者是为了SEO需要使用服务器渲染框架SSR比如next.js(React)，nuxt.js(Vue)</p>
<p>1.BFF层</p>
<ul>
<li><p>Nodejs BFF 模式下，整体分工很清晰，后端通过 php,go 等语言负责服务实现，理想情况下给前端提供的是基于领域模型的 RPC 接口，前端则在 BFF 层直接调用服务端 RPC 接口拿到数据，按需加工消费数据。基于 BFF 模式的研发，很适合拥有前端技术背景的全栈型工程师。这种模式的好处很明显，后端可以专注于业务领域，更多从领域模型的视角去思考问题，页面视角的数据则交给前端型全栈工程师去搞定。领域模型与页面数据是两种思维模式，通过 BFF 可以很好地解耦开，后端的service可以在Node这层分发成多端接口(app,小程序,h5等)，省去了字段撕逼问题，让彼此更专业高效。</p>
</li>
<li><p>适合新项目孵化，类似前端小程序，用Node开发接口。1个前端人员就能搞定，节省人力成本，快速迭代上线。</p>
</li>
<li><p>Nodejs人才问题，前端会Node.js后端的人才特别多，虽然不能算专业但至少是能做业务，稍加熟悉也能成为不错的人才。类似Golang，Python基本想要招直接可用的人才，比Node.js成本高。可以让前端人员投入更多的全栈开发需求项目中，动态平衡人员紧缺问题。</p>
</li>
<li><p>Nodejs 语言的优势，由于 Node.js 遵循事件驱动的非阻塞I/O模型，与传统的后端技术相比，Node.js 能够处理大量的服务器请求，支持高并发。</p>
</li>
<li><p>服务端设计的API接口，面向通用服务，不需要面向UI。各种端的UI差异，由BFF层负责适配。这样的话，可以让后端更加专注于业务逻辑和数据服务，不需要操心各种端的差异</p>
</li>
<li><p>在toB业务需求里，很多时候前后端工作量经常匹配不到一起去，Node 增加了这中间的弹性，避免出现一个需求前端过度依赖后端开发进度的情况</p>
</li>
<li><p>原来的模式是由后端推着前端走，现在的模式是产品和前端拉着后端走，思维模式是完全不一样的。</p>
</li>
</ul>
<p>2.SSR</p>
<ul>
<li><p>Next.js 是 React 服务端渲染（SSR）应用框架. 用于构建 SEO 友好的 SPA 应用.</p>
<p>支持两种预渲染方式, 静态生成和服务器端渲染.<br>基于页面的路由系统, 路由零配置<br>自动代码拆分. 优化页面加载速度.<br>支持静态导出, 可将应用导出为静态网站.<br>内置 CSS-in-JS 库 styled-jsx<br>方案成熟, 可用于生产环境, 世界许多公司都在使用<br>应用部署简单, 拥有专属部署环境 Vercel, 也可以部署在其他环境</p>
</li>
</ul>
<ul>
<li><p>SSR预渲染概述</p>
<p>预渲染是指数据和HTML的拼接在服务器端提前完成.<br>预渲染可以使 SEO 更加友好.<br>预渲染会带来更好的用户体验, 可以无需运行 JavaScript 即可查看应用程序UI.<br>预渲染的两种形式</p>
<p>在 Next.js 中支持两种形式的预渲染: 静态生成和服务器端渲染.<br>静态生成和服务器端渲染是生成 HTML 的时机不同.<br>静态生成: 静态生成是在构建时生成 HTML. 以后的每个请求都共用构建时生成好的 HTML.<br>服务器端渲染: 服务器端渲染是在请求时生成 HTML. 每个请求都会重新生成 HTML.<br>两种预渲染方式的选择</p>
<p>Next.js 允许开发者为每个页面选择不同的预渲染方式. 不同的预渲染方式拥有不同的特点. 应根据场景进行渲染.<br>但建议大多数页面建议使用静态生成.<br>静态生成一次构建, 反复使用, 访问速度快. 因为页面都是事先生成好的.<br>适用场景：营销页面、博客文章、电子商务产品列表、帮助和文档<br>服务器端渲染访问速度不如静态生成快, 但是由于每次请求都会重新渲染, 所以适用数据频繁更新的页面或页面内容随请求变化而变化的页面</p>
</li>
</ul>
<p>以下是前端同学在写服务端时，遇到的比较常见问题,我们应该怎样快速排查Nodejs作为服务端产生的问题呢？</p>
<ul>
<li>使用中间件没有调用next()方法，导致不能执行下一个中间件，请求超时；</li>
<li>async await 的不当使用导致并行请求被串行化了；</li>
<li>频繁地 JSON.parse 和 JSON.stringify 大对象，使CPU使用率上升；</li>
<li>正则表达式的灾难性回溯，使CPU使用率上升，阻塞运算；</li>
<li>闭包导致的内存泄漏，导致内存溢出；</li>
<li>CPU 密集型任务导致事件循环 delay 严重；</li>
<li>未捕获的异常导致进程频繁退出，守护进程（pm2/supervisor）又将进程重启，频繁启停非常消耗资源；</li>
</ul>
<h2 id="利用node-clinic工具"><a href="#利用node-clinic工具" class="headerlink" title="利用node-clinic工具"></a>利用node-clinic工具</h2><p>node-clinic（简称 clinic） 是一个开箱即用的 Node.js 应用诊断工具。</p>
<p>首先，安装 Node.js@9+<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ nvm install <span class="number">9</span></span><br></pre></td></tr></table></figure></p>
<p>全局安装 clinic：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ npm i clinic -g</span><br></pre></td></tr></table></figure></p>
<p>创建测试代码：app.js</p>
<p>使用 clinic doctor 启动并诊断 Node.js 应用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ clinic doctor -- node app.js</span><br></pre></td></tr></table></figure>
<p>使用 ab 压测：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ ab -c <span class="number">10</span> -n <span class="number">200</span> <span class="string">"http://localhost:3000/"</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ clinic flame -- node app.js</span><br></pre></td></tr></table></figure>
<p>可以用以下命令代替：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">$ clinic flame --collect-only -- node app.js # 收集数据</span><br><span class="line">$ clinic flame --visualize-only PID.flamegraph # 将数据生成fire图</span><br></pre></td></tr></table></figure></p>
<h2 id="alinode（Node-js-性能平台）"><a href="#alinode（Node-js-性能平台）" class="headerlink" title="alinode（Node.js 性能平台）"></a>alinode（Node.js 性能平台）</h2><p>Node.js 性能平台（Node.js Performance Platform）是面向中大型 Node.js 应用提供性能监控、安全提醒、故障排查、性能优化等服务的整体性解决方案。凭借对 Node.js 内核深入的理解，我们提供完善的工具链和服务，协助客户主动、快速发现和定位线上问题。</p>
<p>推荐访问官网了解更多alinode性能平台 <a href="https://www.aliyun.com/product/nodejs" target="_blank" rel="noopener">https://www.aliyun.com/product/nodejs</a></p>
<h1 id="浏览器页面渲染"><a href="#浏览器页面渲染" class="headerlink" title="浏览器页面渲染"></a>浏览器页面渲染</h1><p>在前面的缓存章节，我们有提到对index.html的缓存，确保我们能加载正确的静态资源。我们在这个章节，开始聊聊index.html被请求回来后，是怎么触发浏览器页面渲染流程的</p>
<ul>
<li><p>浏览器的渲染机制⼀般分为以下⼏个步骤</p>
<ol>
<li>处理 HTML 并构建 DOM 树。</li>
<li>处理 CSS 构建 CSSOM 树。</li>
<li>将 DOM 与 CSSOM 合并成⼀个渲染树。</li>
<li>根据渲染树来布局，计算每个节点的位置。</li>
<li>调⽤ GPU 绘制，合成图层，显示在屏幕上。<br><img src="/images/pasted-34.png" alt="upload successful"></li>
</ol>
</li>
<li><p>标签执行顺序</p>
<p>当 HTML 解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地⽅重新开始。也就是说，如果你想⾸屏渲染的越快，就越不应该在⾸屏就加载过多JS ⽂件。并且 CSS 也会影响JS 的执⾏，只有当解析完样式表才会执⾏ JS，所以也可以认为这种情况下，CSS 也会暂停构建 DOM。</p>
<p>但是我们可以script 标签上添加defer或者async。defer 会在 HTML 解析完成后，按照脚本出现的次序再顺序执行；而 async 则是下载完成就立即开始执行，同时阻塞页面解析，不保证脚本间的执行顺序。</p>
<p>所以如果我们的页面首屏渲染慢，可以把 CSS 样式表放在 <head><meta name="generator" content="Hexo 3.8.0"> 之中（即页面的头部），把 JavaScript 脚本放在 </head><body> 的最后（即页面的尾部），还可以尝试让没那么重要的js脚本添加defer属性来避免阻塞页面解析。  </body></p>
</li>
<li><p>运维可以利用Nginx开启文档压缩</p>
<p>使用文本压缩算法（例如 gzip）进行文本的压缩</p>
<p>  <img src="/images/pasted-37.png" alt="upload successful"></p>
<p>  可以看到home这个html请求的真实资源 size是154KB,经过gzip压缩后缩减为了30KB<br>  <img src="/images/pasted-36.png" alt="upload successful"></p>
</li>
</ul>
<h1 id="页面静态资源"><a href="#页面静态资源" class="headerlink" title="页面静态资源"></a>页面静态资源</h1><p>  网页上的静态资源包括，JavaScript，css,image,font,audio,video等等，但他们的优化方向都比较相似</p>
<ul>
<li>压缩静态资源的体积大小</li>
<li>减少不必要的请求，比如对列表图片做懒加载，滚动到可视区域才发起真是的静态资源网络请求</li>
<li><p>cdn的分发加速，缓存机制</p>
<p>前端工程化，目前模块化打包，用得最多的就是webpack。webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。<br>我们可以使用webpack提供的各种plugin工具，来对我们的静态资源做优化：压缩，模块打包，Tree Shaking等等。比如，可以使用按需加载功能，尤其在当下组件化盛行的潮流里，哪些页面需要该组件才会发起一个网络请求静态资源，不会全部一次性加载完，组件的按需加载就可能会包括了 JavaScript 脚本、CSS 样式表、图标图片等。<br>对图片的优化，我们可以利用cdn提供的裁剪和格式转化功能进行页面渲染优化，比如：<a href="https://cdn.weipaitang.com/skywebp/fapai/tupian/image/20220726/77341d9a31a04681bdee06b754070b49-W3024H3024/w/320" target="_blank" rel="noopener">https://cdn.weipaitang.com/skywebp/fapai/tupian/image/20220726/77341d9a31a04681bdee06b754070b49-W3024H3024/w/320</a><br>这张图片就使用了cdn的webp格式转换，并且把3024<em>3024像素裁剪为了320</em>320尺寸，总体积压缩了50倍，极大减少了网络请求，加快了图片的展示，提高了用户体验。所以，对于其它类型的静态资源优化可以举一反三。</p>
</li>
</ul>
<p><img src="/images/pasted-43.png" alt="upload successful"></p>
<p>参考资料： <a href="https://www.webpackjs.com/" target="_blank" rel="noopener">https://www.webpackjs.com/</a></p>
<h1 id="客户端优化的案例"><a href="#客户端优化的案例" class="headerlink" title="客户端优化的案例"></a>客户端优化的案例</h1><p> 在我们电商APP日常开发中，经常会有一些分享图片给好友的需求。要求分享的图片和客户端当前展示的效果差不多。这个时候我们往往会让服务端去做一个海报服务接口，让每个用户在分享的时候调用生成海报服务接口，合成一张分享图片。这个时候我们的性能问题就出现了，如果一个活动分享的人够多，那么我们海报服务的服务器CPU占用率会直线飙升，甚至让挂掉。<br> 在2022年，我们自己手里的手机，其实已经有非常强大的算力。像这种合成图片的功能，我们实际上是可以把算力分散到客户端的，不要让请求海报服务造成瓶颈，让用户长时间等待服务端合成图片，造成非常不好的用户体验。<br> 此例子只是抛砖迎玉，提醒我们应该把此类需要大量运算的功能做到客户端中，不应该让服务器性能成为阻塞。<br><img src="/images/pasted-39.png" alt="upload successful">此图出自微拍堂APP</p>
<h1 id="为什么要做预加载"><a href="#为什么要做预加载" class="headerlink" title="为什么要做预加载"></a>为什么要做预加载</h1><ol>
<li><p>当一个项目越来越大的时候，往往会导致项目的首屏加载时间越来越长，我们可以应用 ssr，懒加载等方案来减少首屏的加载时间。</p>
<p>随之带来的问题就是非首屏会有一定的初始化时间。我们可能会应用 loading 或者骨架屏来优化加载时的体验。在混合开发中，我们希望尽可能地与原生体验接近。在不同页面间切换的时候尽可能地减少 loading 时间。</p>
<p>通过预加载资源可以减少页面切换时的等待时间。与纯页面应用有所区别的是，在纯网页应用中，一个页面就是一个进程，只包含一个 webview。而在混合开发中，我们可以借助主进程来开启多个渲染进程。对于网页来说即开启多个 webview。我们可以创建一个新的 webview 进程来加载即将打开的页面，在新的 webview 中，我们完成了页面的预加载和预渲染。在跳转的时候，通过切换 webview 的层级即可跳转到新页面。在回退页面的时候，也可以通过切换 webview 层级来回到原来的页面。</p>
<p>每次发布的时候 app 中存在一定数量的缓存 webview，所以我们在发布新项目的时候需要注意兼容旧版本的代码。</p>
<p>一般情况下 webview 的底色是白色的，但是有些页面的背景是深色的，在页面加载完之前，可能会显示 webview 的底色，通过调用 jsbridge，我们可以修改 webview 的底色。在业务页面中，我们可以配置当前页面的 webview 底色，到达渲染过程更丝滑的目的，不会出现从白屏到有底色的界面的突兀感觉。</p>
<p>具体效果可以参考微拍堂APP,从原生首页点击商品 跳转到H5商品详情页的一个体验过程。</p>
</li>
<li><p>我们在之前的网络请求章节提到DNS prefetch技术，我们的静态资源也可以有相似的预加载优化</p>
<ul>
<li><p>Prefetch</p>
<p>用于标识下一个页面可能需要的资源，以及浏览器端应获取的资源，以便浏览器端可以在将来请求资源时提供更快的响应。由于仅仅是提前获取资源，因此浏览器不会对资源进行预处理，像 CSS 样式表、JavaScript 脚本这样的资源是不会自动执行并应用于当前文档的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"prefetch"</span> href=<span class="string">"/prefetch.js"</span> <span class="keyword">as</span>=<span class="string">"script"</span>&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>Prerender</p>
<p>用于标识下一个页面可能需要的资源，以及浏览器端应获取的资源，以便浏览器端可以在将来请求资源时提供更快的响应，同Prefetch不一样的点在于Prerender还会执行该资源。指定浏览器应该在后台预呈现(加载)指定的网页。因此，如果用户访问到这个页面，它会加速页面加载(因为页面已经加载了)。警告!这浪费了用户的带宽!只有在你绝对确定网页在用户旅途中的某个时刻是必需的时候才使用预渲染</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"prerender"</span> href=<span class="string">"//sample.com/nextpage.html"</span>&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>Preload</p>
<p>指定浏览器必须根据“as”属性给出的类型(以及与该类型关联的优先级)抢先获取和缓存指定的目标资源。同Prefetch的区别在于，Preload优先级更高。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"preload"</span> href=<span class="string">"./nextpage.js"</span> <span class="keyword">as</span>=<span class="string">"script"</span>&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Prefetch 和 Preload 区别 ？</p>
<ul>
<li>preload chunk 会在父 chunk 加载时，以并行方式开始加载。prefetch chunk 会在父 chunk 加载结束后开始加载。</li>
<li>preload chunk 具有中等优先级，并立即下载。prefetch chunk 在浏览器闲置时下载。</li>
<li>preload chunk 会在父 chunk 中立即请求，用于当下时刻。prefetch chunk 会用于未来的某个时刻。</li>
<li>浏览器支持程度不同。</li>
</ul>
</li>
</ul>
<pre><code>参考资料：https://www.w3.org/TR/resource-hints/，https://www.w3schools.com/tags/att_link_rel.asp
</code></pre><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>   前端的性能指标，现在有非常多的工具可以进行统计，浏览器也提供了Performance方法来检测页面性能的能力，完全可以自主开发一套前端性能监控平台。在这里推荐Google的一个网页性能分析工具pagespeed，输入<a href="https://pagespeed.web.dev/" target="_blank" rel="noopener">https://pagespeed.web.dev/</a>, 进入页面，输入想要分析的网址稍等片刻，便会有需要详细的分析，比如：网页的LCP,FID,CLS,FCP,INP,TTFB等指标</p>
<p><img src="/images/pasted-40.png" alt="upload successful"></p>
<p>并且还能给出网页的一个性能分析评分</p>
<p><img src="/images/pasted-41.png" alt="upload successful"></p>
<p>还能给出一些优化建议</p>
<p><img src="/images/pasted-42.png" alt="upload successful"></p>
<p>   最后，希望运维小伙伴们在阅读了《前端性能优化(偏运维篇)》后对前端的性能优化有更深入的了解</p>
]]></content>
  </entry>
  <entry>
    <title>常用正则</title>
    <url>/2022/02/21/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>今天胖头鱼试着把前端面试中常见的正则表达式相关的题都捞一遍，希望以后正则这个点直接过<br>1.提取连续重复的字符<br>币安原题 将有重复的字符提取出来，例如12323454545666，提取[ ‘23’, ‘45’, ‘6’ ]<br>正则结果</p>
<p>const collectRepeatStr = (str) =&gt; {<br>  let repeatStrs = []<br>  const repeatRe = /(.+)\1+/g</p>
<p>  str.replace(repeatRe, ($0, $1) =&gt; {<br>    $1 &amp;&amp; repeatStrs.push($1)<br>  })</p>
<p>  return repeatStrs<br>}</p>
<p>分析过程</p>
<p>题目中有几个关键信息是<br>连续重复的字符<br>连续重复的字符数的长度是不限的（如23、45是两位、6是一位）<br>那什么是连续重复呢？<br>11是连续重复、22也是连续重复、111当然也是。也就是说某些字符X之后一定也是跟着X，就叫连续重复。如果很明确知道X就是1，那么/11+/也就可以匹配了，但关键是这里的X是不明确的，怎么办呢？。<br>使用反向引用的正则知识可以很方便解决这个问题。<br>第一步，写出表示有一个字符重复的正则<br>// 这里的X可用.来表示，即所有的字符，并用括号进行引用，紧跟着反向应用\1，也就是体现了连续重复的意思啦<br>let repeatRe = /(.)\1/</p>
<p>console.log(repeatRe.test(‘11’)) // true<br>console.log(repeatRe.test(‘22’)) // true<br>console.log(repeatRe.test(‘333’)) // true<br>console.log(repeatRe.test(‘123’)) // false</p>
<p>第二步，写出表示有n个字符重复的正则<br>因为并不确定是要匹配11还是45 45所以括号内需要用量词+来体现n个重复字符，而反向引用本身也可以是大于一个的，例如 45 45 45</p>
<p>let repeatRe = /(.+)\1+/</p>
<p>console.log(repeatRe.test(‘11’)) // true<br>console.log(repeatRe.test(‘22’)) // true<br>console.log(repeatRe.test(‘333’)) // true<br>console.log(repeatRe.test(‘454545’)) // true<br>console.log(repeatRe.test(‘124’)) // false</p>
<p>第三步，提取所有连续重复的字符</p>
<p>const collectRepeatStr = (str) =&gt; {<br>  let repeatStrs = []<br>  const repeatRe = /(.+)\1+/g<br>  // 很多时候replace并不是用来做替换，而是做数据提取用<br>  str.replace(repeatRe, ($0, $1) =&gt; {<br>    $1 &amp;&amp; repeatStrs.push($1)<br>  })</p>
<p>  return repeatStrs<br>}</p>
<p>console.log(collectRepeatStr(‘11’)) // [“1”]<br>console.log(collectRepeatStr(‘12323’)) // [“23”]<br>console.log(collectRepeatStr(‘12323454545666’)) // [“23”, “45”, “6”]</p>
<ol start="2">
<li>实现一个trim函数<br>老生常谈的题了，这里我们用两种思路实现 去除字符串的首尾空格<br>正则结果</li>
</ol>
<p>// 去除空格法<br>const trim = (str) =&gt; {<br>  return str.replace(/^\s<em>|\s</em>$/g, ‘’)<br>}<br>// 提取非空格法<br>const trim = (str) =&gt; {<br>  return str.replace(/^\s<em>(.</em>?)\s*$/g, ‘$1’)<br>}</p>
<p>图片</p>
<p><img src="/images/pasted-13.png" alt="upload successful"><br>图片</p>
<p><img src="/images/pasted-14.png" alt="upload successful"><br>分析过程</p>
<p>初看题目我们脑海中闪过的做法是把空格部分删除掉，保留非空格的部分，但是也可以换一种思路，也可以把非空格的部分提取出来，不管空格的部分。接下来我们来写一下两种trim方法的实现<br>方式一、去除空格法</p>
<p>const trim = (str) =&gt; {<br>  return str.replace(/^\s<em>|\s</em>$/g, ‘’)<br>}</p>
<p>console.log(trim(‘  前端胖头鱼’)) // 前端胖头鱼<br>console.log(trim(‘前端胖头鱼  ‘)) // 前端胖头鱼<br>console.log(trim(‘  前端胖头鱼  ‘)) // 前端胖头鱼<br>console.log(trim(‘  前端 胖头鱼  ‘)) // 前端 胖头鱼</p>
<p>方式二、提取非空格法</p>
<p>const trim = (str) =&gt; {<br>  return str.replace(/^\s<em>(.</em>?)\s*$/g, ‘$1’)<br>}</p>
<p>console.log(trim(‘  前端胖头鱼’)) // 前端胖头鱼<br>console.log(trim(‘前端胖头鱼  ‘)) // 前端胖头鱼<br>console.log(trim(‘  前端胖头鱼  ‘)) // 前端胖头鱼<br>console.log(trim(‘  前端 胖头鱼  ‘)) // 前端 胖头鱼</p>
<ol start="3">
<li>数字价格千分位分割<br>将123456789变成123,456,789<br>这道题估计大家在面试和工作中也经常遇到，出现频率比较高。<br>正则结果</li>
</ol>
<p>‘123456789’.replace(/(?!^)(?=(\d{3})+$)/g, ‘,’) // 123,456,789<br>图片</p>
<p><img src="/images/pasted-15.png" alt="upload successful"><br>补充小数千分位支持<br>图片</p>
<p><img src="/images/pasted-16.png" alt="upload successful"><br>分析过程</p>
<p>题目意思大概是：<br>从后往前每三个数字前加一个逗号<br>开头不能加逗号(比如：123 最后不能变成,123)<br>是不是很符合(?=p)的规律呢？p可以表示每三个数字，要添加的逗号所处的位置正好是(?=p)匹配出来的位置。<br>第一步，尝试先把后面第一个逗号弄出来</p>
<p>let price = ‘123456789’<br>let priceReg = /(?=\d{3}$)/</p>
<p>console.log(price.replace(proceReg, ‘,’)) // 123456,789<br>第二步，把所有的逗号都弄出来<br>要把所有的逗号都弄出来，主要要解决的问题是怎么表示三个数字一组,也就是3的倍数。我们知道正则中括号可以把一个p模式变成一个小整体，所以利用括号的特性，可以这样写</p>
<p>let price = ‘123456789’<br>let priceReg = /(?=(\d{3})+$)/g</p>
<p>console.log(price.replace(priceReg, ‘,’)) // ,123,456,789</p>
<p>第三步，去掉首位的逗号，<br>上面已经基本上实现需求了，但是还不够，首位还会出现逗号，那怎么把首位的逗号去除呢？想想是不是有一个知识正好满足这个场景？没错(?!p)，就是他了，两者结合就是从后往前每三个数字的位置前添加逗号，但是这个位置不能是^首位。</p>
<p>let price = ‘123456789’<br>let priceReg = /(?!^)(?=(\d{3})+$)/g</p>
<p>console.log(price.replace(priceReg, ‘,’)) // 123,456,789</p>
<ol start="4">
<li>手机号3-4-4分割<br>将手机号18379836654转化为183-7983-6654<br>表单搜集场景，经常遇到的手机格式化<br>正则结果</li>
</ol>
<p>let mobile = ‘18379836654’<br>let mobileReg = /(?=(\d{4})+$)/g </p>
<p>console.log(mobile.replace(mobileReg, ‘-‘)) // 183-7983-6654</p>
<p>图片</p>
<p><img src="/images/pasted-17.png" alt="upload successful"><br>分析过程</p>
<p>有了上面数字的千分位分割法，做这个题相信会简单很多，也就是从后往前找到这样的位置：<br>每四个数字前的位置，并把这个位置替换为-</p>
<p>let mobile = ‘18379836654’<br>let mobileReg = /(?=(\d{4})+$)/g</p>
<p>console.log(mobile.replace(mobileReg, ‘-‘)) // 183-7983-6654</p>
<ol start="5">
<li>将字符串驼峰化<br>如下规则，将对应字符串变成驼峰写法</li>
<li><p>foo Bar =&gt; fooBar</p>
</li>
<li><p>foo-bar—- =&gt; fooBar</p>
</li>
<li><p>foo_bar__ =&gt; fooBar</p>
</li>
</ol>
<p>正则结果</p>
<p>const camelCase = (string) =&gt; {<br>  const camelCaseRegex = /[-_\s]+(.)?/g</p>
<p>  return string.replace(camelCaseRegex, (match, char) =&gt; {<br>    return char ? char.toUpperCase() : ‘’<br>  })<br>}</p>
<p>图片</p>
<p><img src="/images/pasted-18.png" alt="upload successful"><br>分析过程</p>
<p>分析题目的规律<br>每个单词的前面都有0个或者多个- 空格 _ 如(Foo、–foo、__FOO、_BAR、Bar)</p>
<ul>
<li><p>空格 <em>后面有可能不跟任何东西 如(__、–)<br>const camelCase = (string) =&gt; {<br>// 注意(.)?这里的?是为了满足条件2<br>const camelCaseRegex = /[-</em>\s]+(.)?/g</p>
<p>return string.replace(camelCaseRegex, (match, char) =&gt; {<br>  return char ? char.toUpperCase() : ‘’<br>})<br>}</p>
</li>
</ul>
<p>console.log(camelCase(‘foo Bar’)) // fooBar<br>console.log(camelCase(‘foo-bar–’)) // fooBar<br>console.log(camelCase(‘foo_bar__’)) // fooBar</p>
<ol start="6">
<li>将字符串首字母转化为大写，剩下为小写<br>例如 hello world 转为为Hello World<br>正则结果</li>
</ol>
<p>const capitalize = (string) =&gt; {<br>  const capitalizeRegex = /(?:^|\s+)\w/g</p>
<p>  return string.toLowerCase().replace(capitalizeRegex, (match) =&gt; match.toUpperCase())<br>}</p>
<p><img src="/images/pasted-12.png" alt="upload successful"></p>
<p>找到单词的首字母然后将其转化为大写字母就可以，单词前面可能是开头也可能是多个空格。</p>
<p>const capitalize = (string) =&gt; {<br>  const capitalizeRegex = /(?:^|\s+)\w/g</p>
<p>  return string.toLowerCase().replace(capitalizeRegex, (match) =&gt; match.toUpperCase())<br>}</p>
<p>console.log(capitalize(‘hello world’)) // Hello World<br>console.log(capitalize(‘hello WORLD’)) // Hello World</p>
<p>7.通过name获取url query参数<br>正则结果</p>
<p>const getQueryByName = (name) =&gt; {<br>  const queryNameRegex = new RegExp(<code>[?&amp;]${name}=([^&amp;]*)(&amp;|$)</code>)<br>  const queryNameMatch = window.location.search.match(queryNameRegex)<br>  // 一般都会通过decodeURIComponent解码处理<br>  return queryNameMatch ? decodeURIComponent(queryNameMatch[1]) : ‘’<br>}</p>
<p>分析过程</p>
<p>url query上的参数 name=前端胖头鱼 所处的位置可能是<br>紧跟着问号 ?name=前端胖头鱼&amp;sex=boy<br>在最后的位置 ?sex=boy&amp;name=前端胖头鱼<br>在1和2之间 ?sex=boy&amp;name=前端胖头鱼&amp;age=100<br>所以只要处理三个地方基本就可以通过正则来取了<br>name前面只能是?或者&amp;<br>value的值可以除了是&amp;以为的任意东西<br>value后面只能是跟着&amp;或者是结束位置</p>
<p>const getQueryByName = (name) =&gt; {<br>  const queryNameRegex = new RegExp(<code>[?&amp;]${name}=([^&amp;]*)(?:&amp;|$)</code>)<br>  const queryNameMatch = window.location.search.match(queryNameRegex)<br>  // 一般都会通过decodeURIComponent解码处理<br>  return queryNameMatch ? decodeURIComponent(queryNameMatch[1]) : ‘’<br>}<br>// 1. name在最前面<br>// <a href="https://juejin.cn/?name=前端胖头鱼&amp;sex=boy" target="_blank" rel="noopener">https://juejin.cn/?name=前端胖头鱼&amp;sex=boy</a><br>console.log(getQueryByName(‘name’)) // 前端胖头鱼</p>
<p>// 2. name在最后<br>// <a href="https://juejin.cn/?sex=boy&amp;name=前端胖头鱼" target="_blank" rel="noopener">https://juejin.cn/?sex=boy&amp;name=前端胖头鱼</a><br>console.log(getQueryByName(‘name’)) // 前端胖头鱼</p>
<p>// 2. name在中间<br>// <a href="https://juejin.cn/?sex=boy&amp;name=前端胖头鱼&amp;age=100" target="_blank" rel="noopener">https://juejin.cn/?sex=boy&amp;name=前端胖头鱼&amp;age=100</a><br>console.log(getQueryByName(‘name’)) // 前端胖头鱼</p>
<p>与其他语言中的正则表达式类似，模式中使用的所有元字符都必须转义。正则表达式中的元字符包括：</p>
<h1 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h1><p>( [ { \ ^ $ | ) ? * + .] }<br>这些元字符在正则表达式中都有一或多种特殊用途，因此如果想要匹配字符串中包含的这些字符，就必须对它们进行转义。</p>
<p>// 匹配 .docx<br>var exp = /.docx/gi ;</p>
]]></content>
  </entry>
  <entry>
    <title>git操作</title>
    <url>/2021/11/02/git%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h1><p>在 Git 开发中通常会控制主干分支的质量，但有时还是会把错误的代码合入到远程主干。 虽然可以直接回滚远程分支， 但有时新的代码也已经合入，直接回滚后最近的提交都要重新操作。 那么有没有只移除某些 Commit 的方式呢？可以一次 revert操作来完成。</p>
<p>考虑这个例子，我们提交了 6 个版本，其中 3-4 包含了错误的代码需要被回滚掉。 同时希望不影响到后续的 5-6。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">* 982d4f6 (HEAD -&gt; master) version 6</span><br><span class="line">* 54cc9dc version 5</span><br><span class="line">* 551c408 version 4, harttle screwed it up again</span><br><span class="line">* 7e345c9 version 3, harttle screwed it up</span><br><span class="line">* f7742cd version 2</span><br><span class="line">* 6c4db3f version 1</span><br></pre></td></tr></table></figure></p>
<p>这种情况在团队协作的开发中会很常见：可能是流程或认为原因不小心合入了错误的代码， 也可能是合入一段时间后才发现存在问题。 总之已经存在后续提交，使得直接回滚不太现实。</p>
<p>下面的部分就开始介绍具体操作了，同时我们假设远程分支是受保护的（不允许 Force Push）。 思路是从产生一个新的 Commit 撤销之前的错误提交。</p>
<p>使用 git revert <commit> 可以撤销指定的提交， 要撤销一串提交可以用 <commit1>..<commit2> 语法。 注意这是一个前开后闭区间，即不包括 commit1，但包括 commit2。</commit2></commit1></commit></p>
<p>git revert –no-commit f7742cd..551c408<br>git commit -a -m ‘This reverts commit 7e345c9 and 551c408’<br>其中 f7742cd 是 version 2，551c408 是 version 4，这样被移除的是 version 3 和 version 4。 注意 revert 命令会对每个撤销的 commit 进行一次提交，–no-commit 后可以最后一起手动提交。</p>
<p>此时 Git 记录是这样的：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">* 8fef80a (HEAD -&gt; master) This reverts commit 7e345c9 and 551c408</span><br><span class="line">* 982d4f6 version 6</span><br><span class="line">* 54cc9dc version 5</span><br><span class="line">* 551c408 version 4, harttle screwed it up again</span><br><span class="line">* 7e345c9 version 3, harttle screwed it up</span><br><span class="line">* f7742cd version 2</span><br><span class="line">* 6c4db3f version 1</span><br></pre></td></tr></table></figure></p>
<p>现在的 HEAD（8fef80a）就是我们想要的版本，把它 Push 到远程即可。</p>
<p>确认 diff<br>如果你像不确定是否符合预期，毕竟批量干掉了别人一堆 Commit，可以做一下 diff 来确认。 首先产生 version 4（551c408）与 version 6（982d4f6）的 diff，这些是我们想要保留的：</p>
<p>git diff 551c408..982d4f6<br>然后再产生 version 2（f7742cd）与当前状态（HEAD）的 diff：</p>
<p>git diff f7742cd..HEAD<br>如果 version 3, version 4 都被 version 6 撤销的话，上述两个 diff 为空。 可以人工确认一下，或者 grep 掉 description 之后做一次 diff。 下面介绍的另一种方法可以容易地确认 diff。</p>
<p>示例</p>
<p>bd1b80cb 和0f2f7e4a 是错误的提交可以通过git revert bd1b80cb 0f2f7e4a 来进行单独提交的回滚</p>
<h1 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h1><p>重新复习，这个变基线命令，很多公司是不允许提交代码的时候变基的，但我们公司例外，在提交pr的时候需要执行变基操作，原因？</p>
<ul>
<li>git checkout master</li>
<li>git pull origin master –rebase</li>
<li>git checkout currentBranch</li>
<li>git rebase master    //这一步就是在执行变基操作，但在这之前会执行一个操作，就是找到同master分支相同的commit号，然后整理commit：git reset –soft xxxxhash</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>User-agent</title>
    <url>/2021/07/09/useragent/</url>
    <content><![CDATA[<p>User-agent</p>
<p>iOS</p>
<p>iOS环境下，小程序原生和微信公众号H5的UA一致，无法通过UA对环境进行区分。小程序内的H5页面可通过miniProgram来判断。app中区分全屏页面和弹窗两种内嵌H5的场景，modalWebview为true为弹窗模式，否则则为全屏页面模式。wptFullScreen可理解为是否需要navigate-bar</p>
<p>小程序原生：<br>Mozilla/5.0 (iPhone; CPU iPhone OS 13_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Mobile/15E148 MicroMessenger/8.0.6(0x18000633) NetType/WIFI Language/zh_CN</p>
<p>小程序内H5:<br>Mozilla/5.0 (iPhone; CPU iPhone OS 13_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Mobile/15E148 MicroMessenger/8.0.6(0x18000633) NetType/WIFI Language/zh_CN miniProgram</p>
<p>公众号H5：<br>Mozilla/5.0 (iPhone; CPU iPhone OS 13_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Mobile/15E148 MicroMessenger/8.0.6(0x18000633) NetType/4G Language/zh_CN</p>
<p>iOS原生：<br>NetType/ Language/zh_CN WptMessenger/4.5.8 DeviceId/78CCE389-7C9E-409D-825F-A886305A5591 Idfa/78CCE389-7C9E-409D-825F-A886305A5591 Uuid/46D4AFCD-C7DA-4529-8278-68CF6E7E5F96 Channel/default OS/iOS Ar/1 PhoneModel/iPhone11 ver/13.6 wptAid/default identity/c7c64ba3176686ce86fbf1d3e90797e9 secretKey/secretKey wifiName/d3B0LW1hYzIwMTg=</p>
<p>安卓：<br>安卓环境下，小程序原生比公众号H5多一个MiniProgramEnv/android的标示，可用于区分是小程序还是公众号H5。小程序内H5同ios，可通过miniProgram进行判断。app中区分全屏页面和弹窗两种内嵌H5的场景，modalWebview为true为弹窗模式，wptfullscreen为true则为全屏页面模式，statusBarHeight用于statusBar高度。</p>
<p>小程序原生：<br>Mozilla/5.0 (Linux; Android 10; EML-AL00 Build/HUAWEIEML-AL00; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/78.0.3904.62 XWEB/2853 MMWEBSDK/20210501 Mobile Safari/537.36 MMWEBID/9235 MicroMessenger/8.0.6.1900(0x28000651) Process/appbrand0 WeChat/arm64 Weixin NetType/WIFI Language/zh_CN ABI/arm64 MiniProgramEnv/android</p>
<p>小程序内H5:<br>Mozilla/5.0 (Linux; Android 10; EML-AL00 Build/HUAWEIEML-AL00; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/78.0.3904.62 XWEB/2853 MMWEBSDK/20210501 Mobile Safari/537.36 MMWEBID/9235 MicroMessenger/8.0.6.1900(0x28000651) Process/appbrand0 WeChat/arm64 Weixin NetType/WIFI Language/zh_CN ABI/arm64 miniProgram</p>
<p>H5：<br>Mozilla/5.0 (Linux; Android 10; EML-AL00 Build/HUAWEIEML-AL00; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/77.0.3865.120 MQQBrowser/6.2 TBS/045617 Mobile Safari/537.36 MMWEBID/9235 MicroMessenger/8.0.6.1900(0x28000651) Process/tools WeChat/arm64 Weixin NetType/WIFI Language/zh_CN ABI/arm64</p>
<p>安卓原生：<br>NetType/NETWORK_WIFI Language/zh_CN WptMessenger/4.5.9 Channel/wpt DeviceId/fe717b86a4c04380 DeviceIdType/androidId os/android oVersion/10 cVersion/4.5.9 ua/EML-AL00 brand/HUAWEI Ar/1 wifiName/d3B0LW1hYzIwMTg= secretKey/secretKey oaid/d42edfa5-f5ff-0186-fd47-ff9ffa65dbae androidId/fe717b86a4c04380</p>
]]></content>
  </entry>
  <entry>
    <title>手写promise</title>
    <url>/2021/04/02/%E6%89%8B%E5%86%99promise/</url>
    <content><![CDATA[<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 先定义三个常量表示状态</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'pending'</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">'fulfilled'</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'rejected'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建 MyPromise 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(executor)&#123;</span><br><span class="line">    <span class="comment">// executor 是一个执行器，进入会立即执行</span></span><br><span class="line">    <span class="comment">// 并传入resolve和reject方法</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      executor(<span class="keyword">this</span>.resolve, <span class="keyword">this</span>.reject)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="keyword">this</span>.reject(error)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 储存状态的变量，初始值是 pending</span></span><br><span class="line">  status = PENDING;</span><br><span class="line">  <span class="comment">// 成功之后的值</span></span><br><span class="line">  value = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 失败之后的原因</span></span><br><span class="line">  reason = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存储成功回调函数</span></span><br><span class="line">  onFulfilledCallbacks = [];</span><br><span class="line">  <span class="comment">// 存储失败回调函数</span></span><br><span class="line">  onRejectedCallbacks = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更改成功后的状态</span></span><br><span class="line">  resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 只有状态是等待，才执行状态修改</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.status === PENDING) &#123;</span><br><span class="line">      <span class="comment">// 状态修改为成功</span></span><br><span class="line">      <span class="keyword">this</span>.status = FULFILLED;</span><br><span class="line">      <span class="comment">// 保存成功之后的值</span></span><br><span class="line">      <span class="keyword">this</span>.value = value;</span><br><span class="line">      <span class="comment">// resolve里面将所有成功的回调拿出来执行</span></span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">this</span>.onFulfilledCallbacks.length) &#123;</span><br><span class="line">        <span class="comment">// Array.shift() 取出数组第一个元素，然后（）调用，shift不是纯函数，取出后，数组将失去该元素，直到数组为空</span></span><br><span class="line">        <span class="keyword">this</span>.onFulfilledCallbacks.shift()(value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更改失败后的状态</span></span><br><span class="line">  reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 只有状态是等待，才执行状态修改</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.status === PENDING) &#123;</span><br><span class="line">      <span class="comment">// 状态成功为失败</span></span><br><span class="line">      <span class="keyword">this</span>.status = REJECTED;</span><br><span class="line">      <span class="comment">// 保存失败后的原因</span></span><br><span class="line">      <span class="keyword">this</span>.reason = reason;</span><br><span class="line">      <span class="comment">// resolve里面将所有失败的回调拿出来执行</span></span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">this</span>.onRejectedCallbacks.length) &#123;</span><br><span class="line">        <span class="keyword">this</span>.onRejectedCallbacks.shift()(reason)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  then(onFulfilled, onRejected) &#123;</span><br><span class="line">    <span class="keyword">const</span> realOnFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line">    <span class="keyword">const</span> realOnRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> ? onRejected : <span class="function"><span class="params">reason</span> =&gt;</span> &#123;<span class="keyword">throw</span> reason&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了链式调用这里直接创建一个 MyPromise，并在后面 return 出去</span></span><br><span class="line">    <span class="keyword">const</span> promise2 = <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> fulfilledMicrotask = <span class="function"><span class="params">()</span> =&gt;</span>  &#123;</span><br><span class="line">        <span class="comment">// 创建一个微任务等待 promise2 完成初始化</span></span><br><span class="line">        queueMicrotask(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取成功回调函数的执行结果</span></span><br><span class="line">            <span class="keyword">const</span> x = realOnFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">            <span class="comment">// 传入 resolvePromise 集中处理</span></span><br><span class="line">            resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            reject(error)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> rejectedMicrotask = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个微任务等待 promise2 完成初始化</span></span><br><span class="line">        queueMicrotask(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用失败回调，并且把原因返回</span></span><br><span class="line">            <span class="keyword">const</span> x = realOnRejected(<span class="keyword">this</span>.reason);</span><br><span class="line">            <span class="comment">// 传入 resolvePromise 集中处理</span></span><br><span class="line">            resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">            reject(error)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 判断状态</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === FULFILLED) &#123;</span><br><span class="line">        fulfilledMicrotask()</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.status === REJECTED) &#123;</span><br><span class="line">        rejectedMicrotask()</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.status === PENDING) &#123;</span><br><span class="line">        <span class="comment">// 等待</span></span><br><span class="line">        <span class="comment">// 因为不知道后面状态的变化情况，所以将成功回调和失败回调存储起来</span></span><br><span class="line">        <span class="comment">// 等到执行成功失败函数的时候再传递</span></span><br><span class="line">        <span class="keyword">this</span>.onFulfilledCallbacks.push(fulfilledMicrotask);</span><br><span class="line">        <span class="keyword">this</span>.onRejectedCallbacks.push(rejectedMicrotask);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> promise2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// resolve 静态方法</span></span><br><span class="line">  <span class="keyword">static</span> resolve (parameter) &#123;</span><br><span class="line">    <span class="comment">// 如果传入 MyPromise 就直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (parameter <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">      <span class="keyword">return</span> parameter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转成常规方式</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="params">resolve</span> =&gt;</span>  &#123;</span><br><span class="line">      resolve(parameter);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// reject 静态方法</span></span><br><span class="line">  <span class="keyword">static</span> reject (reason) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      reject(reason);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果相等了，说明return的是自己，抛出类型错误并返回</span></span><br><span class="line">  <span class="keyword">if</span> (promise2 === x) &#123;</span><br><span class="line">    <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Chaining cycle detected for promise #&lt;Promise&gt;'</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断x是不是 MyPromise 实例对象</span></span><br><span class="line">  <span class="keyword">if</span>(x <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">    <span class="comment">// 执行 x，调用 then 方法，目的是将其状态变为 fulfilled 或者 rejected</span></span><br><span class="line">    <span class="comment">// x.then(value =&gt; resolve(value), reason =&gt; reject(reason))</span></span><br><span class="line">    <span class="comment">// 简化之后</span></span><br><span class="line">    x.then(resolve, reject)</span><br><span class="line">  &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">// 普通值</span></span><br><span class="line">    resolve(x)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = MyPromise;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>SQL 和 NoSQL 的区别</title>
    <url>/2021/03/06/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E9%9D%9E%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84-%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="SQL-和-NoSQL-的区别"><a href="#SQL-和-NoSQL-的区别" class="headerlink" title="SQL 和 NoSQL 的区别"></a>SQL 和 NoSQL 的区别</h1><h2 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h2><p>　　SQL (Structured Query Language) 数据库，指关系型数据库。主要代表：SQL Server，Oracle，MySQL(开源)，PostgreSQL(开源)。</p>
<p>　　NoSQL（Not Only SQL）泛指非关系型数据库。主要代表：MongoDB，Redis，CouchDB。</p>
<h2 id="二、区别"><a href="#二、区别" class="headerlink" title="二、区别"></a>二、区别</h2><p>1、存储方式</p>
<p>　　SQL数据存在特定结构的表中；而NoSQL则更加灵活和可扩展，存储方式可以省是JSON文档、哈希表或者其他方式。SQL通常以数据库表形式存储数据。举个栗子，存个学生借书数据：</p>
<p>而NoSQL存储方式比较灵活，比如使用类JSON文件存储上表中熊大的借阅数据：</p>
<p>2、表/数据集合的数据的关系</p>
<p>　　在SQL中，必须定义好表和字段结构后才能添加数据，例如定义表的主键(primary key)，索引(index),触发器(trigger),存储过程(stored procedure)等。表结构可以在被定义之后更新，但是如果有比较大的结构变更的话就会变得比较复杂。在NoSQL中，数据可以在任何时候任何地方添加，不需要先定义表。例如下面这段代码会自动创建一个新的”借阅表”数据集合：</p>
<p>NoSQL也可以在数据集中建立索引。以MongoDB为例，会自动在数据集合创建后创建唯一值_id字段，这样的话就可以在数据集创建后增加索引。</p>
<p>从这点来看，NoSQL可能更加适合初始化数据还不明确或者未定的项目中。</p>
<p>3、外部数据存储</p>
<p>　　SQL中如何需要增加外部关联数据的话，规范化做法是在原表中增加一个外键，关联外部数据表。例如需要在借阅表中增加审核人信息，先建立一个审核人表：</p>
<p>再在原来的借阅人表中增加审核人外键：</p>
<p>这样如果我们需要更新审核人个人信息的时候只需要更新审核人表而不需要对借阅人表做更新。而在NoSQL中除了这种规范化的外部数据表做法以外，我们还能用如下的非规范化方式把外部数据直接放到原数据集中，以提高查询效率。缺点也比较明显，更新审核人数据的时候将会比较麻烦。</p>
<p>4、SQL中的JOIN查询</p>
<p>　　SQL中可以使用JOIN表链接方式将多个关系数据表中的数据用一条简单的查询语句查询出来。NoSQL暂未提供类似JOIN的查询方式对多个数据集中的数据做查询。所以大部分NoSQL使用非规范化的数据存储方式存储数据。</p>
<p>5、数据耦合性</p>
<p>　　SQL中不允许删除已经被使用的外部数据，例如审核人表中的”熊三”已经被分配给了借阅人熊大，那么在审核人表中将不允许删除熊三这条数据，以保证数据完整性。而NoSQL中则没有这种强耦合的概念，可以随时删除任何数据。</p>
<p>6、事务</p>
<p>　　SQL中如果多张表数据需要同批次被更新，即如果其中一张表更新失败的话其他表也不能更新成功。这种场景可以通过事务来控制，可以在所有命令完成后再统一提交事务。而NoSQL中没有事务这个概念，每一个数据集的操作都是原子级的。</p>
<p>7、增删改查语法</p>
<p>8、查询性能</p>
<p>　　在相同水平的系统设计的前提下，因为NoSQL中省略了JOIN查询的消耗，故理论上性能上是优于SQL的。</p>
<h2 id="三、补充"><a href="#三、补充" class="headerlink" title="三、补充"></a>三、补充</h2><p>　　目前许多大型互联网项目都会选用MySQL（或任何关系型数据库） + NoSQL的组合方案。</p>
<p>关系型数据库适合存储结构化数据，如用户的帐号、地址：</p>
<p>　　1）这些数据通常需要做结构化查询（嗯，好像是废话），比如join，这时候，关系型数据库就要胜出一筹</p>
<p>　　2）这些数据的规模、增长的速度通常是可以预期的</p>
<p>　　3）事务性、一致性</p>
<p>NoSQL适合存储非结构化数据，如文章、评论：</p>
<p>　　1）这些数据通常用于模糊处理，如全文搜索、机器学习</p>
<p>　　2）这些数据是海量的，而且增长的速度是难以预期的，</p>
<p>　　3）根据数据的特点，NoSQL数据库通常具有无限（至少接近）伸缩性</p>
<p>　　4）按key获取数据效率很高，但是对join或其他结构化查询的支持就比较差</p>
<p>　　基于它们的适用范围不同，目前主流架构才会采用组合方案，一个也不能少。目前为止，还没有出现一个能够通吃各种场景的数据库，而且根据CAP理论，这样的数据库是不存在的。�</p>
]]></content>
  </entry>
  <entry>
    <title>关于同构SSR</title>
    <url>/2021/01/04/%E5%90%8C%E6%9E%84SSR/</url>
    <content><![CDATA[<h1 id="关于同构SSR"><a href="#关于同构SSR" class="headerlink" title="关于同构SSR"></a>关于同构SSR</h1><p>虽然使用了服务端渲染，但是这个只能叫同构SSR，和传统的服务端渲染还是有区别的。目前同构SSR的本质就是集成页面组件，路由，前端状态，在服务端中运行生成快照，将生成的快照HTML传给客户端。需要注意的是，由于同构的这种快照所需的计算量远大于传统服务端渲染，所以单机性能上，可能要弱于传统服务端渲染。<br>同构SSR的实现得意于虚拟DOM的出现，虚拟DOM的最大好处并非Diff算法而是为前端赋能，把HTML的DOM抽象化，可以在服务端、IOS、安卓甚至智能家电上运行。<br>同构SSR的实质是当用户首次请求时，通过node端生成一个HTML快照给前端，之后用户在当前页面上的操作，其实都是一个SPA的操作交互，前端的路由交互还是依靠history路由去处理，而非传统路由，所以其实还是一个“SPA”。这样的处理，可以在保证首屏速度时，同时，减少服务器压力，提升用户体验，弥补同构渲染性能问题。</p>
]]></content>
  </entry>
  <entry>
    <title>将emoji转成UTF-16</title>
    <url>/2020/12/11/JS-emoji-%E8%BD%AC%E7%A0%81-%E8%A7%A3%E7%A0%81/</url>
    <content><![CDATA[<p>将emoji转成UTF-16<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toUTF16</span>(<span class="params">codePoint</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> TEN_BITS = <span class="built_in">parseInt</span>(<span class="string">'1111111111'</span>, <span class="number">2</span>);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">u</span>(<span class="params">codeUnit</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'\\u'</span>+codeUnit.toString(<span class="number">16</span>).toUpperCase();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (codePoint &lt;= <span class="number">0xFFFF</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> u(codePoint);</span><br><span class="line">  &#125;</span><br><span class="line">  codePoint -= <span class="number">0x10000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Shift right to get to most significant 10 bits</span></span><br><span class="line">  <span class="keyword">var</span> leadSurrogate = <span class="number">0xD800</span> + (codePoint &gt;&gt; <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Mask to get least significant 10 bits</span></span><br><span class="line">  <span class="keyword">var</span> tailSurrogate = <span class="number">0xDC00</span> + (codePoint &amp; TEN_BITS);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> u(leadSurrogate) + u(tailSurrogate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>// using codePointAt, it’s easy to go from emoji<br>// to decimal and back.<br>// Emoji to decimal representation<br>“😀”.codePointAt(0)</p>
<blockquote>
<p>128512</p>
</blockquote>
<p>// Decimal to emoji<br>String.fromCodePoint(128512)</p>
<blockquote>
<p>“😀”</p>
</blockquote>
<p>// going from emoji to hexadecimal is a little<br>// bit trickier. To convert from decimal to hexadecimal,<br>// we can use toUTF16.<br>// Decimal to hexadecimal<br>toUTF16(128512)</p>
<blockquote>
<p>“\uD83D\uDE00”</p>
</blockquote>
<p>// Hexadecimal to emoji<br>“\uD83D\uDE00”</p>
<blockquote>
<p>“😀”</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>css GPU硬件加速原理</title>
    <url>/2020/11/03/GPU/</url>
    <content><![CDATA[<p>满世界的动画性能优化技巧，例如：</p>
<p>只允许改变transform、opacity，其它属性不要动，避免重新计算布局（reflow）</p>
<p>对动画元素应用transform: translate3d(0, 0, 0)、will-change: transform等，开启硬件加速</p>
<p>动画元素尽量用fixed、absolute定位方式，避免reflow</p>
<p>对动画元素应用高一点的z-index，减少复合层数量</p>
<p>。。。其它可能有用的规则</p>
<p>那么问题是：已经小心遵守这些规则了，为什么动画还会卡顿、跳帧？还能优化吗？要从哪里入手？</p>
<p>一.硬件加速是非规范的<br>The most important thing I’d like to tell you before we dive deep into GPU compositing is this: It’s a giant hack. You won’t find anything (at least for now) in the W3C‘s specifications about how compositing works, about how to explicitly put an element on a compositing layer or even about compositing itself. It’s just an optimization that the browser applies to perform certain tasks and that each browser vendor implements in its own way.</p>
<p>很多情况下，开启硬件加速确实能带来明显的性能提升，但是，这部分内容是非规范的，W3C并没有相关规范说明其中细节，所以通过一些技巧（例如transform: translate3d(0, 0, 0)）开启硬件加速是规范之外的行为，可能得到性能提升，也可能带来严重的性能问题</p>
<p>也许在将来会形成规范，依照规范去做肯定能获得性能提升，但在这之前，除了必须遵从各项性能优化原则外，还要考虑实际渲染流程，从原理上解决性能问题</p>
<p>硬件加速（Hardware Acceleration） 硬件加速在CSS动画上是指GPU合成（GPU compositing），浏览器不直接通过CPU生成图像数据显示出来，而是把相关层数据发送给GPU，而GPU在图像数据运算方面有天生优势，所以算是加速</p>
<p>那么当硬件加速不可用时，浏览器怎样渲染页面？</p>
<p>在没有硬件加速的情况下，浏览器通常是依赖于CPU来渲染生成网页的内容，大致的做法是遍历这些层，然后按照顺序把这些层的内容依次绘制在一个内部存储空间上（例如bitmap），最后把这个内部表示显示出来，这种做法就是软件渲染（software rendering）</p>
<p>二.transform和opacity的特殊性 以前通过改变布局相关属性形成动画，例如：</p>
<p>@keyframes move { from { left: 30px; } to { left: 100px; } } 对于动画的每一帧，浏览器都要重新计算元素的形状位置（reflow），把新状态渲染出来（repaint），再显示到屏幕上</p>
<p>整页reflow和repaint想想就觉得很慢，那么如果把动画元素抽出来作为前景，每帧其它部分作为背景不变，只重新渲染动画元素，再把前景背景合成起来，是不是会更快？当然会，因为GPU能快速地进行亚像素级图层合成</p>
<p>但是这样做的前提是能够按照动的，不动的划分出前景背景层，如果动画元素或者受布局影响，或者动的过程中影响到了布局，就会打破前景背景的界限，这样简单分为2层就有问题。那么，应用position: fixed | absolute是不是就能保证不会影响布局了？</p>
<p>不行，因为left可以接受百分比值、相对单位（em、vw等等），浏览器不能百分百肯定该属性的变化与布局无关，所以不能简单的分出前景背景层，例如：</p>
<p>@keyframes move { from { left: 30px; } to { left: 100%; } } 但浏览器能百分百肯定transform和opacity的变化与布局无关，不受布局影响，其变化也不会影响现有布局，所以这两个属性的特殊性是：</p>
<p>does not affect the document’s flow,</p>
<p>does not depend on the document’s flow,</p>
<p>does not cause a repaint.</p>
<p>如果不影响布局，且不受布局影响，其变化不会导致其它部分需要repaint，那么这个东西肯定可以抽出去单独作为一层，放心交给GPU去处理，享受硬件加速带来的好处；</p>
<p>细腻（GPU能做到亚像素级精度，且对GPU来说不费劲）</p>
<p>流畅（不受其它运算密集的JS任务影响，动画交给GPU了，与CPU无关）</p>
<p>三.GPU合成的代价 It might surprise you, but the GPU is a separate computer. That’s right: An essential part of every modern device is actually a standalone unit with its own processors and its own memory- and data-processing models. And the browser, like any other app or game, has to talk with the GPU as it would with an external device.</p>
<p>GPU是独立的一部分，有自己的处理器、内存核数据处理模型，那么意味着通过CPU在内存里创建的图像数据无法直接与GPU共享，需要打包发送给GPU，GPU收到后才能执行我们期望的一系列操作，这个过程需要时间，而打包数据需要内存</p>
<p>需要的内存取决于：</p>
<p>复合层的数量</p>
<p>复合层的大小</p>
<p>相对于数量，复合层的大小影响更大一些，例如：</p>
<p>.rect { width: 320px; height: 240px; background: #f00; } 这个红块如果要发送给GPU的话，需要的存储空间是：320 × 240 × 3 = 230400B = 225KB（rgb需要3个字节），如果图像含有透明部分，就需要320 × 240 × 4 = 307200B = 300KB</p>
<p>这样一个不起眼的小红块就需要2、300KB，页面动辄几十上百个元素，占全屏半屏的元素也不少，如果都作为复合层，交给GPU，内存消耗可想而知，所以一些很极端的硬件加速场景性能非常差：</p>
<p>技术分享</p>
<p>gpu compositing issue</p>
<p>对于1GB RAM的设备，去掉系统和后台进程的1/3，再去掉浏览器和当前页面的1/3，实际能用的只有200到300MB，如果复合层太多太大，内存会被迅速消耗，然后掉帧（卡顿、闪烁）现象，甚至浏览器/应用崩溃也就很合理了</p>
<p>P.S.详细见CSS3硬件加速也有坑！！！</p>
<p>四.创建复合层 浏览器在一些情况下会创建复合层，例如：</p>
<p>3D transforms: translate3d, translateZ and so on;</p>
<p>, and <iframe> elements;</iframe></p>
<p>animation of transform and opacity via Element.animate();</p>
<p>animation of transform and opacity via СSS transitions and animations;</p>
<p>position: fixed;</p>
<p>will-change;</p>
<p>filter;</p>
<p>。。。</p>
<p>还有很多，详细见CompositingReasons.h中定义的常量，分为几类：</p>
<p>这些大多是我们期望的，算是显式创建的复合层，而另一些情况也会创建复合层：</p>
<p>位于复合层之上的元素会被创建复合层（B的z-index大于A，对A做动画，B也会被**独立的复合层）</p>
<p>很容易理解，A在动画过程中可能会与B产生重叠，被B遮住，那么GPU需要每帧对A图层做动画，然后再与B图层合成，才能得到正确结果，所以B无论如何都要被**复合层，连同A一起交给GPU</p>
<p>隐式创建复合层主要出于重叠考虑，如果浏览器不确定会不会发生重叠，那么就要把不确定的东西都**复合层，所以，从这个角度看，高z-index原则是有道理的</p>
<p>五.硬件加速的优缺点 优点 动画非常流畅，能达到60fps</p>
<p>动画执行过程在独立线程里，不受计算密集的JS任务影响</p>
<p>缺点 把元素**复合层时需要额外重绘，有时很慢（可能需要整页重绘）</p>
<p>复合层数据传递给GPU有额外时耗，取决于复合层的数量和大小，这在中低端设备可能会导致闪烁</p>
<p>每个复合层都要消耗一部分内存，移动设备上内存很贵，过多占用会导致浏览器/应用崩溃</p>
<p>存在隐式复合层的问题，不注意的话内存飙升</p>
<p>文字模糊，元素有时会变形</p>
<p>最主要的问题集中在内存消耗和repaint上，所以动画性能优化目标是降低内存消耗，减少repaint</p>
<p>六.性能优化技巧 1.尽量避免隐式复合层 复合层直接影响repaint、内存消耗：动画开始时创建复合层、结束时删除复合层，都会引起repaint，而动画开始时必须把图层数据发送给GPU，内存消耗集中在这里。两条建议：</p>
<p>给动画元素应用高z-index，最好直接作为body的子元素，对于嵌套很深的动画元素，可以复制一个到body下，仅用于实现动画效果</p>
<p>给动画元素应用will-change，浏览器会提前把这些元素**复合层，可以让动画开始/结束时更流畅些，但不能滥用，在不需要的时候赶紧去掉，减少内存消耗</p>
<p>2.只改变transform和opacity 能用transform、opacity优先用，不能用的话想办法用，比如背景色渐变，可以用盖在上面的伪元素背景色opacity动画模拟；box-shadow动画可以用铺在下面的伪元素opacity动画模拟，这些曲折的实现方式能带来显著性能提升</p>
<p>3.减少复合层的大小 小元素放大展示，减小width、height，减少传递给GPU的数据，由GPU做scale放大展示，视觉效果无差异（多用于纯色背景元素，对不太重要的图片也可以进行5%到10%的宽高压缩），例如：</p>
<p><style> #a, #b { will-change: transform; background-color: #f00; } #a { width: 100px; height: 100px; } #b { width: 10px; height: 10px; transform: scale(10); } </style><br>最终显示的两个红色块在视觉上没有差异，但减小了90%的内存消耗</p>
<p>4.考虑对子元素动画与容器动画 容器动画可能存在不必要的内存消耗，比如子元素之间的空隙，也会被当做有效数据发送给GPU，如果对各个子元素分别应用动画，就能避免这部分的内存消耗</p>
<p>例如12道太阳光线旋转，转容器就把容器整张图都发送给GPU，单独转12道光线就去掉了光线之间的11条空隙，能够节省一半内存</p>
<p>5.早早关注复合层的数量和大小 从一开始就关注复合层，尤其是隐式创建的复合层，避免后期优化影响布局</p>
<p>复合层的大小比数量影响更大，但浏览器会做一些优化操作，把几个复合层整合成一个，叫Layer Squashing，但有时一个大复合层比几个小复合层消耗的内存更多，有必要的话可以手动去掉这种优化：</p>
<p>// 给每个元素应用不同的translateZ translateZ(0.0001px), translateZ(0.0002px) 6.不要滥用硬件加速 没事不要乱加transform: translateZ(0)、will-change: transform等强制开启硬件加速的属性，GPU合成存在缺点和不足，而且是非标准的行为，最好情况能带来显著性能提升，最坏情况可能会让浏览器崩溃</p>
]]></content>
  </entry>
  <entry>
    <title>如何封装react 组件</title>
    <url>/2020/11/03/react-%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<p>由于公司需要一套自己的前端UI公共组件，所以有这次分享</p>
<p>本篇文章重点阐述 SRP，即单一职责原则。<br>React组件式开发方式。你可以将复杂的用户界面分割为一个个组件，利用组件的可重用性和抽象的DOM操作。<br>基于组件的开发是高效的：一个复杂的系统是由专门的、易于管理的组件构建的。然而，只有设计良好的组件才能确保组合和复用的好处。<br>尽管应用程序很复杂，但为了满足最后期限和意外变化的需求，你必须不断地走在架构正确性的细线上。你必须将组件分离为专注于单个任务，并经过良好测试。<br>不幸的是，遵循错误的路径总是更加容易：编写具有许多职责的大型组件、紧密耦合组件、忘记单元测试。这些增加了技术债务，使得修改现有功能或创建新功能变得越来越困难。<br>编写React应用程序时，经常问自己：<br>• 如何正确构造组件？<br>• 在什么时候，一个大的组件应该拆分成更小的组件？<br>• 如何设计防止紧密耦合的组件之间的通信？<br>幸运的是，可靠的组件具有共同的特性。让我们来研究以下有用的标准，并将其详细到案例研究中。</p>
<h1 id="单一职责"><a href="#单一职责" class="headerlink" title="单一职责"></a>单一职责</h1><p>当一个组件只有一个改变的原因时，它有一个单一的职责。<br>编写React组件时要考虑的基本准则是单一职责原则。单一职责原则(缩写：SRP)要求组件有一个且只有一个变更的原因。<br>组件的职责可以是呈现列表，或者显示日期选择器，或者发出 HTTP 请求，或者绘制图表，或者延迟加载图像等。你的组件应该只选择一个职责并实现它。当你修改组件实现其职责的方式（例如，更改渲染的列表的数量限制），它有一个更改的原因。<br>为什么只有一个理由可以改变很重要？因为这样组件的修改隔离并且受控。单一职责原则制了组件的大小，使其集中在一件事情上。集中在一件事情上的组件便于编码、修改、重用和测试。<br>下面我们来举几个例子<br>实例1：一个组件获取远程数据，相应地，当获取逻辑更改时，它有一个更改的原因。<br>发生变化的原因是：<br>• 修改服务器URL<br>• 修改响应格式<br>• 要使用其他HTTP请求库<br>• 或仅与获取逻辑相关的任何修改。<br>示例2：表组件将数据数组映射到行组件列表，因此在映射逻辑更改时有一个原因需要更改。<br>发生变化的原因是：<br>• 你需要限制渲染行组件的数量（例如，最多显示25行）<br>• 当没有要显示的项目时，要求显示提示信息“列表为空”<br>• 或仅与数组到行组件的映射相关的任何修改。<br>你的组件有很多职责吗？如果答案是“是”，则按每个单独的职责将组件分成若干块。<br>如果您发现SRP有点模糊，请阅读本文。<br>在项目早期阶段编写的单元将经常更改，直到达到发布阶段。这些更改通常要求组件在隔离状态下易于修改：这也是 SRP 的目标。</p>
<h2 id="1-1-多重职责陷阱"><a href="#1-1-多重职责陷阱" class="headerlink" title="1.1 多重职责陷阱"></a>1.1 多重职责陷阱</h2><p>当一个组件有多个职责时，就会发生一个常见的问题。乍一看，这种做法似乎是无害的，并且工作量较少：<br>• 你立即开始编码：无需识别职责并相应地规划结构<br>• 一个大的组件可以做到这一切：不需要为每个职责创建组成部分<br>• 无拆分-无开销：无需为拆分组件之间的通信创建 props 和 callbacks<br>这种幼稚的结构在开始时很容易编码。但是随着应用程序的增加和变得复杂，在以后的修改中会出现困难。同时实现多个职责的组件有许多更改的原因。现在出现的主要问题是：出于某种原因更改组件会无意中影响同一组件实现的其它职责。<br>不要关闭电灯开关，因为它同样作用于电梯。<br>这种设计很脆弱。意外的副作用是很难预测和控制的。<br>例如，<chartandform> 同时有两个职责，绘制图表，并处理为该图表提供数据的表单。<chartandform> 就会有两个更改原因：绘制图表和处理表单。<br>当你更改表单字段（例如，将 <input> 修改为 <select> 时，你无意中中断图表的渲染。此外，图表实现是不可重用的，因为它与表单细节耦合在一起。<br>解决多重责任问题需要将 <chartandform> 分割为两个组件：<chart> 和<form>。每个组件只有一个职责：绘制图表或处理表单。组件之间的通信是通过props 实现。<br>多重责任问题的最坏情况是所谓的上帝组件（上帝对象的类比）。上帝组件倾向于了解并做所有事情。你可能会看到它名为 <application>、<manager> 、<bigcontainer> 或 <page>，代码超过500行。<br>在组合的帮助下使其符合SRP，从而分解上帝组件。(组合（composition）是一种通过将各组件联合在一起以创建更大组件的方式。组合是 React 的核心。)</page></bigcontainer></manager></application></form></chart></chartandform></select></chartandform></chartandform></p>
<h2 id="1-2-案例研究：使组件只有一个职责"><a href="#1-2-案例研究：使组件只有一个职责" class="headerlink" title="1.2 案例研究：使组件只有一个职责"></a>1.2 案例研究：使组件只有一个职责</h2><p>设想一个组件向一个专门的服务器发出 HTTP 请求，以获取当前天气。成功获取数据时，该组件使用响应来展示天气信息：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;</span><br><span class="line"><span class="comment">// 问题: 一个组件有多个职责</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Weather</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123; <span class="attr">temperature</span>: <span class="string">'N/A'</span>, <span class="attr">windSpeed</span>: <span class="string">'N/A'</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; temperature, windSpeed &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div className=<span class="string">"weather"</span>&gt;</span><br><span class="line">                &lt;div&gt;Temperature: &#123;temperature&#125;°C&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">                &lt;div&gt;Wind: &#123;windSpeed&#125;km/</span>h&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        axios.get(<span class="string">'http://weather.com/api'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> &#123; current &#125; = response.data;</span><br><span class="line">            <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">                temperature: current.temperature,</span><br><span class="line">                windSpeed: current.windSpeed</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在处理类似的情况时，问问自己：是否必须将组件拆分为更小的组件？通过确定组件可能会如何根据其职责进行更改，可以最好地回答这个问题。<br>这个天气组件有两个改变原因：</p>
<ol>
<li>componentDidMount() 中的 fetch 逻辑：服务器URL或响应格式可能会改变。</li>
<li>render() 中的天气展示：组件显示天气的方式可以多次更改。<br>解决方案是将 <weather> 分为两个组件：每个组件只有一个职责。命名为 <weatherfetch> 和 <weatherinfo>。<br><weatherfetch> 组件负责获取天气、提取响应数据并将其保存到 state 中。它改变原因只有一个就是获取数据逻辑改变。</weatherfetch></weatherinfo></weatherfetch></weather></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;</span><br><span class="line"><span class="comment">// 解决措施: 组件只有一个职责就是请求数据</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeatherFetch</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123; <span class="attr">temperature</span>: <span class="string">'N/A'</span>, <span class="attr">windSpeed</span>: <span class="string">'N/A'</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; temperature, windSpeed &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;WeatherInfo temperature=&#123;temperature&#125; windSpeed=&#123;windSpeed&#125; /&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        axios.get(<span class="string">'http://weather.com/api'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">const</span> &#123; current &#125; = response.data;</span><br><span class="line">            <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">                temperature: current.temperature,</span><br><span class="line">                windSpeed: current.windSpeed</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种结构有什么好处？<br>例如，你想要使用 async/await 语法来替代 promise 去服务器获取响应。更改原因：修改获取逻辑<br>// 改变原因: 使用 async/await 语法<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeatherFetch</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ..... //</span></span><br><span class="line">    <span class="keyword">async</span> componentDidMount() &#123;</span><br><span class="line">        <span class="keyword">const</span> response = <span class="keyword">await</span> axios.get(<span class="string">'http://weather.com/api'</span>);</span><br><span class="line">        <span class="keyword">const</span> &#123; current &#125; = response.data;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            temperature: current.temperature,</span><br><span class="line">            windSpeed: current.windSpeed</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为 <weatherfetch> 只有一个更改原因：修改 fetch 逻辑，所以对该组件的任何修改都是隔离的。使用 async/await 不会直接影响天气的显示。</weatherfetch></p>
<p><weatherfetch> 渲染 <weatherinfo>。后者只负责显示天气，改变原因只可能是视觉显示改变。<br>// 解决方案: 组件只有一个职责，就是显示天气</weatherinfo></weatherfetch></p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">WeatherInfo</span>(<span class="params">&#123; temperature, windSpeed &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div className=<span class="string">"weather"</span>&gt;</span><br><span class="line">            &lt;div&gt;Temperature: &#123;temperature&#125;°C&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">            &lt;div&gt;Wind: &#123;windSpeed&#125; km/</span>h&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们更改<weatherinfo>，如不显示 “wind:0 km/h” 而是显示 “wind:calm”。这就是天气视觉显示发生变化的原因：<br>// 改变原因: 无风时的显示<br>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">WeatherInfo</span>(<span class="params">&#123; temperature, windSpeed &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> windInfo = windSpeed === <span class="number">0</span> ? <span class="string">'calm'</span> : <span class="string">`<span class="subst">$&#123;windSpeed&#125;</span> km/h`</span>;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div className=<span class="string">"weather"</span>&gt;</span><br><span class="line">            &lt;div&gt;Temperature: &#123;temperature&#125;°C&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">            &lt;div&gt;Wind: &#123;windInfo&#125;&lt;/</span>div&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></weatherinfo></p>
<p>同样，对 <weatherinfo> 的修改是隔离的，不会影响 <weatherfetch> 组件。</weatherfetch></weatherinfo></p>
<p><weatherfetch> 和 <weatherinfo> 有各自的职责。一种组件的变化对另一种组件的影响很小。这就是单一职责原则的作用：修改隔离，对系统的其他组件产生影响很轻微并且可预测。</weatherinfo></weatherfetch></p>
<h2 id="1-3-案例研究：HOC-偏好单一责任原则"><a href="#1-3-案例研究：HOC-偏好单一责任原则" class="headerlink" title="1.3 案例研究：HOC 偏好单一责任原则"></a>1.3 案例研究：HOC 偏好单一责任原则</h2><p>按职责使用分块组件的组合并不总是有助于遵循单一责任原则。另外一种有效实践是高阶组件(缩写为 HOC)<br>高阶组件是一个接受一个组件并返回一个新组件的函数。<br>HOC 的一个常见用法是为封装的组件增加新属性或修改现有的属性值。这种技术称为属性代理：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withNewFunctionality</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">NewFunctionality</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">        render() &#123;</span><br><span class="line">            <span class="keyword">const</span> newProp = <span class="string">'Value'</span>;</span><br><span class="line">            <span class="keyword">const</span> propsProxy = &#123;</span><br><span class="line">                ...this.props,</span><br><span class="line">                <span class="comment">// 修改现有属性:</span></span><br><span class="line">                ownProp: <span class="keyword">this</span>.props.ownProp + <span class="string">' was modified'</span>,</span><br><span class="line">                <span class="comment">// 增加新属性:</span></span><br><span class="line">                newProp</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="keyword">return</span> &lt;WrappedComponent &#123;...propsProxy&#125; /&gt;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const MyNewComponent = withNewFunctionality(MyComponent);</span><br></pre></td></tr></table></figure></p>
<p>你还可以通过控制输入组件的渲染过程从而控制渲染结果。这种 HOC 技术被称为渲染劫持：<br>通过return cloneElement(rootElement=super.render(),rootElement.props,newChildren)<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withModifiedChildren</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">ModifiedChildren</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">        render() &#123;</span><br><span class="line">            <span class="keyword">const</span> rootElement = <span class="keyword">super</span>.render();</span><br><span class="line">            <span class="keyword">const</span> newChildren = [</span><br><span class="line">                ...rootElement.props.children,</span><br><span class="line">                <span class="comment">// 插入一个元素</span></span><br><span class="line">                &lt;div&gt;New child&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">            ];</span></span><br><span class="line"><span class="regexp">            return cloneElement(</span></span><br><span class="line"><span class="regexp">                rootElement,</span></span><br><span class="line"><span class="regexp">                rootElement.props,</span></span><br><span class="line"><span class="regexp">                newChildren</span></span><br><span class="line"><span class="regexp">            );</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">const MyNewComponent = withModifiedChildren(MyComponent);</span></span><br></pre></td></tr></table></figure></p>
<p>如果您想深入了解HOCS实践，我建议您阅读“深入响应高阶组件”。<br>让我们通过一个例子来看看HOC的属性代理技术如何帮助分离职责。<br>组件 <persistentform> 由 input 输入框和按钮 save to storage 组成。更改输入值后，点击 save to storage 按钮将其写入到 localStorage 中。<br>input 的状态在 handlechange(event) 方法中更新。点击按钮，值将保存到本地存储，在 handleclick() 中处理：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersistentForm</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123; <span class="attr">inputValue</span>: localStorage.getItem(<span class="string">'inputValue'</span>) &#125;;</span><br><span class="line">        <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; inputValue &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div className=<span class="string">"persistent-form"</span>&gt;</span><br><span class="line">                &lt;input type=<span class="string">"text"</span> value=&#123;inputValue&#125;</span><br><span class="line">                    onChange=&#123;<span class="keyword">this</span>.handleChange&#125; /&gt;</span><br><span class="line">                &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;Save to storage&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    handleChange(event) &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            inputValue: event.target.value</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    handleClick() &#123;</span><br><span class="line">        localStorage.setItem(<span class="string">'inputValue'</span>, <span class="keyword">this</span>.state.inputValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></persistentform></p>
<p>遗憾的是： <persistentform> 有2个职责：管理表单字段；将输入只保存中 localStorage。<br>让我们重构一下 <persistentform> 组件，使其只有一个职责：展示表单字段和附加的事件处理程序。它不应该知道如何直接使用存储：<br>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersistentForm</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123; <span class="attr">inputValue</span>: props.initialValue &#125;;</span><br><span class="line">        <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; inputValue &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div className=<span class="string">"persistent-form"</span>&gt;</span><br><span class="line">                &lt;input type=<span class="string">"text"</span> value=&#123;inputValue&#125;</span><br><span class="line">                    onChange=&#123;<span class="keyword">this</span>.handleChange&#125; /&gt;</span><br><span class="line">                &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;Save to storage&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    handleChange(event) &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            inputValue: event.target.value</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    handleClick() &#123;</span><br><span class="line">        <span class="keyword">this</span>.props.saveValue(<span class="keyword">this</span>.state.inputValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></persistentform></persistentform></p>
<p>组件从属性初始值接收存储的输入值，并使用属性函数 saveValue(newValue) 来保存输入值。这些props 由使用属性代理技术的 withpersistence() HOC提供。<br>现在 <persistentform> 符合 SRP。更改的唯一原因是修改表单字段。<br>查询和保存到本地存储的职责由 withPersistence() HOC承担：<br>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withPersistence</span>(<span class="params">storageKey, storage</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">PersistentComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">            <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">                <span class="keyword">super</span>(props);</span><br><span class="line">                <span class="keyword">this</span>.state = &#123; <span class="attr">initialValue</span>: storage.getItem(storageKey) &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            render() &#123;</span><br><span class="line">                <span class="keyword">return</span> (</span><br><span class="line">                    &lt;WrappedComponent</span><br><span class="line">                        initialValue=&#123;<span class="keyword">this</span>.state.initialValue&#125;</span><br><span class="line">                        saveValue=&#123;<span class="keyword">this</span>.saveValue&#125;</span><br><span class="line">                        &#123;...this.props&#125;</span><br><span class="line">                    /&gt;</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">            saveValue(value) &#123;</span><br><span class="line">                storage.setItem(storageKey, value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></persistentform></p>
<p>withPersistence()是一个 HOC，其职责是持久的。它不知道有关表单域的任何详细信息。它只聚焦一个工作：为传入的组件提供 initialValue 字符串和 saveValue() 函数。<br>将 <persistentform> 和 withpersistence() 一起使用可以创建一个新组件<localstoragepersistentform>。它与本地存储相连，可以在应用程序中使用：<br>const LocalStoragePersistentForm<br>    = withPersistence(‘key’, localStorage)(PersistentForm);<br>const instance = <localstoragepersistentform>;<br>只要 <persistentform> 正确使用 initialValue 和 saveValue()属性，对该组件的任何修改都不能破坏 withPersistence() 保存到存储的逻辑。<br>反之亦然：只要 withPersistence() 提供正确的 initialValue 和 saveValue()，对 HOC 的任何修改都不能破坏处理表单字段的方式。<br>SRP的效率再次显现出来：修改隔离，从而减少对系统其他部分的影响。<br>此外，代码的可重用性也会增加。你可以将任何其他表单 <myotherform> 连接到本地存储：<br>const LocalStorageMyOtherForm<br>    = withPersistence(‘key’, localStorage)(MyOtherForm);<br>const instance = <localstoragemyotherform>;<br>你可以轻松地将存储类型更改为 session storage：<br>const SessionStoragePersistentForm<br>    = withPersistence(‘key’, sessionStorage)(PersistentForm);<br>const instance = <sessionstoragepersistentform>;<br>初始版本 <persistentform> 没有隔离修改和可重用性好处，因为它错误地具有多个职责。<br>在不好分块组合的情况下，属性代理和渲染劫持的 HOC 技术可以使得组件只有一个职责。</persistentform></sessionstoragepersistentform></localstoragemyotherform></myotherform></persistentform></localstoragepersistentform></localstoragepersistentform></persistentform></p>
<h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p>一个封装组件提供 props 控制其行为而不是暴露其内部结构。<br>耦合是决定组件之间依赖程度的系统特性。根据组件的依赖程度，可区分两种耦合类型：<br>• 当应用程序组件对其他组件知之甚少或一无所知时，就会发生松耦合。<br>• 当应用程序组件知道彼此的许多详细信息时，就会发生紧耦合。<br>松耦合是我们设计应用结构和组件之间关系的目标。<br>松耦合应用(封装组件)<br>松耦合会带来以下好处：<br>• 可以在不影响应用其它部分的情况下对某一块进行修改。、<br>• 任何组件都可以替换为另一种实现<br>• 在整个应用程序中实现组件复用，从而避免重复代码<br>• 独立组件更容易测试，增加了测试覆盖率<br>相反，紧耦合的系统会失去上面描述的好处。主要缺点是很难修改高度依赖于其他组件的组件。即使是一处修改，也可能导致一系列的依赖组件需要修改。<br>紧耦合应用(组件无封装)<br>封装 或 信息隐藏 是如何设计组件的基本原则，也是松耦合的关键。</p>
<h2 id="信息隐藏"><a href="#信息隐藏" class="headerlink" title="信息隐藏"></a>信息隐藏</h2><p>封装良好的组件隐藏其内部结构，并提供一组属性来控制其行为。<br>隐藏内部结构是必要的。其他组件没必要知道或也不依赖组件的内部结构或实现细节。<br>React 组件可能是函数组件或类组件、定义实例方法、设置 ref、拥有 state 或使用生命周期方法。这些实现细节被封装在组件内部，其他组件不应该知道这些细节。<br>隐藏内部结构的组件彼此之间的依赖性较小，而降低依赖度会带来松耦合的好处。</p>
<h2 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h2><p>细节隐藏是隔离组件的关键。此时，你需要一种组件通信的方法：props。porps 是组件的输入。<br>建议 prop 的类型为基本数据（例如，string 、 number 、boolean）：</p>
<p><message text="Hello world!" modal="{false}">;<br>必要时，使用复杂的数据结构，如对象或数组：</message></p>
<p>&lt;MoviesList items={[‘Batman Begins’, ‘Blade Runner’]} /&gt;<br>prop 可以是一个事件处理函数和异步函数：</p>
<p><input type="text" onchange="{handleChange}"><br>prop 甚至可以是一个组件构造函数。组件可以处理其他组件的实例化：<br>function If({ component: Component, condition }) {<br>    return condition ? <component> : null;<br>}</component></p>
<p><if condition="{false}" component="{LazyComponent}"><br>为了避免破坏封装，请注意通过 props 传递的内容。给子组件设置 props 的父组件不应该暴露其内部结构的任何细节。例如，使用 props 传输整个组件实例或 refs 都是一个不好的做法。<br>访问全局变量同样也会对封装产生负面影响。</if></p>
<h2 id="案例研究：封装修复"><a href="#案例研究：封装修复" class="headerlink" title="案例研究：封装修复"></a>案例研究：封装修复</h2><p>组件的实例和状态对象是封装在组件内部的实现细节。因此，将状态管理的父组件实例传递给子组件会破坏封装。<br>我们来研究一下这种情况。<br>一个简单的应用程序显示一个数字和两个按钮。第一个按钮增加数值，第二个按钮减少数值：<br>这个应用由两个组件组成：<app> 和 <controls>.<br>number 是 <app> 的 state 对象，<app> 负责 将这个数字渲染到页面。<br>// 问题: 封装被破坏<br>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123; <span class="attr">number</span>: <span class="number">0</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div className=<span class="string">"app"</span>&gt;</span><br><span class="line">                &lt;span className=<span class="string">"number"</span>&gt;&#123;<span class="keyword">this</span>.state.number&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">                &lt;Controls parent=&#123;this&#125; /</span>&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></app></app></controls></app></p>
<p><controls> 负责渲染按钮，并为其设置事件处理函数，当用户点击按钮时，父组件的状态将会被更新：number 加1或者减1((updateNumber()方法`)<br>// 问题: 使用父组件的内部结构<br>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Controls</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div className=<span class="string">"controls"</span>&gt;</span><br><span class="line">                &lt;button onClick=&#123;() =&gt; <span class="keyword">this</span>.updateNumber(+<span class="number">1</span>)&#125;&gt;</span><br><span class="line">                    Increase</span><br><span class="line">          &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">                &lt;button onClick=&#123;() =&gt; this.updateNumber(-1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">                    Decrease</span></span><br><span class="line"><span class="regexp">          &lt;/</span>button&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    updateNumber(toAdd) &#123;</span></span><br><span class="line"><span class="regexp">        this.props.parent.setState(prevState =&gt; (&#123;</span></span><br><span class="line"><span class="regexp">            number: prevState.number + toAdd</span></span><br><span class="line"><span class="regexp">        &#125;));</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></controls></p>
<p>当前的实现有什么问题？<br>• 第一个问题是： <app> 的封装被破坏，因为它的内部结构在应用中传递。<app> 错误地允许 <controls> 直接去修改其 state。<br>• 第二个问题是: 子组件 Controls 知道了太多父组件 <app> 的内部细节，它可以访问父组件的实例，知道父组件是一个有状态组件，知道父组件的 state 对象的细节(知道 number 是父组件 state 的属性)，并且知道怎么去更新父组件的 state.<br>一个麻烦的结果是： <controls> 将很难测试和重用。对 <app> 结构的细微修改会导致需要对 <controls> 进行修改（对于更大的应用程序，也会导致类似耦合的组件需要修改）。<br>解决方案是设计一个方便的通信接口，考虑到松耦合和封装。让我们改进两个组件的结构和属性，以便恢复封装。<br>只有组件本身应该知道它的状态结构。<app> 的状态管理应该从 <controls>（updateNumber()方法）移到正确的位置：即 <app> 组件中。</app></controls></app></controls></app></controls></app></controls></app></app></p>
<p><app> 被修改为 <controls> 设置属性 onIncrease 和 onDecrease。这些是更新 <app> 状态的回调函数:<br>// 解决: 恢复封装<br>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123; <span class="attr">number</span>: <span class="number">0</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div className=<span class="string">"app"</span>&gt;</span><br><span class="line">                &lt;span className=<span class="string">"number"</span>&gt;&#123;<span class="keyword">this</span>.state.number&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">                &lt;Controls</span></span><br><span class="line"><span class="regexp">                    onIncrease=&#123;() =&gt; this.updateNumber(+1)&#125;</span></span><br><span class="line"><span class="regexp">                    onDecrease=&#123;() =&gt; this.updateNumber(-1)&#125;</span></span><br><span class="line"><span class="regexp">                /</span>&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        );</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    updateNumber(toAdd) &#123;</span></span><br><span class="line"><span class="regexp">        this.setState(prevState =&gt; (&#123;</span></span><br><span class="line"><span class="regexp">            number: prevState.number + toAdd</span></span><br><span class="line"><span class="regexp">        &#125;));</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></app></controls></app></p>
<p>现在，<controls> 接收用于增加和减少数值的回调，注意解耦和封装恢复时：<controls> 不再需要访问父组件实例。也不会直接去修改父组件的状态。<br>而且，<controls> 被修改为了一个函数式组件:<br>// 解决方案: 使用回调函数去更新父组件的状态<br>              <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Controls</span>(<span class="params">&#123; onIncrease, onDecrease &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div className=<span class="string">"controls"</span>&gt;</span><br><span class="line">            &lt;button onClick=&#123;onIncrease&#125;&gt;Increase&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">            &lt;button onClick=&#123;onDecrease&#125;&gt;Decrease&lt;/</span>button&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></controls></controls></controls></p>
<p><app> 组件的封装已经恢复，状态由其本身管理，也应该如此。<br>此外，<controls> 不在依赖 <app> 的实现细节，onIncrease 和 onDecrease 在按钮被点击的时候调用，<controls> 不知道(也不应该知道)这些回调的内部实现。</controls></app></controls></app></p>
<p><controls> 组件的可重用性和可测试性显著增加。</controls></p>
<p><controls> 的复用变得很容易，因为它除了需要回调，没有其它依赖。测试也变得简单，只需验证单击按钮时，回调是否执行。</controls></p>
<h1 id="组成结构和权威组成部分。只需将它们分成较小的块，然后使用合成将整个背面粘合在一起，即可使复杂的过程变得简单。"><a href="#组成结构和权威组成部分。只需将它们分成较小的块，然后使用合成将整个背面粘合在一起，即可使复杂的过程变得简单。" class="headerlink" title="组成结构和权威组成部分。只需将它们分成较小的块，然后使用合成将整个背面粘合在一起，即可使复杂的过程变得简单。"></a>组成结构和权威组成部分。只需将它们分成较小的块，然后使用合成将整个背面粘合在一起，即可使复杂的过程变得简单。</h1><h2 id="单一责任"><a href="#单一责任" class="headerlink" title="单一责任"></a>单一责任</h2><p>组成的一个重要方面是能够由较小的专用组件组成复杂的组件。这种分而治之的方法有助于授权机构遵循单一责任原则。<br>回顾以前的代码片段。<application>负责呈现页眉，页脚，侧边栏和主要区域。<br>有意义的划分这个责任为四个子的责任，每个由专门的组件来实现<header>，<sidebar>，<content>和<footer>。后来的合成<application>从这些专用组件重新粘合。<br>现在带来好处。组合<application>通过允许其子级执行子职责而使其遵循单一职责原则。</application></application></footer></content></sidebar></header></application></p>
<h2 id="可重用性"><a href="#可重用性" class="headerlink" title="可重用性"></a>可重用性</h2><p>使用组合的组件可以重用通用逻辑。这就是可重用性的好处。<br>例如，组件<composed1>和<composed2>共享通用代码：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> instance1 = (</span><br><span class="line">  &lt;Composed1&gt;</span><br><span class="line">    <span class="comment">/* Specific to Composed1 code... */</span></span><br><span class="line">    <span class="comment">/* Common code... */</span></span><br><span class="line">  &lt;<span class="regexp">/Composed1&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp">const instance2 = (</span></span><br><span class="line"><span class="regexp">  &lt;Composed2&gt;</span></span><br><span class="line"><span class="regexp">    /</span>* Common code... *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">    /</span>* Specific to Composed2 code... *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">  &lt;/</span>Composed2&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></composed2></composed1></p>
<p>由于重复代码是一种不好的做法，因此如何使组件重用通用代码？<br>首先，将通用代码封装在一个新组件中<common>。其次，<composed1>并<composed2>应使用组成包括<common>，修复代码重复：<br>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> instance1 = (</span><br><span class="line">  &lt;Composed1&gt;</span><br><span class="line">    &lt;Piece1 /&gt;</span><br><span class="line">    &lt;Common /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Composed1&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp">const instance2 = (</span></span><br><span class="line"><span class="regexp">  &lt;Composed2&gt;</span></span><br><span class="line"><span class="regexp">    &lt;Common /</span>&gt;</span><br><span class="line">    &lt;Piece2 /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Composed2&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure></common></composed2></composed1></common></p>
<p>可重用组件有利于“不要重复自己（DRY）”原则。这种有益的做法节省了精力和时间。</p>
<h1 id="可重用的组件是设计良好的系统的结果。尽可能重复使用代码，以避免重复。"><a href="#可重用的组件是设计良好的系统的结果。尽可能重复使用代码，以避免重复。" class="headerlink" title="可重用的组件是设计良好的系统的结果。尽可能重复使用代码，以避免重复。"></a>可重用的组件是设计良好的系统的结果。尽可能重复使用代码，以避免重复。</h1><p>一个可重用的组件写入一次，但多次使用。<br>想象一个幻想世界，其中软件开发主要是在重新发明轮子。<br>编码时，不能使用任何现有的库或实用程序。即使在整个应用程序中，您也无法使用已经编写的代码。<br>在这种环境下，是否可以在合理的时间内编写应用程序？当然不。<br>欢迎重用。使事情起作用，而不是重新发明它们的工作方式。</p>
<h2 id="4-1跨应用程序重用"><a href="#4-1跨应用程序重用" class="headerlink" title="4.1跨应用程序重用"></a>4.1跨应用程序重用</h2><p>根据“不要重复自己（DRY）”原则，每条知识在系统中必须具有唯一，明确，权威的表示形式。该原则建议避免重复。<br>代码重复会增加复杂性和维护工作，而不会增加重大价值。逻辑的更新迫使您修改应用程序中的所有克隆。<br>重复性问题通过可重用的组件解决。一次编写，多次使用：高效省时的策略。<br>但是，您不会免费获得可重用性属性。如果组件符合单一职责原则并具有正确的封装，则可以重用。<br>遵守单一责任至关重要：<br>重用组件实际上意味着重用其责任实现。<br>仅负责一项的组件最容易重用。<br>但是，当一个组件错误地承担多个职责时，其重用会增加沉重的开销。您只想重用一个职责实施，还可以获取不适当的职责不必要的实施。<br>您想要一个香蕉，就得到一个香蕉，再加上所有的丛林。<br>正确的封装会创建一个不依赖于依赖项的组件。隐藏的内部结构和集中的支柱使组件可以很好地适合要重用的多个位置。</p>
<h2 id="4-2重用第三方库"><a href="#4-2重用第三方库" class="headerlink" title="4.2重用第三方库"></a>4.2重用第三方库</h2><p>一个正常的工作日。您已经阅读了向应用程序添加新功能的任务。启动文本编辑器之前，请等待几分钟……<br>您开始解决的问题很有可能已经解决。由于React的受欢迎程度和强大的开源社区，值得寻找现有的解决方案。<br>请查看brillout / awesome-react-components存储库，该存储库具有可重用组件的已编译列表。<br>好的图书馆会对架构决策产生积极影响，并倡导最佳实践。以我的经验，最有影响力的人物是react-router和redux。<br>react-router使用声明性路由来构建单页应用程序。<br>使用将URL路径与您的组件相关联<route>。然后，当用户访问匹配的URL时，路由器将为您呈现该组件。<br>redux和react-redux HOC引入了单向和可预测的应用程序状态管理。它从组件中提取异步和不纯净的代码（例如HTTP请求），支持单一职责原则并创建纯净或几乎纯净的组件。</route></p>
<h1 id="诸如网络请求或全局变量之类的副作用使组件取决于环境。通过为相同的prop值返回相同的输出来使其纯净。"><a href="#诸如网络请求或全局变量之类的副作用使组件取决于环境。通过为相同的prop值返回相同的输出来使其纯净。" class="headerlink" title="诸如网络请求或全局变量之类的副作用使组件取决于环境。通过为相同的prop值返回相同的输出来使其纯净。"></a>诸如网络请求或全局变量之类的副作用使组件取决于环境。通过为相同的prop值返回相同的输出来使其纯净。</h1><p>甚至认为使用Redux都需要其他构造，例如动作，减速器和Sagas，它有助于使<fetchweather>纯净。<br>让我们进行修改<weatherfetch>以与Redux一起使用：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; fetch &#125; <span class="keyword">from</span> <span class="string">'./action'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherFetch</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">   render() &#123;</span><br><span class="line">     <span class="keyword">const</span> &#123; temperature, windSpeed &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">     <span class="keyword">return</span> (</span><br><span class="line">       &lt;WeatherInfo temperature=&#123;temperature&#125; windSpeed=&#123;windSpeed&#125; /&gt;</span><br><span class="line">     );</span><br><span class="line">   &#125;</span><br><span class="line">   componentDidMount() &#123;</span><br><span class="line">     <span class="keyword">this</span>.props.fetch();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapStateToProps</span>(<span class="params">state</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    temperature: state.temperate,</span><br><span class="line">    windSpeed: state.windSpeed</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps, &#123; fetch &#125;);</span><br><span class="line">connect(mapStateToProps, &#123; fetch &#125;)HOC包装&lt;WeatherFetch&gt;。</span><br></pre></td></tr></table></figure></weatherfetch></fetchweather></p>
<h1 id="有意义的组件命名和表达性代码是可读性的关键。您的代码必须易于理解并且欢迎阅读。"><a href="#有意义的组件命名和表达性代码是可读性的关键。您的代码必须易于理解并且欢迎阅读。" class="headerlink" title="有意义的组件命名和表达性代码是可读性的关键。您的代码必须易于理解并且欢迎阅读。"></a>有意义的组件命名和表达性代码是可读性的关键。您的代码必须易于理解并且欢迎阅读。</h1><p>一个有意义的组件很容易理解它的作用。<br>很难低估可读代码的重要性。您多少次被代码遮住了？您看到字符，但看不到含义。<br>开发人员花费大量时间阅读和理解代码，而不是实际编写代码。编码活动占75％的时间理解代码，20％的时间修改现有代码和5％的代码编写新代码（源）。<br>花一点时间在可读性上会减少以后对队友和您自己的理解时间。随着应用程序的增长，命名实践变得很重要，因为理解的努力会随着代码量的增加而增加。<br>读取有意义的代码很容易。但是，有意义地编写代码需要简洁的代码实践和不断的努力以清晰地表达自己。</p>
<h2 id="帕斯卡案"><a href="#帕斯卡案" class="headerlink" title="帕斯卡案"></a>帕斯卡案</h2><p>组件名称是在pascal情况下一个或多个单词（主要是名词）的串联。例如<datepicker>，<griditem>，<application>，<header>。</header></application></griditem></datepicker></p>
<h2 id="专业化"><a href="#专业化" class="headerlink" title="专业化"></a>专业化</h2><p>组件越特殊，其名称可能包含的单词越多。<br>名为的组件<headermenu>建议在标题中显示菜单。名称<sidebarmenuitem>表示位于侧栏中的菜单项。<br>当名称有意义地暗示意图时，组件很容易理解。为此，通常必须使用冗长的名称。很好：冗长多于清晰。<br>假设您浏览一些项目文件并确定2个组件：<authors>和<authorslist>。仅根据名称，您能得出它们之间的区别吗？很有可能不会。<br>要获取详细信息，您必须打开<authors>源文件并浏览代码。完成此操作后，您将意识到<authors>从服务器获取作者列表并呈现<authorslist>表示性组件。<br>使用更专业的名称代替<authors>不会导致这种情况。更好的名称<fetchauthors>，<authorscontainer>或<authorspage>。<br>简洁胜于简洁。</authorspage></authorscontainer></fetchauthors></authors></authorslist></authors></authors></authorslist></authors></sidebarmenuitem></headermenu></p>
<h2 id="一个字-一个概念"><a href="#一个字-一个概念" class="headerlink" title="一个字-一个概念"></a>一个字-一个概念</h2><p>一个词代表一个概念。例如，呈现项目概念的集合由列表词表示。<br>每个概念选择一个词，然后在整个应用程序中保持关系的一致性。结果是可预测的单词心理映射-您已经习惯了概念。<br>当同一概念由许多单词表示时，可读性会受到影响。例如，您定义一个呈现订单列表的组件，<orderslist>另一个定义呈现费用列表的组件<expensestable>。<br>呈现项目集合的相同概念由两个不同的词表示：list和table。没有理由为同一概念使用不同的词。它增加了混乱并破坏了命名的一致性。<br>命名组件<orderslist>和<expenseslist>（使用列表词）或<orderstable>和<expensestable>（使用表词）。使用您认为更好的任何单词，只要保持一致即可。<br>测试不仅是自动检测错误的方法。如果您发现难以测试的组件，则很可能是设计错误的组件。</expensestable></orderstable></expenseslist></orderslist></expensestable></orderslist></p>
<h1 id="在封装一个组件的时候应该先思考什么"><a href="#在封装一个组件的时候应该先思考什么" class="headerlink" title="在封装一个组件的时候应该先思考什么?"></a>在封装一个组件的时候应该先思考什么?</h1><p>这个组件应该是做什么的<br>这个组件应该至少需要知道那些信息<br>这个组件会反馈什么东西<br>在设计一个组件的时候我们不应该仅限于实现当前的需求，<br>设计出一个只适用于单一项目的组件，而是应该是一个可以适应大部分同种需求的通用组件。<br>所以我们在碰到一个需求的时候应该首先对需求进行抽象，而不是看到设计稿就撸着袖子上。<br>例如碰到一个轮播图组件的需求的时候，我们拆分以下这个需求，可以得到：<br>（1） 这个组件要做什么：<br>可以展示多张图片<br>可以向左向右翻页，或者是可以是上下翻页<br>PageControl的状态会根据图片的滚动而相应改变 还有可能有一些隐藏的需求，类似于：<br>应该支持左右两侧或者上下无限循环滚动<br>可以选择的是否自动轮播<br>支持手动滑动切换图片<br>图片有点击事件，可以点击来进行相关的事件反应<br>（2）这个组件至少应该知道什么信息<br>一个好的组件应该是要像存在魔法一样，只需要极其少数的参数和条件就可以得到期望的效果。就像这个轮播图组件一样，组件应该至少知道的信息有：<br>图片的url地址数组<br>当图片不存在时候的占位图<br>其他可以知道也可以不知道的信息可以有：<br>是否开启自动轮播，默认是开启或者不开启<br>图片滚动是左右还是上下，默认是左右<br>等等 ………………………………<br>（3）这个组件会反馈什么<br>一个可用的轮播图效果</p>
]]></content>
  </entry>
  <entry>
    <title>react hooks</title>
    <url>/2020/08/25/react-hooks/</url>
    <content><![CDATA[<h1 id="1-userContext"><a href="#1-userContext" class="headerlink" title="1.userContext"></a>1.userContext</h1><p>关于React Hooks中使用useContext 进行父子组件传值（父子组件不在同一个文件中）<br>1、封装的公共文件<br>// createContext.js文件<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createContext &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">const</span> myContext = createContext(<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> myContext;</span><br></pre></td></tr></table></figure></p>
<p>2、父组件<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState&#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> Counter <span class="keyword">from</span> <span class="string">'./Counter'</span></span><br><span class="line"><span class="keyword">import</span> myContext <span class="keyword">from</span> <span class="string">'./createContext'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h4&gt;我是父组件&lt;<span class="regexp">/h4&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;点击了 &#123;count&#125; 次!&lt;/</span>p&gt;</span><br><span class="line">      &lt;button</span><br><span class="line">        onClick=&#123;() =&gt; &#123;</span><br><span class="line">          setCount(count + <span class="number">1</span>);</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      &gt;</span><br><span class="line">        点我</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">      &#123;/</span>* 关键代码 *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">      &#123;/</span>* 提供器 *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">      &lt;myContext.Provider value=&#123;count&#125;&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Counter /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/myContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure></p>
<p>3、子组件<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useContext&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> myContext <span class="keyword">from</span> <span class="string">'./createContext'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 关键代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> count = useContext(myContext);  <span class="comment">// 得到父组件传的值</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;h4&gt;我是子组件&lt;<span class="regexp">/h4&gt;</span></span><br><span class="line"><span class="regexp">            &lt;p&gt;这是父组件传过来的值：&#123;count&#125;&lt;/</span>p&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Counter;</span></span><br></pre></td></tr></table></figure></p>
<h1 id="2-useCallback"><a href="#2-useCallback" class="headerlink" title="2.useCallback"></a>2.useCallback</h1><p>它会返回相同的引用，避免子组件进行无意义的重复渲染：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> memoizedHandleClick = useCallback(</span><br><span class="line">    () =&gt; <span class="built_in">console</span>.log(<span class="string">`Click happened with dependency: <span class="subst">$&#123;count&#125;</span>`</span>), [count],</span><br><span class="line">  ); </span><br><span class="line">  <span class="keyword">return</span> &lt;Button onClick=&#123;memoizedHandleClick&#125;&gt;Click Me&lt;/Button&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="3-useMemo-、-React-memo"><a href="#3-useMemo-、-React-memo" class="headerlink" title="3.useMemo 、 React.memo"></a>3.useMemo 、 React.memo</h1><p>useCallback缓存的是方法的引用，而useMemo缓存的则是方法的返回值。使用场景是减少不必要的子组件渲染：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">&#123; a, b &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 当 a 改变时才会重新渲染</span></span><br><span class="line">  <span class="keyword">const</span> child1 = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> &lt;Child1 a=&#123;a&#125; /&gt;, [a]);</span><br><span class="line">  <span class="comment">// 当 b 改变时才会重新渲染</span></span><br><span class="line">  <span class="keyword">const</span> child2 = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> &lt;Child2 b=&#123;b&#125; /&gt;, [b]);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &#123;child1&#125;</span><br><span class="line">      &#123;child2&#125;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>如果想实现Class Component的shouldComponentUpdate方法，可以使用React.memo方法，区别是它只能比较 props，不会比较 state：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Parent = React.memo(<span class="function">(<span class="params">&#123; a, b &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 当 a 改变时才会重新渲染</span></span><br><span class="line">  <span class="keyword">const</span> child1 = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> &lt;Child1 a=&#123;a&#125; /&gt;, [a]);</span><br><span class="line">  <span class="comment">// 当 b 改变时才会重新渲染</span></span><br><span class="line">  <span class="keyword">const</span> child2 = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> &lt;Child2 b=&#123;b&#125; /&gt;, [b]);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &#123;child1&#125;</span><br><span class="line">      &#123;child2&#125;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br></pre></td></tr></table></figure></p>
<h1 id="封装自定义-usePrevious"><a href="#封装自定义-usePrevious" class="headerlink" title="封装自定义 usePrevious"></a>封装自定义 usePrevious</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> usePrevious = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> ref = useRef();</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    ref.current = value;</span><br><span class="line">  &#125;, [value]);</span><br><span class="line">  <span class="keyword">return</span> ref.current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> prevCountRef = usePrevious(count);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">0</span>);</span><br><span class="line">  <span class="comment">// useEffect(() =&gt; &#123;</span></span><br><span class="line">  <span class="comment">//   console.log(1);</span></span><br><span class="line">  <span class="comment">//   prevCountRef.current = count;</span></span><br><span class="line">  <span class="comment">// &#125;);</span></span><br><span class="line">  <span class="keyword">const</span> prevCount = prevCountRef;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;</span><br><span class="line">        Now: &#123;count&#125;, <span class="attr">before</span>: &#123;prevCount&#125;</span><br><span class="line">      &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;click here&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<h1 id="Hooks-的坑"><a href="#Hooks-的坑" class="headerlink" title="Hooks 的坑"></a>Hooks 的坑</h1><p>Hooks 的坑 99% 都是闭包引起的，我们通过一个例子来了解下什么情况下会因为闭包导致问题。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [state, setState] = React.useState(<span class="number">0</span>)</span><br><span class="line">  <span class="comment">// 连点三次你觉得答案会是什么？</span></span><br><span class="line">  <span class="keyword">const</span> handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setState(state + <span class="number">1</span>)</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(state)</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;div&gt;&#123;state&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;handleClick&#125; /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>复制代码<br>上述代码触发三次 handleClick 后你觉得答案会是什么？可能答案与你所想的不大一样，结果是：</p>
<p>0 1 2</p>
<p>因为每次 render 都有一份新的状态，因此上述代码中的 setTimeout 使用产生了一个闭包，捕获了每次 render 后的 state，也就导致了输出了 0、1、2。</p>
<p>如果你希望输出的内容是最新的 state 的话，可以通过 useRef 来保存 state。前文讲过 ref 在组件中只存在一份，无论何时使用它的引用都不会产生变化，因此可以来解决闭包引发的问题。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [state, setState] = React.useState(<span class="number">0</span>)</span><br><span class="line">  <span class="comment">// 用 ref 存一下</span></span><br><span class="line">  <span class="keyword">const</span> currentState = React.useRef(state)</span><br><span class="line">  <span class="comment">// 每次渲染后更新下值</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    currentState.current = state</span><br><span class="line">  &#125;)</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">const</span> handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setState(state + <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 这样定时器里通过 ref 拿到最新值</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(currentState.current)</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;div&gt;&#123;state&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;handleClick&#125; /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>其实闭包引发的问题多半是保存了 old 的值，只要想办法拿到最新的值其实基本上就解决问题了。</p>
<h1 id="函数式组件-usestate-render"><a href="#函数式组件-usestate-render" class="headerlink" title="函数式组件 usestate render"></a>函数式组件 usestate render</h1><h2 id="react合成事件里的setState操作也是batch操作"><a href="#react合成事件里的setState操作也是batch操作" class="headerlink" title="react合成事件里的setState操作也是batch操作"></a>react合成事件里的setState操作也是batch操作</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">"./styles.css"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [counter1, setCounter1] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [counter2, setCounter2] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [counter3, setCounter3] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [renderCount, setRenderCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setRenderCount(renderCount + <span class="number">1</span>);</span><br><span class="line">  &#125;, [counter1, counter2, counter3]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setCounter1(counter1 + <span class="number">1</span>);</span><br><span class="line">    setCounter2(counter2 + <span class="number">1</span>);</span><br><span class="line">    setCounter3(counter3 + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">'App'</span>&gt;</span><br><span class="line">      &lt;h1&gt;<span class="built_in">Function</span> Component&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        Counter1: &#123;counter1&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        Counter2: &#123;counter2&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        Counter3: &#123;counter3&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">      &lt;br/&gt;</span><br><span class="line">      &lt;div&gt;Component was rendered &#123;renderCount&#125; times&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;handleClick&#125;&gt;Click me&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="不会批处理的情况"><a href="#不会批处理的情况" class="headerlink" title="不会批处理的情况"></a>不会批处理的情况</h2><p>请注意，此功能并不总是有效。在使用不同种类的，例如一个异步操作的事件处理程序async/await，then/catch，setTimeout，fetch，等独立的状态更新将不会进行批处理。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">"./styles.css"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [counter1, setCounter1] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [counter2, setCounter2] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [counter3, setCounter3] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [renderCount, setRenderCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setRenderCount(renderCount + <span class="number">1</span>);</span><br><span class="line">  &#125;, [counter1, counter2, counter3]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleClickAsync = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> setCounter1(counter1 + <span class="number">1</span>);</span><br><span class="line">    setCounter2(counter2 + <span class="number">1</span>);</span><br><span class="line">    setCounter3(counter3 + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleClickThen = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      setCounter1(counter1 + <span class="number">1</span>);</span><br><span class="line">      setCounter2(counter2 + <span class="number">1</span>);</span><br><span class="line">      setCounter3(counter3 + <span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">'App'</span>&gt;</span><br><span class="line">      &lt;h1&gt;<span class="built_in">Function</span> Component&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        Counter1: &#123;counter1&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        Counter2: &#123;counter2&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        Counter3: &#123;counter3&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">      &lt;br/&gt;</span><br><span class="line">      &lt;div&gt;Component was rendered &#123;renderCount&#125; times&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;handleClickAsync&#125;&gt;Async handler&lt;/</span>button&gt;</span><br><span class="line">      &lt;button onClick=&#123;handleClickThen&#125;&gt;Then handler&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="如何强制分批处理？"><a href="#如何强制分批处理？" class="headerlink" title="如何强制分批处理？"></a>如何强制分批处理？</h2><p>幸运的是，通过使用，我们可以克服这一问题ReactDOM.unstable_batchUpdate，并且仍然可以根据需要从状态批处理更新中受益。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">"./styles.css"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [counter1, setCounter1] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [counter2, setCounter2] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [counter3, setCounter3] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [renderCount, setRenderCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setRenderCount(renderCount + <span class="number">1</span>);</span><br><span class="line">  &#125;, [counter1, counter2, counter3]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleClickThen = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      ReactDOM.unstable_batchedUpdates(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setCounter1(counter1 + <span class="number">1</span>);</span><br><span class="line">      setCounter2(counter2 + <span class="number">1</span>);</span><br><span class="line">      setCounter3(counter3 + <span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">'App'</span>&gt;</span><br><span class="line">      &lt;h1&gt;<span class="built_in">Function</span> Component&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        Counter1: &#123;counter1&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        Counter2: &#123;counter2&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        Counter3: &#123;counter3&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">      &lt;br/&gt;</span><br><span class="line">      &lt;div&gt;Component was rendered &#123;renderCount&#125; times&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;handleClickThen&#125;&gt;Then handler&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Chrome time 分析</title>
    <url>/2020/07/03/Chrome-time-%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="Stalled（阻塞）"><a href="#Stalled（阻塞）" class="headerlink" title="Stalled（阻塞）"></a>Stalled（阻塞）</h1><p>　　浏览器对同一个主机域名的并发连接数有限制，因此如果当前的连接数已经超过上限，那么其余请求就会被阻塞，等待新的可用连接；此外脚本也会阻塞其他组件的下载；</p>
<p>　　优化措施：</p>
<p>　　1、将资源合理分布到多台主机上，可以提高并发数，但是增加并行下载数量也会增大开销，这取决于带宽和CPU速度，过多的并行下载会降低性能；</p>
<p>　　2、脚本置于页面底部；</p>
<h1 id="DNS-Lookup（域名解析）"><a href="#DNS-Lookup（域名解析）" class="headerlink" title="DNS Lookup（域名解析）"></a>DNS Lookup（域名解析）</h1><p>　　请求某域名下的资源，浏览器需要先通过DNS解析器得到该域名服务器的IP地址。在DNS查找完成之前，浏览器不能从主机名那里下载到任何东西。</p>
<p>　　优化措施：</p>
<p>　　1、利用DNS缓存（设置TTL时间）；</p>
<p>　　2、利用Connection:keep-alive特性建立持久连接，可以在当前连接上进行多个请求，无需再进行域名解析；</p>
<h1 id="Initial-connection（初始化连接）"><a href="#Initial-connection（初始化连接）" class="headerlink" title="Initial connection（初始化连接）"></a>Initial connection（初始化连接）</h1><p>　　TCP建立连接的三次握手时间</p>
<h1 id="SSL（包含于HTTPS连接中）"><a href="#SSL（包含于HTTPS连接中）" class="headerlink" title="SSL（包含于HTTPS连接中）"></a>SSL（包含于HTTPS连接中）</h1><p>　　http是超文本传输协议，以明文方式发送内容，不提供任何方式的数据加密，如果被不法分子截取浏览器和服务器之间的传输报文，会获取其中的信息。</p>
<p>　　https 是安全套接字层超文本传输协议，就是在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</p>
<p>　　因此建立HTTPS连接的时间相当于三次握手的时间+SSL时间。</p>
<h1 id="Request-sent（发送请求）"><a href="#Request-sent（发送请求）" class="headerlink" title="Request sent（发送请求）"></a>Request sent（发送请求）</h1><p>　　发送HTTP请求的时间（从第一个bit到最后一个bit）</p>
<p>　　优化措施：</p>
<p>　　1、减少HTTP请求，可以使用CSS Sprites、内联图片、合并脚本和样式表等；</p>
<p>　　2、对不常变化的组件添加长久的Expires头（相当于设置久远的过期时间），在后续的页面浏览中可以避免不必要的HTTP请求；</p>
<h1 id="Waiting（等待响应）"><a href="#Waiting（等待响应）" class="headerlink" title="Waiting（等待响应）"></a>Waiting（等待响应）</h1><p>　　通常是耗费时间最长的。从发送请求到收到响应之间的空隙，会受到线路、服务器距离等因素的影响。</p>
<p>　　优化措施：</p>
<p>　　1、使用CDN，将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求，提高响应速度；</p>
<h1 id="Content-Download（下载）"><a href="#Content-Download（下载）" class="headerlink" title="Content Download（下载）"></a>Content Download（下载）</h1><p>　　下载HTTP响应的时间（包含头部和响应体）</p>
<p>　　优化措施：</p>
<p>　　1、通过条件Get请求，对比If-Modified-Since和Last-Modified时间，确定是否使用缓存中的组件，服务器会返回“304 Not Modified”状态码，减小响应的大小；</p>
<p>　　2、移除重复脚本，精简和压缩代码，如借助自动化构建工具grunt、gulp等；</p>
<p>　　3、压缩响应内容，服务器端启用gzip压缩，可以减少下载时间</p>
]]></content>
  </entry>
  <entry>
    <title>nodejs相关记录</title>
    <url>/2020/06/30/nodejs%E7%9B%B8%E5%85%B3%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="nvm管理node-版本号"><a href="#nvm管理node-版本号" class="headerlink" title="nvm管理node 版本号"></a>nvm管理node 版本号</h1><p>在mac和liunx系统里边  nvm use 切换的是当次版本   下次打开终端  还是之前的node版本</p>
<p>要想永久切换   使用nvm alias default （版本号）</p>
<h1 id="path-resolve-路径"><a href="#path-resolve-路径" class="headerlink" title="path.resolve 路径"></a>path.resolve 路径</h1><p>// 当前工作目录与当前文件路径(F:/1/2/task6/test/dist)有区别<br>path.resolve();                               //  F:/1/2/task6/test 当前工作目录的绝对路径<br>path.resolve(‘./a’);                          //  F:/1/2/task6/test/a<br>path.resolve(‘../a’);                         //  F:/1/2/task6/a<br>path.resolve(‘.’);                            //  F:/1/2/task6/test<br>path.resolve(‘..’);                           //  F:/1/2/task6<br>path.resolve(‘/‘));                           //  F:/<br>path.resolve(‘./a’,’../c/d’);                 //  F:/1/2/task6/test/c/d<br>path.resolve(‘./a’,’./c/d’);                  //  F:/1/2/task6/test/a/c/d<br>path.resolve(‘/a’,’../c/d’);                  //  F:c/d<br>path.resolve(‘/a’,’./c/d’);                   //  F:/a/c/d<br>path.resolve(‘./a’,’/b’,’./c/d’);             //  F:/b/c/d<br>path.resolve(‘a’,’b’,’c/d’);                  //  F:/1/2/task6/test/a/b/c/d<br>path.resolve(‘./a’,’./b’,’c/d’);              //  F:/1/2/task6/test/a/b/c/d<br>path.resolve(‘./a’,’/b’,’c/d’);               //  F:/b/c/d<br>path.resolve(‘./a/b’,’..’,’c/d’);             //  F:/1/2/task6/test/a/c/d<br>path.resolve(‘./a’,’..’,’c/d’);               //  F:/1/2/task6/test/c/d<br>————————————————</p>
<h1 id="paht-join"><a href="#paht-join" class="headerlink" title="paht.join"></a>paht.join</h1><p>path.join(‘/foo’, ‘bar’, ‘baz/asdf’, ‘quux’, ‘.’);          //  返回 /foo/bar/baz/asdf/quux, “.”和”/“没什么影响<br>path.join(‘/foo’, ‘./bar’, ‘baz/asdf’, ‘.’, ‘quux’);        //  返回 /foo/bar/baz/asdf/quux<br>path.join(‘/foo’, ‘./bar’, ‘./baz/asdf’, ‘quux’, ‘..’);     //  返回 /foo/bar/baz/asdf<br>path.join(‘/foo’, ‘bar’, ‘baz/asdf’, ‘.’, ‘.’);             //  返回 /foo/bar/baz/asdf<br>path.join(‘/foo’, ‘bar’, ‘baz/asdf’, ‘quux’);               //  返回 /foo/bar/baz/asdf/quux<br>path.join(‘/foo’, ‘bar’, ‘baz/asdf’, ‘..’, ‘..’);           //  返回 /foo/bar<br>————————————————</p>
]]></content>
  </entry>
  <entry>
    <title>React HOC ref 用法</title>
    <url>/2020/06/04/React-HOC-ref-%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<p>昨天参加面试被问到hoc 父组件的static 方法的传递</p>
<p>关键点就是React.forwardRef的API中ref必须指向dom元素而不是React组件。</p>
<p>一、React.forwardRef使用示例<br>下面就是应用到React组件的错误示例：</p>
<p>const A=React.forwardRef((props,ref)=&gt;<b {...props}="" ref="{ref}/">)<br>这就是我之前经常犯的错误， 这里的ref是无法生效的。</b></p>
<p>前面提到ref必须指向dom元素，那么正确方法就应用而生：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span>  A=React.forwardRef(<span class="function">(<span class="params">props,ref</span>)=&gt;</span>(</span><br><span class="line">&lt;div ref=&#123;ref&#125;&gt;</span><br><span class="line">&lt;B &#123;...props&#125; /&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">))</span></span><br></pre></td></tr></table></figure></p>
<p>二、React.forwardRef应用到高阶组件中<br>2.1. withComponent类型的高阶组件【1】<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> A <span class="keyword">from</span> <span class="string">'./a.jsx'</span></span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withA</span>(<span class="params">Component</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ForWardedComponent = React.forwardRef(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> &lt;div ref=&#123;ref&#125;&gt;</span><br><span class="line">               &lt;Component &#123;...props&#125; /&gt;</span><br><span class="line">           &lt;<span class="regexp">/div&gt;);</span></span><br><span class="line"><span class="regexp">     class MidComponent extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">        render() &#123;</span></span><br><span class="line"><span class="regexp">            const props = this.props</span></span><br><span class="line"><span class="regexp">            return (</span></span><br><span class="line"><span class="regexp">                &lt;A &#123;...props&#125;&gt;</span></span><br><span class="line"><span class="regexp">                  &lt;ForWardedComponent  ref=&#123;props.forwardedRef&#125; &#123;...props&#125;/</span>&gt;</span><br><span class="line">            &lt;<span class="regexp">/A&gt;</span></span><br><span class="line"><span class="regexp">            )</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    </span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/对MidComponent组件属性进行类型经查 </span></span><br><span class="line"><span class="regexp">    MidComponent.propTypes = &#123;</span></span><br><span class="line"><span class="regexp">        forwardedRef: PropTypes.object,</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">    return  MidComponent</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">exports.withA=withA</span></span><br><span class="line"><span class="regexp">这样，在上述示例的组件A中，A的周期componentDidMount() 调用 this.props.forwardedRef.current ,指向的就是上述示例中ForWardedComponent对应的dom元素。</span></span><br><span class="line"><span class="regexp">是B组件对应的dom的父元素，而不是该dom</span></span><br><span class="line"><span class="regexp">在a.jsx中某处:</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    componentDidMount()&#123;</span></span><br><span class="line"><span class="regexp">     console.log(this.props.forwardedRef.current)</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">最后应用实例：</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">import React from 'react'</span></span><br><span class="line"><span class="regexp">import ReactDOM from  'react-dom'</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/假设withA存储于withA.js文件。</span></span><br><span class="line"><span class="regexp">import &#123;withA&#125;   from  './</span>withA.js<span class="string">'  </span></span><br><span class="line"><span class="string"> const B=()=&gt;&lt;h2&gt;hello world&lt;/h2&gt;</span></span><br><span class="line"><span class="string">const B2=withA(B)</span></span><br><span class="line"><span class="string">class App extends React.Component &#123;</span></span><br><span class="line"><span class="string">      constructor(props) &#123;</span></span><br><span class="line"><span class="string">        super(props)</span></span><br><span class="line"><span class="string">        this.forwardedRef=React.creactRef()        </span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        render() &#123;</span></span><br><span class="line"><span class="string">           return  &lt;div&gt;</span></span><br><span class="line"><span class="string">               &lt;B2  forwardedRef=&#123;this.forwardedRef&#125;/&gt;</span></span><br><span class="line"><span class="string">           &lt;/div&gt;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">ReactDOM.render(&lt;App/&gt;,document.getElementById('</span>app<span class="string">'))</span></span><br><span class="line"><span class="string">     </span></span><br><span class="line"><span class="string">2.2 纯粹的高阶组件（Parent-Child）</span></span><br><span class="line"><span class="string">【1】中并不是React组件，只是一个React组件为参数的函数，调用以后才成为React组件。那么直接写入一个Parent组件又该如何呢？</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">import React from '</span>react<span class="string">'</span></span><br><span class="line"><span class="string">import A from '</span>./a.jsx<span class="string">'</span></span><br><span class="line"><span class="string">import PropTypes from '</span>prop-types<span class="string">';</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">function AasParent(props)&#123;</span></span><br><span class="line"><span class="string">    const ForWardedComponent = React.forwardRef((props, ref) =&gt; &lt;div ref=&#123;ref&#125;&gt;</span></span><br><span class="line"><span class="string">               &#123;props.children&#125;</span></span><br><span class="line"><span class="string">           &lt;/div&gt;);</span></span><br><span class="line"><span class="string">      return (</span></span><br><span class="line"><span class="string">                &lt;A &#123;...props&#125;&gt;</span></span><br><span class="line"><span class="string">                  &lt;ForWardedComponent  ref=&#123;props.forwardedRef&#125; &#123;...props&#125;/&gt;</span></span><br><span class="line"><span class="string">            &lt;/A&gt;)</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">AasParent.propTypes = &#123;</span></span><br><span class="line"><span class="string">        forwardedRef: PropTypes.object,</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">module.exports=AasParent</span></span><br><span class="line"><span class="string">最后应用实例：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">import React from '</span>react<span class="string">'</span></span><br><span class="line"><span class="string">import ReactDOM from  '</span>react-dom<span class="string">'</span></span><br><span class="line"><span class="string">//假设AasParent存储于AasParent.jsx文件。注意与【1】中的区别</span></span><br><span class="line"><span class="string">import AasParent   from  '</span>./AasParent.jsx<span class="string">'  </span></span><br><span class="line"><span class="string"> const B=(props)=&gt;&lt;h2&gt;&#123;props.greetings&#125;&lt;/h2&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">class App extends React.Component &#123;</span></span><br><span class="line"><span class="string">      constructor(props) &#123;</span></span><br><span class="line"><span class="string">        super(props)</span></span><br><span class="line"><span class="string">        this.forwardedRef=React.creactRef()        </span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        render() &#123;</span></span><br><span class="line"><span class="string">           return  &lt;AasParent forwardedRef=&#123;this.forwardedRef&#125;&gt;</span></span><br><span class="line"><span class="string">               &lt;B2  greetings="你好，Melo"/&gt;</span></span><br><span class="line"><span class="string">           &lt;/AasParent&gt;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">ReactDOM.render(&lt;App/&gt;,document.getElementById('</span>app<span class="string">'))</span></span><br></pre></td></tr></table></figure></p>
<p>三、总结<br>1.React.forwardRef的API中ref必须指向dom元素而不是React组件。<br>2.在【1】的组件A中，A的周期componentDidMount() 调用 this.props.forwardedRef.current ,指向的就是【1】中ForWardedComponent对应的dom元素。是【1】中B组件对应的dom的父dom元素，而不是该dom。</p>
]]></content>
  </entry>
  <entry>
    <title>Http协议相关</title>
    <url>/2020/05/12/Http%E5%8D%8F%E8%AE%AE%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<p>1.强缓存离不开两个响应头Expires与Cache-Control</p>
<p>Expires：Expires是http1.0提出的一个表示资源过期时间的header，它描述的是一个绝对时间，由服务器返回，Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效<br>Expires: Wed, 11 May 2018 07:20:00 GMT</p>
<p>Cache-Control: Cache-Control 出现于 HTTP / 1.1，优先级高于 Expires ,表示的是相对时间<br>Cache-Control: max-age=315360000<br>强制缓存</p>
<p>Expires<br>响应header中添加Expires字段来标明失效规则。它的值为服务器返回的到期时间，即下一次请求时，请求时间小于服务器返回的到期时间，直接使用缓存数据。<br>response.setDataHeader(“Expires”, “0”);//无缓存<br>复制代码</p>
<p>Cache-Control（优先级高于Expires）<br>Cache-Control是最重要的规则。常见的取值有private、public、no-cache、max-age、no-store,默认为private。</p>
<p>private：只能针对个人用户，而不能被代理服务器缓存；<br>public：指示响应可被任何缓存区缓存；<br>no-cache：强制客户端直接向服务器发送请求,也就是说每次请求都必须向服务器发送。服务器接收到请求，然后判断资源是否变更，是则返回新内容，否则返回304，未变更。<br>max-age：用来设置资源（representations）可以被缓存多长时间，单位为秒；<br>no-store：禁止一切缓存</p>
<p>2.协商缓存<br>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：</p>
<p>协商缓存生效，返回304和Not Modified<br>协商缓存失效，返回200和请求结果</p>
<p>协商缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag 。</p>
<p>ETag/If-None-Match（优先级高于Last-Modified/If-Modified-Since）<br>服务器响应请求时，通过Etag头部告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定），浏览器再次请求时，就会带上一个头If-None-Match，这个值就是服务器上一次给的Etag的值，服务器比对一下资源当前的Etag是否跟If-None-Match一致，不一致则说明资源修改过了，浏览器不能再使用缓存，否则浏览器可以继续使用缓存，并返回304状态码。</p>
<p>Last-Modified/Last-Modified-Since<br>服务器响应请求时，会告诉浏览器一个告诉浏览器资源的最后修改时间：Last-Modified，浏览器之后再请求的时候，会带上一个头：If-Modified-Since，这个值就是服务器上一次给的 Last-Modified 的时间，服务器会比对资源当前最后的修改时间，如果大于If-Modified-Since，则说明资源修改过了，浏览器不能再使用缓存，否则浏览器可以继续使用缓存，并返回304状态码。</p>
]]></content>
  </entry>
  <entry>
    <title>V2Ray断流异常</title>
    <url>/2020/03/15/V2Ray%E6%96%AD%E6%B5%81%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<ol>
<li><p>问题描述<br>最近一段时间发现，代理十分不稳定，经常出现“断流”，具体表现为：打开需要代理的站点，需要访问两次，第一次访问失败，需要再刷新一次。<br>查看错误日志内容：</p>
</li>
<li><p>Proxy|HTTP: failed to read response from r16—sn-ni57dn7z.gvt1.com &gt; io: read/write on closed pipe</p>
</li>
<li><p>问题原因<br>后翻阅issue检查发现，我的代理服务器时间比客户端慢了3分钟，两端时间不一致。</p>
</li>
<li><p>解决办法<br>同步服务器时间</p>
</li>
</ol>
<p>查看当前服务当前时间</p>
<ol>
<li>date -R</li>
<li>timedatectl set-ntp no</li>
<li>timedatectl set-time ‘23:51:00’</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>React 高阶组件 属性代理和反向继承 生命周期调研</title>
    <url>/2019/12/22/React-%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6-%E5%B1%9E%E6%80%A7%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%90%91%E7%BB%A7%E6%89%BF-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%B0%83%E7%A0%94/</url>
    <content><![CDATA[<h2 id="属性代理-Props-Proxy-：-HOC-对传给-WrappedComponent-W-的-porps-进行操作，反向继承-Inheritance-Inversion-：-HOC-继承-WrappedComponent-W。"><a href="#属性代理-Props-Proxy-：-HOC-对传给-WrappedComponent-W-的-porps-进行操作，反向继承-Inheritance-Inversion-：-HOC-继承-WrappedComponent-W。" class="headerlink" title="属性代理(Props Proxy)： HOC 对传给 WrappedComponent W 的 porps 进行操作，反向继承(Inheritance Inversion)： HOC 继承 WrappedComponent W。"></a>属性代理(Props Proxy)： HOC 对传给 WrappedComponent W 的 porps 进行操作，反向继承(Inheritance Inversion)： HOC 继承 WrappedComponent W。</h2><h3 id="1-属性代理"><a href="#1-属性代理" class="headerlink" title="1.属性代理"></a>1.属性代理</h3><p>使用 Props Proxy 可以做什么？</p>
<p>操作 props<br>通过 Refs 访问到组件实例<br>提取 state<br>用其他元素包裹 WrappedComponent<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.message = <span class="string">'World'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  componentWillMount()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"属性代理1 willmount"</span>);  </span><br><span class="line">        &#125;</span><br><span class="line">        componentDidMount()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"属性代理1 didmount"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (&lt;h1&gt;Hello &#123;this.message&#125;&lt;/h1&gt;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyContainer = <span class="function">(<span class="params">WrappedComponent</span>) =&gt;</span> </span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">        componentWillMount()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"HOC属性代理1 willmount"</span>);  </span><br><span class="line">        &#125;</span><br><span class="line">        componentDidMount()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"HOC属性代理1 didmount"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        render()&#123;</span><br><span class="line">            <span class="keyword">return</span> &lt;WrappedComponent &#123;...this.props&#125; /&gt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">const Hocfirst=MyContainer(App);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;Hocfirst/&gt;, window.root);</span><br><span class="line"></span><br><span class="line">\\\</span><br><span class="line"></span><br><span class="line">"HOC属性代理1 willmount"</span><br><span class="line">"属性代理1 willmount"</span><br><span class="line">"属性代理1 didmount"</span><br><span class="line">"HOC属性代理1 didmount"</span><br></pre></td></tr></table></figure></p>
<h3 id="2-反向继承"><a href="#2-反向继承" class="headerlink" title="2.反向继承"></a>2.反向继承</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">replacer</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`function <span class="subst">$&#123;value.name&#125;</span>() &#123;...&#125;`</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stringify</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(value, replacer, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// II debug example</span></span><br><span class="line"><span class="comment">// We are using the Inheritance Inversion technique to display</span></span><br><span class="line"><span class="comment">// the current state and props of the WrappedComponent (the component you want to debug).</span></span><br><span class="line"><span class="comment">// This is based on the technique that Mickael Jackson and Ryan Florence recommend</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">IIHOC</span>(<span class="params">WrappedComponent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">II</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;h2&gt;</span><br><span class="line">            HOC Debugger Component</span><br><span class="line">          &lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">          &lt;p&gt;</span></span><br><span class="line"><span class="regexp">            Props</span></span><br><span class="line"><span class="regexp">          &lt;/</span>p&gt;</span><br><span class="line">          &lt;pre&gt;&#123;stringify(<span class="keyword">this</span>.props)&#125;&lt;<span class="regexp">/pre&gt;</span></span><br><span class="line"><span class="regexp">          &lt;p&gt;</span></span><br><span class="line"><span class="regexp">            State</span></span><br><span class="line"><span class="regexp">          &lt;/</span>p&gt;</span><br><span class="line">          &lt;pre&gt;&#123;stringify(<span class="keyword">this</span>.state)&#125;&lt;<span class="regexp">/pre&gt;</span></span><br><span class="line"><span class="regexp">          &#123;super.render()&#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      name: <span class="string">'fran'</span>,</span><br><span class="line">      email: <span class="string">'franleplant@gmail.com'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h2&gt;</span><br><span class="line">          Wrapped Component</span><br><span class="line">        &lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">        &lt;p&gt;Im a wrapped component&lt;/</span>p&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const EnhancedExample = IIHOC(Example)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;EnhancedExample date=&#123;(new Date).toISOString()&#125; callback=&#123;function test() &#123;&#125;&#125;/</span>&gt;, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">E2：</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComponentChild</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      num: <span class="number">2019</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"child component Did Mount"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  clickComponent() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Component click"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> ( &lt;div &gt; &#123;</span><br><span class="line">        this.state.num</span><br><span class="line">      &#125; &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> iihoc = <span class="function">(<span class="params">WrapComponet</span>) =&gt;</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">WrapComponet</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">super</span>(props)</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">this</span>.state = &#123;</span><br><span class="line"> </span><br><span class="line">          num: <span class="number">2000</span></span><br><span class="line"> </span><br><span class="line">      &#125;</span><br><span class="line"> </span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line"> </span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'iihoc componentDidMount'</span>)</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">this</span>.clickComponent()</span><br><span class="line"> </span><br><span class="line">  &#125;</span><br><span class="line">render()&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line"> </span><br><span class="line">    &lt;div&gt;</span><br><span class="line"> </span><br><span class="line">        &lt;div onClick=&#123;<span class="keyword">this</span>.clickComponent&#125;&gt;iiHoc 点击&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">       &#123;/</span>* &lt;div&gt;&lt;WrapComponet /&gt;&lt;/div&gt; *<span class="regexp">/&#125;/</span><span class="regexp">/用的是父组件的state；</span></span><br><span class="line"><span class="regexp">       &lt;div&gt;&#123;super.render()&#125;&lt;/</span>div&gt;<span class="comment">//反向继承，用的是子组件的state；并且会劫持父组件的生命周期钩子函数componentDidMount，不会执行父组件的componentDidMount</span></span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">)</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">var App = iihoc(ComponentChild)</span></span><br><span class="line"><span class="regexp"> </span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;App/</span>&gt;, <span class="built_in">window</span>.root);</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>h5 hybird webview页面兼容性</title>
    <url>/2019/12/20/h5-hybird-webview%E9%A1%B5%E9%9D%A2%E5%85%BC%E5%AE%B9%E6%80%A7/</url>
    <content><![CDATA[<p>1.在滚动容器上增加滚动 touch 方法<br>将-webkit-overflow-scrolling 值设置为 touch</p>
<p>.wrapper {<br>    -webkit-overflow-scrolling: touch;<br>}</p>
<p>2.iOS 上拉边界下拉出现白色空白<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">'touchmove'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(e._isScroller) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 阻止默认事件</span></span><br><span class="line">    e.preventDefault();</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    passive: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>3.软键盘将页面顶起来、收起未回落问题<br>表现<br>Android 手机中，点击 input 框时，键盘弹出，将页面顶起来，导致页面样式错乱。<br>移开焦点时，键盘收起，键盘区域空白，未回落。<br>产生原因<br>我们在app 布局中会有个固定的底部。安卓一些版本中，输入弹窗出来，会将解压 absolute 和 fixed 定位的元素。导致可视区域变小，布局错乱。<br>原理与解决方案<br>软键盘将页面顶起来的解决方案，主要是通过监听页面高度变化，强制恢复成弹出前的高度。<br>// 记录原有的视口高度<br>const originalHeight = document.body.clientHeight || document.documentElement.clientHeight;</p>
<p>window.onresize = function(){<br>  var resizeHeight = document.documentElement.clientHeight || document.body.clientHeight;<br>  if(resizeHeight &lt; originalHeight ){<br>    document.body.clientHeight = originalHeight;<br>  }<br>}<br>复制代码键盘不能回落问题出现在 iOS 12+ 和 wechat 6.7.4+ 中，而在微信 H5 开发中是比较常见的 Bug。<br>兼容原理，1.判断版本类型 2.更改滚动的可视区域<br>const isWechat = window.navigator.userAgent.match(/MicroMessenger\/([\d.]+)/i);<br>if (!isWechat) return;<br>const wechatVersion = wechatInfo[1];<br>const version = (navigator.appVersion).match(/OS (\d+)<em>(\d+)</em>?(\d+)?/);</p>
<p> // 如果设备类型为iOS 12+ 和wechat 6.7.4+，恢复成原来的视口<br>if (+wechatVersion.replace(/./g, ‘’) &gt;= 674 &amp;&amp; +version[1] &gt;= 12) {<br>  window.scrollTo(0, Math.max(document.body.clientHeight, document.documentElement.clientHeight));<br>}<br>复制代码<br>window.scrollTo(x-coord, y-coord)，其中window.scrollTo(0, clientHeight)恢复成原来的视口</p>
<p>4.微信公众号分享问题<br>表现<br>在微信公众号 H5 开发中，页面内部点击分享按钮调用 SDK，方法不生效。<br>解决方案<br>解决方法：添加一层蒙层，做分享引导。<br>因为页面内部点击分享按钮无法直接调用，而分享功能需要点击右上角更多来操作。<br>然后用户可能不知道通过右上角小标里面的功能分享。又想引导用户分享，这时应该怎么做呢？<br>技术无法实现的，从产品出发。</p>
]]></content>
  </entry>
  <entry>
    <title>React 16 新特性</title>
    <url>/2019/12/17/React-16-%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h3 id="useEffect-useState-useCallback-Suspense"><a href="#useEffect-useState-useCallback-Suspense" class="headerlink" title="useEffect, useState, useCallback,Suspense"></a>useEffect, useState, useCallback,Suspense</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useCallback, Suspense &#125; <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">"./styles.css"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> EmployeesList <span class="keyword">from</span> <span class="string">"./EmployeesList"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> debounce <span class="keyword">from</span> <span class="string">"debounce"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; employeesResource &#125; <span class="keyword">from</span> <span class="string">"./fake-resource"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialResource = employeesResource(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">EmployeesPage</span>(<span class="params">&#123; resource &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Suspense fallback=&#123;&lt;div&gt;Fetching employees....&lt;<span class="regexp">/div&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">      &lt;EmployeesFetch resource=&#123;resource&#125; /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/Suspense&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function EmployeesFetch(&#123; resource &#125;) &#123;</span></span><br><span class="line"><span class="regexp">  const employees = resource.employees.read();</span></span><br><span class="line"><span class="regexp">  return &lt;EmployeesList employees=&#123;employees&#125; /</span>&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [resource, setResource] = useState(initialResource);</span><br><span class="line">  <span class="keyword">const</span> setResourceByQuery = useCallback(</span><br><span class="line">    debounce(<span class="function"><span class="params">query</span> =&gt;</span> setResource(employeesResource(query)), <span class="number">500</span>),</span><br><span class="line">    []</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;h2&gt;Employees list&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">      &lt;label&gt;Filter:&lt;/</span>label&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        type=<span class="string">"text"</span></span><br><span class="line">        onChange=&#123;event =&gt; setResourceByQuery(event.target.value)&#125;</span><br><span class="line">        placeholder=<span class="string">"Type query..."</span></span><br><span class="line">      /&gt;</span><br><span class="line">      &lt;EmployeesPage resource=&#123;resource&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const rootElement = document.getElementById("root");</span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;App /</span>&gt;, rootElement);</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<p>useEffect的执行时机都是每次渲染后触发，无论是首次渲染还是更新渲染。<br>useEffect只会有当然组件是函数组件才会执行，不能再非函数组件中使用。<br>useEffect可以在同一函数组件中使用多次，按调用顺序执行，这样我们可以将生命周期中需要做的事情更小粒度的去编写代码。<br>在useEffect传入的函数中，return一个函数，用作函数组件卸载时需要执行的操作。<br>控制useEffect什么时候执行可以传入第二参数，而且第二个参数必须是数组！react会对这次传入的数组中的每一项和上一次数组中的每一项进行对比，当发现不一样时会做对应记录，在渲染后就会触发对应符合触发的useEffect函数。<br>useEffect的触发是采用异步方式执行的。因为有可能存在多个useEffect的函数，如果像class组件那样在commit阶段最后触发的话，很容易导致阻塞线程。所以React利用setTimeout的方式，将useEffect异步执行。</p>
]]></content>
  </entry>
  <entry>
    <title>JavaScript 原生dom操作</title>
    <url>/2019/12/11/JavaScript-%E5%8E%9F%E7%94%9Fdom%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h3 id="document-querySelector-document-querySelectorAll"><a href="#document-querySelector-document-querySelectorAll" class="headerlink" title="document.querySelector / document.querySelectorAll"></a>document.querySelector / document.querySelectorAll</h3><p>document.querySelector方法返回文档中与指定选择器或选择器组匹配的第一个 html 元素。 如果找不到匹配项，则返回null。<br>document.querySelectorAll 方法返回与指定的选择器组匹配的文档中的元素列表 (使用深度优先的先序遍历文档的节点)。返回的对象是 NodeList 。<br>// 返回第一个 ul 元素<br>const list = document.querySelector(‘ul’)<br>// 返回所有类名为 info 或者 warning 的 div 元素<br>const elements = document.querySelectorAll(‘div.info, div.warning’);</p>
<h3 id="Node-removeChild"><a href="#Node-removeChild" class="headerlink" title="Node.removeChild"></a>Node.removeChild</h3><p>Node.removeChild方法从DOM中删除一个子节点并返回删除的节点。 请注意，返回的节点不再是DOM的一部分，而是仍存在于内存中。 如果处理不当，可能会导致内存泄漏。<br>let list = document.querySelector(‘ul’);<br>let firstItem = list.querySelector(‘li’);<br>let removedItem = list.removeChild(firstItem);</p>
<h3 id="Node-replaceChild"><a href="#Node-replaceChild" class="headerlink" title="Node.replaceChild"></a>Node.replaceChild</h3><p>此方法替换父节点中的子节点(并返回替换后的旧子节点)。请注意，如果处理不当，此方法可能导致与Node.removeChild类似的内存泄漏问题。<br>let list = document.querySelector(‘ul’);<br>let oldItem = list.querySelector(‘li’);<br>let newItem = document.createElement(‘li’);<br>newItem.innerHTML = ‘前端小智’;<br>let replacedItem = list.replaceChild(newItem, oldItem);<br>复</p>
<h3 id="Element-insertAdjacentHTML"><a href="#Element-insertAdjacentHTML" class="headerlink" title="Element.insertAdjacentHTML"></a>Element.insertAdjacentHTML</h3><p>element.insertAdjacentHTML(position, text) 将指定的文本解析为HTML或XML，并将结果节点插入到DOM树中的指定位置。它不会重新解析它正在使用的元素，因此它不会破坏元素内的现有元素。这避免了额外的序列化步骤，使其比直接innerHTML操作更快。<br>position是相对于元素的位置，并且必须是以下字符串之一：<br>beforebegin：元素自身的前面。<br>afterbegin：插入元素内部的第一个子节点之前。<br>beforeend：插入元素内部的最后一个子节点之后。<br>afterend：元素自身的后面。<br>text是要被解析为HTML或XML,并插入到DOM树中的字符串。<br><!-- beforebegin --></p>
<p><div><br>  <!-- afterbegin --><br>  <p>Hello World</p><br>  <!-- beforeend --><br></div><br><!-- afterend --><br>复制代码<br>示例：<br>var list = document.querySelector(‘ul’);<br>list.insertAdjacentHTML(‘afterbegin’, ‘<li id="first-item">First</li>‘);</p>
<h3 id="Element-hasAttribute-Element-removeAttribute"><a href="#Element-hasAttribute-Element-removeAttribute" class="headerlink" title="Element.hasAttribute / Element.removeAttribute"></a>Element.hasAttribute / Element.removeAttribute</h3><p>Element.hasAttribute方法检查给定元素是否具有指定的属性，返回值为boolean。 通过调用Element.removeAttribute方法，我们可以从元素中删除具有给定名称的属性。<br>let list = document.querySelector(‘ul’);<br>if (list.hasAttribute(‘id’)) {<br>    console.log(‘list has an id’);<br>    list.removeAttribute(‘id’);<br>};</p>
<h3 id="Element-getAttribute-Element-setAttribute"><a href="#Element-getAttribute-Element-setAttribute" class="headerlink" title="Element.getAttribute / Element.setAttribute"></a>Element.getAttribute / Element.setAttribute</h3><p>Element.getAttribute方法返回元素上给定属性的值，反之亦然，Element.setAttribute设置给定元素上属性的值。<br>let list = document.querySelector(‘ul’);<br>list.setAttribute(‘id’, ‘my-list’);<br>let id = list.getAttribute(‘id’);<br>console.log(id); // outputs my-list</p>
]]></content>
  </entry>
  <entry>
    <title>vue生命周期</title>
    <url>/2019/12/02/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<p><img src="/images/pasted-8.png" alt="upload successful"></p>
<p><img src="/images/pasted-9.png" alt="upload successful"></p>
<p>beforeCreate:在实例初始化之后，数据观测data observer(props、data、computed) 和 event/watcher 事件配置之前被调用。</p>
<p>created:实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。</p>
<p>beforeMount:在挂载开始之前被调用：相关的 render 函数首次被调用。</p>
<p>mounted: el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。</p>
<p>beforeUpdate:数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。 你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。</p>
<p>updated：无论是组件本身的数据变更，还是从父组件接收到的 props 或者从vuex里面拿到的数据有变更，都会触发虚拟 DOM 重新渲染和打补丁，并在之后调用 updated。</p>
<p>beforeDestroy:实例销毁之前调用。在这一步，实例仍然完全可用。</p>
<p>destroyed:Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用。<br>注意:</p>
<p>created阶段的ajax请求与mounted请求的区别：前者页面视图未出现，如果请求信息过多，页面会长时间处于白屏状态。</p>
<p>单个组件的生命周期</p>
<p>初始化组件时，仅执行了beforeCreate/Created/beforeMount/mounted四个钩子函数<br>当改变data中定义的变量（响应式变量）时，会执行beforeUpdate/updated钩子函数<br>当切换组件（当前组件未缓存）时，会执行beforeDestory/destroyed钩子函数<br>初始化和销毁时的生命钩子函数均只会执行一次，beforeUpdate/updated可多次执行</p>
<h2 id="Vue-nextTick-："><a href="#Vue-nextTick-：" class="headerlink" title="Vue.nextTick()："></a>Vue.nextTick()：</h2><p>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。</p>
<p>获取更新后的DOM言外之意就是什么操作需要用到了更新后的DOM而不能使用之前的DOM或者使用更新前的DOM会出问题，所以就衍生出了这个获取更新后的 DOM的Vue方法。所以放在Vue.nextTick()回调函数中的执行的应该是会对DOM进行操作的 js代码，比如Swiper扩展包的:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var swiper = new Swiper(&apos;.swiper-container&apos;, &#123;</span><br><span class="line">                    pagination: &apos;.swiper-pagination&apos;,</span><br><span class="line">                    nextButton: &apos;.swiper-button-next&apos;,</span><br><span class="line">                    prevButton: &apos;.swiper-button-prev&apos;,</span><br><span class="line">                    paginationClickable: true,</span><br><span class="line">                    spaceBetween: 30,</span><br><span class="line">                    centeredSlides: true,</span><br><span class="line">                    autoplay: 2500,</span><br><span class="line">                    autoplayDisableOnInteraction: false</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="什么时候需要用Vue-nextTick"><a href="#什么时候需要用Vue-nextTick" class="headerlink" title="什么时候需要用Vue.nextTick():"></a>什么时候需要用Vue.nextTick():</h2><p>你在Vue生命周期的created()钩子函数进行的DOM操作一定要放在Vue.nextTick()的回调函数中。原因是什么呢，原因是在created()钩子函数执行的时候DOM 其实并未进行任何渲染，而此时进行DOM操作无异于徒劳，所以此处一定要将DOM操作的js代码放进Vue.nextTick()的回调函数中。与之对应的就是mounted钩子函数，因为该钩子函数执行时所有的DOM挂载和渲染都已完成，此时在该钩子函数中进行任何DOM操作都不会有问题 。<br>在数据变化后要执行的某个操作，当你设置 vm.someData = ‘new value’，DOM并不会马上更新，而是在异步队列被清除，也就是下一个事件循环开始时执行更新时才会进行必要的DOM更新。如果此时你想要根据更新的 DOM 状态去做某些事情，就会出现问题。。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 Vue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用。<br>mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 vm.$nextTick 替换掉 mounted：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mounted: function () &#123;</span><br><span class="line">this.$nextTick(function () &#123;</span><br><span class="line"></span><br><span class="line">// Code that will run only after the</span><br><span class="line">// entire view has been rendered</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
  </entry>
  <entry>
    <title>浅谈vue和react的数据流和绑定</title>
    <url>/2019/11/27/%E6%B5%85%E8%B0%88vue%E5%92%8Creact%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B5%81%E5%92%8C%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<p>数据流：<br>Vue和React均是单向数据流传递</p>
<p>单向数据流指只能从一个方向修改数据，姑且我们可以这样理解，如下图所示。一个父组件下有两个子组件1和子组件2，父组件可以向子组件传递数据。假如子组件都获取到了父组件的name，在子组件1中对name重新修改之后，子组件2和父组件中的值并不会发生改变，这正是因为Vue中的机制是单向数据流，子组件不能直接改变父组件的状态。但反过来，如果是父组件中的name修改了，当然两个子组件中的name也就改变了。</p>
<p>数据的绑定 :<br>Vue是双向绑定和React是单向绑定</p>
<p>它们俩主要是由MVVM框架实现，在Vue中主要由三个部分组成，View、ViewModel和Model组成，其中View和Model不能直接进行通信，他们要通过中间件ViewModel来进行。例如，当Model部分数据发生改变时，由于vue中Data Binding将底层数据和Dom层进行了绑定，ViewModel通知View层更新视图；当在视图 View数据发生变化也会同步到Model中。View和Model之间的同步完全是自动的，不需要人手动的操作DOM,所以叫双向绑定。</p>
<p>而在React中虽然modal和view之间也是通过ViewMode处理,但是l却需要setState去手动刷新渲染view，所以叫单向绑定</p>
]]></content>
  </entry>
  <entry>
    <title>koa800</title>
    <url>/2019/11/27/koa800/</url>
    <content><![CDATA[<blockquote>
<p>基于koa框架, 可扩展、可配置的中间件集合, 以及快速定制项目结构的脚手架工具</p>
</blockquote>
<p><a href="http://git.tuan800-inc.com/ruby_cd/cd-ruby-common_package_source/blob/master/node/koa800/CHANGELOG.md" target="_blank" rel="noopener">CHANGELOG</a></p>
<h2 id="1-要解决的问题"><a href="#1-要解决的问题" class="headerlink" title="1. 要解决的问题"></a>1. 要解决的问题</h2><ol>
<li><p>脚手架文件太多:</p>
<ul>
<li>干扰业务代码</li>
<li>无法方便的进行更新和升级</li>
<li>随着时间推移, 项目结构和脚手架文件在不同项目中逐渐变得不统一</li>
</ul>
</li>
<li><p>中间件的管理:</p>
<ul>
<li>相同的中间件需要在不同项目中去引用和配置, 重复的工作量, 重复的代码(违反DRY)</li>
<li>不便于统一的更新和升级</li>
</ul>
</li>
</ol>
<hr>
<h2 id="2-背景"><a href="#2-背景" class="headerlink" title="2. 背景"></a>2. 背景</h2><p>微服务是当前比较流行的系统架构模式, 各个应用的专注于提供特定的服务. 在框架选择上, 轻量级、 支持中间件选配的koa框架是一个不错的选择.</p>
<p>koa 的使用非常灵活便捷, 它没有提供模板文件, 也没有要求项目结构标准, 这让开发者有很大的自由度; 不过对于同一个团队下的多个koa应用来说, 这会是一个问题: 多个项目在脚手架结构上的不统一, 将会对跨项目维护、中间件升级等造成麻烦.</p>
<p>解决以上问题, 有的团队会采用代码规范/项目结构规范来作为约束, 对于生命周期较长的多应用系统, 规范不一定有很好的效果, 规范毕竟是靠人来执行.</p>
<p>koa800提供另外一种方案: 将各项目的结构标准、共用的中间件依赖等, 提取到npm包中, 对于那些部分项目使用的中间件, 也将其提取到npm包中, 使用者可以对这部分特性进行简单的声明选择. 这样一来, 项目结构和中间件都在koa800中进行控制和装配, 实现了强制的项目标准.</p>
<p>同时, koa800还提供了项目脚手架的创建和更新功能.</p>
<hr>
<h2 id="3-Koa800-介绍"><a href="#3-Koa800-介绍" class="headerlink" title="3. Koa800 介绍"></a>3. Koa800 介绍</h2><p>koa800提供了2个功能:</p>
<ol>
<li>Scaffold Generator: 创建、更新项目脚手架, 可配置需要特性. 发生在执行setup脚本时.</li>
<li>Runtime Koa Wrapper: 统一管理项目中间件, 可配置需要特性. 发生在项目运行时.</li>
</ol>
<p>Scaffold Generator和Koa Wrapper都是通过<a href="TODO">Feature</a>进行管理.</p>
<hr>
<h3 id="3-1-Scaffold-Generator"><a href="#3-1-Scaffold-Generator" class="headerlink" title="3.1 Scaffold Generator"></a>3.1 Scaffold Generator</h3><p>让我们用koa800来初始化一个新项目:</p>
<blockquote>
<p>% mkdir koa800_demo<br>% cd koa800_demo</p>
</blockquote>
<p>然后用<code>npm init</code>创建项目package.json</p>
<p>现在你需要做的是将<code>koa800</code>加入项目依赖:</p>
<blockquote>
<p>% npm install koa800 –save</p>
</blockquote>
<p>现在该项目的package.json大概是这个样子的:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"koa800_demo"</span>,</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="string">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="string">"koa800"</span>: <span class="string">"^1.0.0"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行koa800提供的setup脚本更新项目脚手架:</p>
<blockquote>
<p>% ./node_modules/.bin/setup</p>
</blockquote>
<p>执行完毕后, 将创建类似如下的项目结构:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── app/</span><br><span class="line">│   └── controllers/</span><br><span class="line">├── app.js</span><br><span class="line">├── bin/</span><br><span class="line">│   └── www</span><br><span class="line">├── config/</span><br><span class="line">│   ├── environments/</span><br><span class="line">│   │   ├── development.js</span><br><span class="line">│   │   └── production.js</span><br><span class="line">│   ├── errors.js</span><br><span class="line">│   ├── routes/</span><br><span class="line">│   │   └── index.js</span><br><span class="line">│   └── settings.js</span><br><span class="line">└── package.json</span><br></pre></td></tr></table></figure>
<p>此时查看<code>package.json</code>, 内容也有更新, 内容大概如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"koa800_demo"</span>,</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="string">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="string">"koa800"</span>: <span class="string">"^1.0.0"</span>,</span><br><span class="line">    <span class="string">"zhe800_cd_node_imago"</span>: <span class="string">"^1.0.0"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"start"</span>: <span class="string">"node ./bin/www"</span>,</span><br><span class="line">    <span class="string">"c"</span>: <span class="string">"node ./node_modules/.bin/c"</span>,</span><br><span class="line">    <span class="string">"setup"</span>: <span class="string">"node ./node_modules/.bin/setup"</span>,</span><br><span class="line">    <span class="string">"imago"</span>: <span class="string">"node -e \"require('zhe800_cd_node_imago')\""</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"koa800Config"</span>: &#123;</span><br><span class="line">    <span class="string">"eslint"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">"jsonp"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">"tingyun"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">"memcached"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">"redis"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">"prepare_commit_msg"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">"auto_routes"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">"loom"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">"docker"</span>: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中, koa800Config是用于声明可选feature的属性, 默认情况下, 这里列出了所有可选的features, 但设为了false, 表示不启用, 用户可以根据项目实际需要对某些feature进行开启.</p>
<p>在每次修改了koa800Config中的feature设置后, 需要再次执行如上的setup脚本, setup脚本会根据koa800Config中的配置去调整当前项目的脚手架和中间件.</p>
<hr>
<h3 id="3-2-Runtime-Koa-Wrapper"><a href="#3-2-Runtime-Koa-Wrapper" class="headerlink" title="3.2 Runtime Koa Wrapper"></a>3.2 Runtime Koa Wrapper</h3><p>在上一小节中, 通过setup生成的项目入口文件是app.js, 该文件内容如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">let</span> app = <span class="built_in">require</span>(<span class="string">'koa800'</span>)();</span><br><span class="line"><span class="built_in">module</span>.exports = app;</span><br></pre></td></tr></table></figure>
<p>可以看到, 项目本身没有直接依赖和使用<code>koa</code>, 而是使用的<code>koa800</code>, <code>koa800</code>作为一个包裹器, 引用了<code>koa</code>, 同时引入并正确配置了其他一些依赖的中间件. 同脚手架生成器一样, 用户也可以在package.json的koa800Config属性中去配置需要的依赖feature.</p>
<hr>
<h2 id="4-约定"><a href="#4-约定" class="headerlink" title="4. 约定"></a>4. 约定</h2><p>koa800 的主要目的是减少项目之间的重复的项目结构代码, 保证项目的规范和统一, 并能在今后方便的进行整体调整. koa800想要避免的重复代码包括:</p>
<ul>
<li>项目组织和加载的代码</li>
<li>对相同中间件的引用和配置的代码</li>
<li>CI类, 工具类, 编译打包部署等代码</li>
</ul>
<p>koa800创建的脚手架有如下约定:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── app/</span><br><span class="line">│   └── controllers/       控制器代码</span><br><span class="line">├── app.js                 app的入口文件</span><br><span class="line">├── bin/</span><br><span class="line">│   └── www                项目启动文件</span><br><span class="line">├── config/                项目配置文件目录</span><br><span class="line">│   ├── environments/          具体环境的个性配置文件目录</span><br><span class="line">│   │   ├── development.js</span><br><span class="line">│   │   └── production.js</span><br><span class="line">│   ├── errors.js</span><br><span class="line">│   ├── routes/            路由目录</span><br><span class="line">│   │   ├── index.js       任意域名路由</span><br><span class="line">│   │   └── search.js      子域名路由, 子域名和文件名一致</span><br><span class="line">│   └── settings.js        基础配置文件, 低优先级</span><br><span class="line">│   └── settings.local.js  全局特殊配置文件, 高优先级</span><br><span class="line">└── package.json</span><br></pre></td></tr></table></figure></p>
<p>这些约定是由各feature的setup流程进行控制的.</p>
<hr>
<h2 id="5-Feature"><a href="#5-Feature" class="headerlink" title="5. Feature"></a>5. Feature</h2><p>Feature 是脚手架构建和中间件装配的基本单元, Feature分为Required和Optional2个类别, 目前的Feature如下:</p>
<table>
<thead>
<tr>
<th>Required Features</th>
<th>描述</th>
<th>Scaffold Generator</th>
<th>Runtime</th>
</tr>
</thead>
<tbody>
<tr>
<td>base</td>
<td>基础特性</td>
<td>生成项目基础脚手架, 引入基础依赖</td>
<td>引入并配置项目基本的中间件</td>
</tr>
<tr>
<td>tingyun</td>
<td>引入tingyun APM监控</td>
<td>生成tingyun.json.exampl模板文件, 引入依赖</td>
<td>封装app.monitor.noticeError</td>
</tr>
<tr>
<td>controllers</td>
<td>控制器</td>
<td>生成控制器目录app/controllers/</td>
<td>加载控制器, 挂载到app.controllers</td>
</tr>
<tr>
<td>errors</td>
<td>错误列表</td>
<td>生成错误列表模块config/errors.js</td>
<td>加载错误列表, 挂载到app.errors</td>
</tr>
<tr>
<td>imago</td>
<td>接入统一配置中心</td>
<td>引入imago依赖,生成config/imago_conf.js</td>
<td>将imago配置挂载到app.settings.imago_conf</td>
</tr>
<tr>
<td>settings</td>
<td>项目配置管理</td>
<td>生成多级配置管理文件</td>
<td>按照优先级解析settings, 挂载到app.settings</td>
</tr>
<tr>
<td>start_hooks</td>
<td>应用启动的前置注册管理</td>
<td>不涉及</td>
<td>处理app.start的前置操作</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Optional Features</th>
<th>描述</th>
<th>Scaffold Generator</th>
<th>Runtime</th>
</tr>
</thead>
<tbody>
<tr>
<td>auto_routes</td>
<td>自动路由配置</td>
<td>引入路由和子域名的依赖</td>
<td>加载config/routes/中的路由, 并自动匹配子域名</td>
</tr>
<tr>
<td>data_service</td>
<td>接入data service</td>
<td>引入data service依赖和配置</td>
<td>配置data service</td>
</tr>
<tr>
<td>docker</td>
<td>提供dockerfile</td>
<td>将dockerfile写入images目录</td>
<td>不涉及</td>
</tr>
<tr>
<td>eslint</td>
<td>引入eslint</td>
<td>将.git/hook/pre-commit链接到指定脚本</td>
<td>不涉及</td>
</tr>
<tr>
<td>jsonp</td>
<td>引入jsonp支持</td>
<td>引入jsonp依赖, 并提供check referer</td>
<td>加载jsonp中间件</td>
</tr>
<tr>
<td>loom</td>
<td>接入服务治理平台</td>
<td>引入config/thrift_conf.js</td>
<td>在app.start前执行app.loom.init</td>
</tr>
<tr>
<td>memcached</td>
<td>引入memcached</td>
<td>引入memcached依赖</td>
<td>将memcached链接挂载到app.settings.memcached</td>
</tr>
<tr>
<td>prepare_commit_msg</td>
<td>在git commit消息中自动集成分支信息</td>
<td>将.git/hooks/prepare-commit-ms链接到指定脚本</td>
<td>不涉及</td>
</tr>
<tr>
<td>redis</td>
<td>引入redis</td>
<td>引入redis依赖</td>
<td>将redis链接挂载到app.redis</td>
</tr>
</tbody>
</table>
<p>以下是部分feature说明:</p>
<hr>
<h3 id="base"><a href="#base" class="headerlink" title="base"></a>base</h3><p>feature base 按照约定创建了项目基本的结构, 同时提供了一些基础的API和脚本:</p>
<p><strong>API</strong></p>
<ul>
<li><p><code>app.requireModule(relativePathFromRoot)</code>: 参数是相对于app.root的相对路径, 这个API让用户不用考虑当前脚本的位置和目标模块的层级关系, 非常方便.</p>
</li>
<li><p><code>app.isDevelopment() -&gt; bool</code> <code>app.isProduction() -&gt; bool</code> 用于判断当前执行环境的语法糖.</p>
</li>
<li><p><code>app.netFT</code>: 网络请求降级API, 见<a href="http://wiki.tuan800-inc.com/display/NOD/netFT" target="_blank" rel="noopener">http://wiki.tuan800-inc.com/display/NOD/netFT</a></p>
</li>
</ul>
<p><strong>脚本</strong></p>
<ul>
<li><code>npm run setup</code>: 按照当前配置的koa800Config更新项目脚手架</li>
<li><code>npm run c</code>: 提供了koa800 console功能, 方便调试</li>
</ul>
<p><img src="/assets/images/koa800/console.gif" alt="console"></p>
<p>除此之外, base feature还配置了日志, 设置了favicon.ico, 处理了Post 参数等问题.</p>
<hr>
<h3 id="eslint"><a href="#eslint" class="headerlink" title="eslint"></a>eslint</h3><p>在node.js 项目中, 我们引入eslint作为代码质量控制工具. 并在git commit 时, 利用 pre-commit hook 对修改的文件自动执行eslint, 强制保证了入库代码的质量.</p>
<p>在 pre-commit 执行eslint检测到代码错误时, 可以配置要求阻止当前commit(默认), 也可以配置仅作为警告输出, commit仍然成功.</p>
<p><img src="/assets/images/koa800/eslint.gif" alt="eslint"></p>
<p>eslint 支持的配置项:</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>false</td>
<td>关闭 auto eslint</td>
</tr>
<tr>
<td>true/error</td>
<td>开启 auto eslint, 如eslint失败, 将阻止 git commit</td>
</tr>
<tr>
<td>warning</td>
<td>开启 auto eslint, 如eslint失败, 仅输出错误消息, 允许 git commit</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="prepare-commit-msg"><a href="#prepare-commit-msg" class="headerlink" title="prepare_commit_msg"></a>prepare_commit_msg</h3><p>对多个开发共同维护的git仓库, 分析某个commit的作者、来源分支或者来源工单, 是一个常见的场景, 不过git commit 中只能查到作者信息, 不能很方便的追踪到来源分支. 在某些团队中是要求在commit message中手动加上当前分支名, 以满足未来分析需要, 这个工作其实可以通过git prepare-commit-msg 来自动实现.</p>
<p>当在koa800中开启prepare_commit_msg选项后, 每次用户commit代码, 会自动把当前分支名信息记录到commit message中.</p>
<p><img src="/assets/images/koa800/prepare_commit_msg.gif" alt="prepare_commit_msg"></p>
<p>prepare_commit_msg 支持的配置项:</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>false</td>
<td>关闭 prepare_commit_msg</td>
</tr>
<tr>
<td>true</td>
<td>开启 prepare_commit_msg</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="settings"><a href="#settings" class="headerlink" title="settings"></a>settings</h3><p>配置管理是项目工程结构中重要一环, koa800 的 settings feature 为项目提供了多级的配置管理:</p>
<ol>
<li><p>第一优先级:</p>
<p> <code>config/settings.local.js</code></p>
<p> 该文件不应该在git版本库, 用于开发测试或者部署环境的特殊配置, 优先级最高.</p>
</li>
<li><p>第二优先级:</p>
<p> <code>config/environments/development.js</code> 或 <code>config/environments/production.js</code></p>
<p> koa800会根据env的值去加载<code>config/environments/</code>中的同名js配置文件, 该目录中的配置用于不同运行环境的差异化配置.</p>
<p> 环境配置文件应该放入版本库.</p>
</li>
<li><p>最低优先级:</p>
<p> <code>config/settings.js</code></p>
<p> 该文件包含项目基础配置, 优先级最低, 应该放入git版本库.</p>
</li>
</ol>
<p>settings属于Required feature, 无需在koa800Conifg中配置.</p>
<hr>
<h3 id="start-hooks"><a href="#start-hooks" class="headerlink" title="start_hooks"></a>start_hooks</h3><p>某些应用在启动web 服务前, 需要处理一些前置操作, 如服务注册, 配置同步, 获取静态资源hash值等. 如果任由这些需求在各个微服务中处理, 会有大量的重复代码. 该feature 提供的API <code>app.beforeStart</code> 允许用户在app.start前注册前置操作:</p>
<p><code>app.beforeStart(action)</code>参数action 可以是以下值:</p>
<ul>
<li><p>一个 Promise 实例, koa800会保证此promise resolve后, 才启动web 服务</p>
</li>
<li><p>一个 function, 且该function的返回值是一个Promise实例, koa800会在启动web服务前执行该function, 并且会保证此promise resolve后, 才启动web 服务.</p>
</li>
<li><p>一个 function, 返回值并不是Promise实例, koa800会在启动web服务前执行该function.</p>
</li>
</ul>
<p><code>app.beforeStart</code> 允许级联调用, 如:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.beforeStart(syncConfiguration).beforeStart(serviceDiscovery).beforeStart(serviceRegistration)</span><br></pre></td></tr></table></figure>
<p>start_hooks属于Required feature, 无需在koa800Conifg中配置.</p>
<hr>
<h3 id="auto-routes"><a href="#auto-routes" class="headerlink" title="auto_routes"></a>auto_routes</h3><p>web应用的http 路由通常由两部分组成: 子域名匹配和path匹配, <a href="https://www.npmjs.com/package/koa-sub-domain" target="_blank" rel="noopener">koa-sub-domain</a>和<a href="https://www.npmjs.com/package/koa-router" target="_blank" rel="noopener">koa-router</a> 可以实现以上功能.</p>
<p>如果不使用koa800, 用户需要自行配置子域名路由, 如:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.use(app.requireModule(<span class="string">'config/routes'</span>).routes());                          <span class="comment">// 泛域名路由</span></span><br><span class="line">app.use(subdomain(<span class="string">'last'</span>, app.requireModule(<span class="string">'config/routes/last'</span>).routes()));  <span class="comment">// last 子域名路由</span></span><br><span class="line">app.use(subdomain(<span class="string">'new'</span>, app.requireModule(<span class="string">'config/routes/new'</span>).routes()));    <span class="comment">// new 子域名路由</span></span><br><span class="line">app.use(subdomain(<span class="string">'top'</span>, app.requireModule(<span class="string">'config/routes/top'</span>).routes()));    <span class="comment">// top 子域名路由</span></span><br></pre></td></tr></table></figure>
<p>koa800提倡约定大于配置, 只要代码按照约定组织, koa800 会完整这些重复而固定的工作, 减少用户需要编写的代码行.</p>
<p>在koa800, 只要将路由文件按照约定放入<code>config/routes</code>中, koa800 会自动加载路由, 并按照文件名识别子域名:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">config</span><br><span class="line">└── routes</span><br><span class="line">    ├── index.js  泛域名路由</span><br><span class="line">    ├── last.js   last 子域名路由</span><br><span class="line">    ├── new.js    new 子域名路由</span><br><span class="line">    └── top.js    top 子域名路由</span><br></pre></td></tr></table></figure>
<p>auto_routes 支持的配置项:</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>false</td>
<td>关闭 auto_routes</td>
</tr>
<tr>
<td>true</td>
<td>开启 auto_routes</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h3><p><a href="https://www.npmjs.com/package/koa-safe-jsonp" target="_blank" rel="noopener">koa-safe-jsonp</a> 提供了koa jsonp支持, koa800将其做了简单的封装.</p>
<p>jsonp存在较高的<a href="http://www.csdn.net/article/2015-07-14/2825207" target="_blank" rel="noopener">安全风险</a>, referer 检查是jsnop风险防范的常见手段, koa800的jsonp feature 提供了referer 检测的验证action, 该filter位于<code>app/controllers/filters/check_referer.js</code></p>
<p>使用方式:</p>
<p>在路由中加上前置filter: <code>filters.checkReferer</code>:</p>
<blockquote>
<p>router.get(‘/user_info’, app.controllers.filters.checkReferer, app.controllers.user.info);</p>
</blockquote>
<p>可以在<code>app/controllers/filters/check_referer.js</code>中配置特定的refererMatcher.</p>
<p>jsonp 支持的配置项:</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>false</td>
<td>关闭 jsonp</td>
</tr>
<tr>
<td>true</td>
<td>开启 jsonp</td>
</tr>
<tr>
<td>配置对象</td>
<td>开启 jsonp, 并将配置对象传递给koa-safe-jsonp</td>
</tr>
</tbody>
</table>
<p>配置对象中可以配置<code>callback</code>和<code>limit</code>, 详见<a href="https://www.npmjs.com/package/koa-safe-jsonp" target="_blank" rel="noopener">koa-safe-jsonp</a></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">jsonp(app, &#123;</span><br><span class="line">  callback: <span class="string">'_callback'</span>, <span class="comment">// default is 'callback'</span></span><br><span class="line">  limit: <span class="number">50</span>, <span class="comment">// max callback name string length, default is 512</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="6-开发者指南"><a href="#6-开发者指南" class="headerlink" title="6. 开发者指南"></a>6. 开发者指南</h2><p>koa800提供的所有特性单元是Feature, 开发者可以通过编写Feature按需扩展koa800的功能.</p>
<p>在koa800中Feature类定义如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Feature</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(properties) &#123;</span><br><span class="line">    <span class="keyword">this</span>.run          = properties.run;</span><br><span class="line">    <span class="keyword">this</span>.setup        = properties.setup;</span><br><span class="line">    <span class="keyword">this</span>.packageJson  = properties.packageJson;</span><br><span class="line">    <span class="keyword">this</span>.scaffold     = properties.scaffold;</span><br><span class="line">    <span class="keyword">this</span>.dependencies = properties.dependencies;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>属性说明:</p>
<ul>
<li>run: 该feature在运行时对app的增强操作</li>
<li>setup: 该feature在脚手架更新过程中的操作, 该属性期望是一个生成器函数</li>
<li>packageJson: 该feature在脚手架更新过程中, 对项目package.json的补充, 比如引入scripts, dependencies等</li>
<li>scaffold: 该feature在脚手架更新过程需要同步的文件列表</li>
<li>dependencies: 该feature依赖的其他feature</li>
</ul>
<p>Scaffold Generator 各feature的处理流程:</p>
<ol>
<li>处理dependencies features</li>
<li>更新scaffold文件列表</li>
<li>更新packageJson内容</li>
<li>执行setup</li>
</ol>
<p>运行时, 各feature的执行流程:</p>
<ol>
<li>依次执行feature.run</li>
</ol>
<h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>目前koa800测试覆盖率&gt;80%, 开发者在新增、更新feature时, 务必补充单元测试.</p>
]]></content>
  </entry>
  <entry>
    <title>chrome插件开发教程</title>
    <url>/2019/11/18/chrome%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p>相关链接</p>
<p>代码仓库： <a href="mailto:git@git.tuan800-inc.com" target="_blank" rel="noopener">git@git.tuan800-inc.com</a>:ued/cd_ued_chrome_extensions.git ，相关开发流程和使用说明在项目的README中均有描述<br>参考</p>
<p>Chrome扩展及应用开发（首发版），这本书非常实用，配合书中的项目，可以快速上手Chrome扩展开发<br>Chrome扩展程序官方文档，查API就靠它了，<br>非官方中文文档，可以先快速过一遍api<br>这里主要整理了chrome开发技术、cd_ued_chrome_extensions项目的开发环境和打包流程以及Chrome应用商店的使用步骤。</p>
<p>Chrome开发相关技术<br>扩展程序由HTML、CSS和JavaScript等web技术组成，并由浏览器提供了一系列增强API。</p>
<p>在项目文件夹根目录新建一个manifest.json的文件，用于声明相关配置。配置文件主要用来指定文件路径、，配置权限等。</p>
<p>{<br>    // 区分扩展程序和应用，在扩展程序中只能为2<br>    “manifest_version”: 2,<br>    “name”: “扩展程序测试”,<br>    “version”: “1.0”,<br>    “description”: “Chrome扩展”,<br>    // 在chrome://extensions/扩展程序列表下的图标<br>    “icons”: {},<br>    // 当进入指定URL页面时调用对应脚本<br>    “content_scripts”: [],<br>    // 在浏览器右上角的扩展程序的属性<br>    “browser_action”: {},<br>    // 一些权限设置<br>    “permissions”: [],<br>    // 一直在后台运行的脚本<br>    “background”: {},<br>    // 选项页面<br>    “options_page”: “options.html”<br>}<br>整个扩展程序可分为下面几个部分</p>
<p>content_scripts，进入指定URL页面可注入的脚本<br>background，在后台运行<br>browser_action，右上角弹窗<br>options_page，扩展程序选项页面<br>content_scripts<br>扩展程序一个非常重要的功能就是可以操作用户正在浏览的页面。在配置文件中通过指定对应的match字段，匹配页面url，并在浏览器访问这些页面时，注入对应的脚本文件。</p>
<p>“content_scripts”: [<br>  {<br>    “matches”: [<br>      “<em>://local.com/</em>“, // 其中 <em> 表示通配符<br>      “</em>://<a href="http://www.amazon.com/*&quot;" target="_blank" rel="noopener">www.amazon.com/*&quot;</a><br>    ],<br>    “js”: [<br>      “js/content.js”<br>    ]<br>  }<br>]<br>content_scripts里面的脚本运行在于网页文档相同的环境下，包括访问和操作页面的DOM和BOM。</p>
<p>browser_action<br>有时候需要扩展程序快速展示一些信息功能，右上角的弹窗页面就很有用，弹窗页可以看做是扩展程序与用户的交互窗口。</p>
<p>“browser_action”: {<br>  “default_icon”: {<br>    “19”: “images/icon19.png”,<br>    “38”: “images/icon38.png”<br>  },<br>  “default_popup”: “popup.html” // 可以在页面上通过script标签引入对应的页面js文件<br>},<br>options_page<br>如果配置了options_page选项，并制定了对应的页面，则右击右上角图标是，会出现“选项”栏，点击可跳转到对应的选项页面。选项页面一般用于为用户进行一些插件配置操作，诸如偏好设置等。</p>
<p>options_page可以看做是我们为扩展程序提供的一个主页。</p>
<p>background<br>上面部分是基于前端进行开发的，包括DOM、html、CSS等，可以发现，他们都需要用户的主动操作，要么访问对应的页面，要么点击右上角的图标弹出页面，这类页面统称为UI页面。如果希望扩展程序自动运行并常驻后台来实现一些特定的功能，就可以使用background后台页面。</p>
<p>“background”: {<br>    “page”: “background.html”<br>  },<br>background在后台启动时就会开始运行，可以用于进行插件数据的初始化等操作。</p>
<p>页面交互<br>一个扩展程序往往不止一个页面，有时候页面之间需要进行数据传递或事件通知，这时候需要考虑页面交互的问题。</p>
<p>本地存储<br>一种常见的应用场景是选项页面和其他页面之间的配置选项交互，由于同一个扩展程序的页面(除了注入页面的content_scripts)被认为在同一个域下，因此只需要通过localStorage本地存储就可以轻松做到数据的传递。</p>
<p>UI页面与后台页面的交互<br>另外一种应用场景时某个页面需要主动通知其他页面，可以通过chrome.runtime接口进行</p>
<p>// content.js 发送信息<br>chrome.runtime.sendMessage(message);</p>
<p>// background.js 接收消息<br>chrome.runtime.onMessage.addListener(function(message, sender, sendResponse) { // message就是传递的data });</p>
<p>由于sendMessage无法指定特定的listener，因此onMessage的监听器会接收到所有的消息推送，如果需要区分消息，则需要开发者自己实现相关的逻辑。message可以是字符串也可以是对象，因此可以在参数上携带发送者的消息。</p>
<p>let messageStrategy = {<br>  // … 对应的命令逻辑<br>}<br>chrome.runtime.onMessage.addListener((message, sender, sendResponse) =&gt; {<br>    let {command, content} = message<br>    messageStrategy[command] &amp;&amp; messageStrategy<a href="content">command</a><br>});<br>后台页面与标签页交互<br>可以通过向当前的标签页发送消息，从而获取页面内容的信息</p>
<p>sendMessageToCurrentTab(data) {<br>    return new Promise((resolve, reject) =&gt; {<br>        chrome.tabs.query({active: true, currentWindow: true}, function (tabs) {<br>            chrome.tabs.sendMessage(tabs[0].id, data, function (response) {<br>                resolve(response)<br>            });<br>        });<br>    })<br>}<br>一些常见问题<br>脚本只能通过script标签引入，使用行内脚本会提示<br>配置了popup页面之后，会导致监听插件按钮点击事件<code>chrome.browserAction.onClicked.addListener</code>无效，这是因为默认事件被打开popup.html阻止了，可以在页面初始化逻辑中进行处理点击事件相关的逻辑<br>Chrome提供的大部分API是不支持在content_scripts中运行的，在background中执行没有问题<br>注意配置的match，如果需要在全站页面使用，后面的路径记得配置<em>，例如</em>://<a href="http://www.amazon.com/*，否则只有首页可以注入脚本.." target="_blank" rel="noopener">www.amazon.com/*，否则只有首页可以注入脚本..</a>.<br>项目开发打包流程</p>
<h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><p>由于后期需要维护多个扩展程序，因此搭建此开发环境，便于开发和后期维护</p>
<p>由于插件各个脚本存在一定的关联，如storage的key值、公共函数、公共接口等，需要引入模块化开发。</p>
<p>由于开发预览需要及时更新的文件，因此采用<code>gulp + watch</code>的形式搭建开发环境，使用<code>gulp-webpack</code>进行打包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 开启文件改动监听</span><br><span class="line">gulp js:w</span><br><span class="line"></span><br><span class="line"># 打包生产环境的文件</span><br><span class="line">gulp js --env production</span><br></pre></td></tr></table></figure>
<ul>
<li>webpack相关配置位于<code>gulp-webpack</code>的webpack配置项下，用于修改项目名称和相关文件，</li>
<li>插件源文件开发位于<code>插件名/src</code>目录下，最终打包的文件位于<code>插件名/js</code>目录下，插件配置文件位于<code>插件名/manifest.json</code>下</li>
<li>开发时装配的插件直接使用<code>插件名</code>目录这个即可</li>
</ul>
<h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>由于是本地安装chrome插件，因此只需要输出对应的插件资源即可，执行命令<code>npm run build + 对应插件目录名</code>即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm run build piseer</span><br></pre></td></tr></table></figure>
<p>实际上打包过程只是剔除不必要的文件，在dist目录下生成对应的压缩包，方便传递或部署到SVN上。</p>
<p>相关的打包脚本位于<code>scripts/build.js</code>下</p>
<h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><p>由于chrome应用商店提供了扩展程序自动更新的机制，因此部分扩展程序可以通过托管到应用商店，只需要将打包的压缩包在<a href="https://chrome.google.com/webstore/developer/dashboard/" target="_blank" rel="noopener">开发者中心</a>添加上传即可。</p>
<p>发布相关</p>
<ul>
<li>发布应用的chrome账号为<a href="mailto:`steadyzhe@gmail.com" target="_blank" rel="noopener">`steadyzhe@gmail.com</a>`，密码找云龙提供</li>
<li>发布需要上传的压缩包，直接使用<code>npm run build xxx</code>生成的压缩包即可</li>
<li>发布后一般一个小时内会在应用商店更新，在开发者中心可查看发布进度，一般开发者中心的显示已发布后还需要等待一会应用商店才会更新</li>
<li>如果manifest.json中的permissions过多（貌似还有其他一些限制），在更新包时可能会被系统检测导致人工审核，建议只申明必须的扩展程序权限。</li>
</ul>
<p>插件在应用商店的地址</p>
<ul>
<li><a href="https://chrome.google.com/webstore/detail/shoppinghelper/phlggmjehjabmkeljbfimpgjkanlmbgc?utm_source=gmail" target="_blank" rel="noopener">亚马逊插件</a>，权限为非公开<br>自动更新<br>相关工单： </li>
<li><a href="http://redmine.tuan800-inc.com/issues/370684" target="_blank" rel="noopener">亚马逊插件自动更新调研</a></li>
<li><a href="http://redmine.tuan800-inc.com/issues/372979" target="_blank" rel="noopener">湃势插件自动更新调研</a><br>采用开发者方式安装本地插件包，需要每次更新插件后手动重新下载并解压压缩包，因此需要实现自动更新机制。</li>
</ul>
<p>通过应用商店托管扩展程序，有以下特性</p>
<p>扩展程序安全性，这里的安全性指的是允许用户安装的策略，在发布应用时有公开、非公开、指定账户访问三种等级，其中<br>公开是所有用户都可以通过应用商店搜索到该扩展程序<br>非公开则需要知道扩展程序的下载链接，才能够进行安装，无法直接通过搜索应用商店直接安装<br>指定账户访问则需要在开发者中心添加体验用户的chrome账号，才能够安装该插件，采用这种方式则需要收集使用者的chrome账户<br>自动更新，后续只需要增加版本号并重新在开发者中心发布，chrome会自动更新相关插件，一般会在新版本发布后6个小时内进行更新<br>强制更新，chrome自动更新有一定时间的延迟，如果在发布后想要立即体验更新版本，可以使用强制更新<br>打开<code>chrome://extensions/</code>，选择开发者模式，然后点击更新按钮，强制更新全部扩展程序<br>chrome账户重新登录，在登录状态下安装的扩展程序，重新登录后chrome会进行数据同步，此时也会更新到最新的版本<br>修改chrome扩展更新频率，可以通过在启动chrome时通过参数<code>--extensions-update-frequency=45</code>指定更新检测频率<br>采用非公开方式发布扩展程序，用户只需要第一次点击链接进行扩展程序的安装即可，后续更新都会由chrome自动更新完成，之前通过接口获取配置规则的逻辑也可由发布新版本的机制代替。</p>
<p>Chrome应用商店开发者中心相关操作流程<br>首先进入开发者中心<a href="https://chrome.google.com/webstore/developer/dashboard/g05227480483751387811?page=1&amp;pli=1，应该需要输入当前Chome账号密码" target="_blank" rel="noopener">https://chrome.google.com/webstore/developer/dashboard/g05227480483751387811?page=1&amp;pli=1，应该需要输入当前Chome账号密码</a></p>
<p>在“您的列表”下面找到“添加新内容”，打开上传页面；也可以选在已发布的插件，点击右侧的修改操作，进入编辑页面，然后重新上传更新后的包</p>
<p>点击“选择文件”，选择<code>npm run build</code>打包的压缩文件，然后点击上传，等到文件上传完毕，会自动跳转到编辑页面</p>
<p>在编辑页面需要填写扩展程序的基本信息，如介绍、图标、轮播图等，此处填写的内容会经过应用商店的审核，某些内容可能会导致审核不通过~</p>
<p>编辑完成后拉到页面最下面，点击发布按钮即可，此处的公开程度选项决定了是否在应用商店展示该扩展程序。</p>
<p>发布更改后等待一段时间（一般几分钟到几个小时不等），就可以在应用商店安装对应的扩展程序了。</p>
<p>之前经历过连续审核未通过的情形，需要根据被拒邮件列举的理由进行调整并重新发布更改，常见的理由有</p>
<p>未上传图标、空白描述、无预览效果图等<br>未描述产品隐私策略，需要附上隐私政策网址，在描述中详细介绍使用用户数据做什么事情</p>
]]></content>
  </entry>
  <entry>
    <title>重识排列组合</title>
    <url>/2019/10/24/Untitled/</url>
    <content><![CDATA[<p>6位数4位为一组共有多少组</p>
<p>共有15组。C（6，4）=15。    6<em>5</em>4<em>3</em>2<em>1/2</em>1<em>4</em>3<em>2</em>1=15;</p>
<p>从n个不同元素中取出m(m≤n)个元素的所有组合的个数,叫做从n个不同元素中取出m个元素的组合数.用符号 c(n,m) 表示.c(n,m)=p(n,m)/m!=n!/((n-m)!*m!)。</p>
<p>这里是从6个里面任取4个的所有组合 共有6!/(（6-4）!<em>4!)=6</em>5<em>4</em>3<em>2</em>1/2<em>1</em>4<em>3</em>2*1=15，所以共有15组。<br>扩展资料：</p>
<p>重复组合是一种特殊的组合。从n个不同元素中可重复地选取m个元素。不管其顺序合成一组，称为从n个元素中取m个元素的可重复组合。当且仅当所取的元素相同，且同一元素所取的次数相同，则两个重复组合相同。</p>
<p>排列组合计算方法如下：</p>
<p>排列A(n,m)=n×（n-1）.（n-m+1）=n!/（n-m）!(n为下标,m为上标,以下同)</p>
<p>组合C(n,m)=P(n,m)/P(m,m) =n!/m!（n-m）!；</p>
<p>例如：<br>A(4,2)=4!/2!=4*3=12</p>
<p>C(4,2)=4!/(2!<em>2!)=4</em>3/(2*1)=6</p>
]]></content>
  </entry>
  <entry>
    <title>nginx记录</title>
    <url>/2019/10/08/nginx%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h3 id="1-nginx-创建一个域名指向-静态资源html"><a href="#1-nginx-创建一个域名指向-静态资源html" class="headerlink" title="1.nginx 创建一个域名指向 静态资源html"></a>1.nginx 创建一个域名指向 静态资源html</h3><p><a href="http://www.test.com/" target="_blank" rel="noopener">http://www.test.com/</a></p>
<p>需要在nginx头上添加用户组，并且把静态资源的文件夹赋予用户权限</p>
<p>sudo chown -R root:wheel /Users/zhousteady/Downloads/test/examples</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">user root wheel;</span><br><span class="line">worker_processes  1;</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">      listen 80;</span><br><span class="line">      server_name www.test.com;</span><br><span class="line">      index index.html;</span><br><span class="line">  </span><br><span class="line">      root /Users/zhousteady/Downloads/test/examples/;</span><br><span class="line"></span><br><span class="line">      location / &#123;</span><br><span class="line">        proxy_redirect     off;</span><br><span class="line">        proxy_set_header   Host $host;</span><br><span class="line">        proxy_set_header   X-Forwarded-Host $host;</span><br><span class="line">        proxy_set_header   X-Forwarded-Server $host;</span><br><span class="line"></span><br><span class="line">        proxy_set_header   X-Real-IP        $remote_addr;</span><br><span class="line">        proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_buffering    on;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      location = /favicon.ico &#123;</span><br><span class="line">        return 204;</span><br><span class="line">        access_log     off;</span><br><span class="line">        log_not_found  off;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      location ~* &quot;(.+)-(\w+)\.\w+$&quot; &#123;</span><br><span class="line">        error_page 404 = @notfound;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      location @notfound &#123;</span><br><span class="line">        rewrite ^(.+)-(\w+)(\.\w+)$ $1$3 break;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="antd-线上静态资源和url-转发"><a href="#antd-线上静态资源和url-转发" class="headerlink" title="antd 线上静态资源和url 转发"></a>antd 线上静态资源和url 转发</h3><p>http请求 静态资源文件，需要让 运维配置 前置的nginx  , 类似：   请注意publicPath: ‘/ued_admin_static/‘, 为webpack静态资源打包前缀</p>
<pre><code>location ~ ^/ued_admin_static/{
           add_header Cache-Control &quot;no-cache, max-age=0, must-revalidate&quot;;
           rewrite ^/ued_admin_static/(.*) /$1 break;
           proxy_pass http://cd_ued_ftrade_admin;
        }


        location ~ ^/ued_admin/{
           add_header Cache-Control &quot;no-cache, max-age=0, must-revalidate&quot;;
           rewrite ^/ued_admin/(.*) /index.html break;
           index index.html;
           proxy_pass http://cd_ued_ftrade_admin;
        }
</code></pre>]]></content>
  </entry>
  <entry>
    <title>vue 记录</title>
    <url>/2019/08/30/vue%E4%B8%AD%E4%BA%8B%E4%BB%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6%E8%AF%A6%E8%A7%A3-stop-prevent-self-once-capture-passive-1/</url>
    <content><![CDATA[<h1 id="vue中事件修饰符详解-stop-prevent-self-once-capture-passive"><a href="#vue中事件修饰符详解-stop-prevent-self-once-capture-passive" class="headerlink" title="vue中事件修饰符详解(stop, prevent, self, once, capture, passive)"></a>vue中事件修饰符详解(stop, prevent, self, once, capture, passive)</h1><p>.stop 是阻止冒泡行为,不让当前元素的事件继续往外触发,如阻止点击div内部事件,触发div事件</p>
<p>.prevent 是阻止事件本身行为,如阻止超链接的点击跳转,form表单的点击提交</p>
<p>.self 是只有是自己触发的自己才会执行,如果接受到内部的冒泡事件传递信号触发,会忽略掉这个信号</p>
<p>.capture 是改变js默认的事件机制,默认是冒泡,capture功能是将冒泡改为倾听模式</p>
<p>.once 是将事件设置为只执行一次,如 .click.prevent.once 代表只阻止事件的默认行为一次,当第二次触发的时候事件本身的行为会执行</p>
<p>.passive 滚动事件的默认行为 (即滚动行为) 将会立即触发，而不会等待 onScroll 完成。这个 .passive 修饰符尤其能够提升移动端的性能。</p>
<p>————————————————</p>
<p>.passive 和 .prevent 不能一起使用:<br>.prevent 将会被忽略</p>
<p>.self 和 .stop 区别:<br>self只响应当前元素自身触发的事件，不会响应经过冒泡触发的事件，并不会阻止冒泡继续向外部触发。<br>stop是从自身开始不向外部发射冒泡信号</p>
<h1 id="this-set"><a href="#this-set" class="headerlink" title="this.$set"></a>this.$set</h1><p>使用示列：this.$set(arr,  index,  val)。当然，this.$set除了用于操作数组外还可以操作对象，使用示例：this.$set( obj, key, val).</p>
]]></content>
  </entry>
  <entry>
    <title>nodejs exports</title>
    <url>/2019/07/23/nodejs-exports/</url>
    <content><![CDATA[<h1 id="exports-与-module-exports"><a href="#exports-与-module-exports" class="headerlink" title="exports 与 module.exports"></a>exports 与 module.exports</h1><p>为了方便，Node为每个模块提供一个exports变量，指向module.exports。这等同在每个模块头部，有一行这样的命令。</p>
<p>var exports = module.exports;<br>于是我们可以直接在 exports 对象上添加方法，表示对外输出的接口，如同在module.exports上添加一样。注意，不能直接将exports变量指向一个值，因为这样等于切断了exports与module.exports的联系。</p>
<h1 id="不同于CommonJS，ES6使用-export-和-import-来导出、导入模块。"><a href="#不同于CommonJS，ES6使用-export-和-import-来导出、导入模块。" class="headerlink" title="不同于CommonJS，ES6使用 export 和 import 来导出、导入模块。"></a>不同于CommonJS，ES6使用 export 和 import 来导出、导入模块。</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// profile.js</span></span><br><span class="line"><span class="keyword">var</span> firstName = <span class="string">'Michael'</span>;</span><br><span class="line"><span class="keyword">var</span> lastName = <span class="string">'Jackson'</span>;</span><br><span class="line"><span class="keyword">var</span> year = <span class="number">1958</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;firstName, lastName, year&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="两个差异"><a href="#两个差异" class="headerlink" title="两个差异"></a>两个差异</h1><p>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</p>
<p>什么是值的拷贝，值的引用？<br>所谓值的拷贝，是在栈内存当中实现的，是一个复制的过程，复制之后两个值互不影响<br>值的引用，是在堆内存当中实现的，当一个引用类型赋值给一个变量时，此时变量拥有指向引用类型的一个指针，当变量发生改变，被引用的值也会发生改变<br>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</p>
<p>什么是运行时加载，什么是编译输出？<br>在后端开发当中，只需要做到一次加载，因此在启动服务器中进行加载即可，对于CommonJS的设计当中符合后端的这种开发理念，然后这种效果带来了很大的便利性，在前端开发也是需要模块化加载方式，可是，前端的加载方式跟后端不一致，如果采用CommonJS相同的加载方式，前端性能会大打折扣，比如网页假死，以及难以改变引入模块的变量，因此，在编译阶段，先将模块按需进行处理，生成接口，在引入模块之后进行使用时，可以很方便的调用接口<br>export 与 export default (params表示一个对象)<br>export 输出的时候必须是一个接口，因此export 后面跟的是 { …params} 或则以声明变量的形式 var name = 。。。。或则export function</p>
<p>export default 中 default 相当于 export 之后的一个接口名称，因此之后可以表达式或则 { …params} 对象</p>
<p>加载方式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">from</span> ‘./test’</span><br><span class="line"><span class="keyword">import</span> &#123; key, key1, key2 &#125; <span class="keyword">from</span> ‘./test’</span><br><span class="line"></span><br><span class="line">modele.exports 与 exports (params表示一个对象)</span><br><span class="line">modele.exports = &#123;&#125;写法</span><br></pre></td></tr></table></figure>
<p>exports为var exports = modele.exports，因此exports后面重新赋值会改变指针，故不能为exports重新赋值，例如exports = newObject，只能类似exports.name = ‘hello world’这种方式进行输出 , 实际上输出的是modele.exports = {name: ‘hello world’}</p>
<p>加载方式</p>
<p>var common = require(’./test’)</p>
<p>简单来说就是，在CommonJS规范下，通过require()导入的是模块的一份值拷贝，可以任意修改，且不会影响到原模块的值。修改原模块的值也不会变动当前文件下的值。– 二者在导入那一刻失去了联系。</p>
<p>在ES6规范下，打入只是和原模块建立连接，当前文件下不允许修改原模块，即只读。修改原模块的值，会在当前文件下也起作用。</p>
<p>看下面的例子就很清晰了：</p>
<p>CommonJS规范下值拷贝<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// calculator.js</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	count: count,</span><br><span class="line">	add: <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">		count += <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> a + b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="built_in">require</span>(<span class="string">'./calculator.js'</span>).count;</span><br><span class="line"><span class="keyword">var</span> add = <span class="built_in">require</span>(<span class="string">'./callculator.js'</span>).add;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// 0</span></span><br><span class="line">add(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// calculator.js中的count会变化</span></span><br><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// 0，这里的count不受变化</span></span><br><span class="line"></span><br><span class="line">count += <span class="number">1</span>; <span class="comment">// 本地count值可变化</span></span><br><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">ES6规范下动态映射</span><br><span class="line"></span><br><span class="line"><span class="comment">// calculator.js</span></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">	count += <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> &#123; count, add &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; count, add &#125; <span class="keyword">from</span> <span class="string">'./calculator.js'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// 0</span></span><br><span class="line">add(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// </span></span><br><span class="line"><span class="built_in">console</span>.log(count); <span class="comment">// 1, 实时反映calculator.js中的count值的变化</span></span><br><span class="line"></span><br><span class="line">count += <span class="number">1</span>; <span class="comment">// 不允许，count是只读的</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>steadycate</category>
      </categories>
      <tags>
        <tag>steadytag</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 二进制 十进制...</title>
    <url>/2019/07/19/JavaScript-%E4%BA%8C%E8%BF%9B%E5%88%B6-%E5%8D%81%E8%BF%9B%E5%88%B6/</url>
    <content><![CDATA[<p>利用 toString() 方法 十进制转二进制</p>
<p>var num = 10；<br>console.log( num.toString(“2”) )  转2进制: “1010”</p>
<p>console.log( num.toString(“8”) )  转8进制: “12”</p>
<p>console.log( num.toString(“16”) )  转16进制: “a”</p>
<p>利用 parseInt() 方法，其它进制转十进制</p>
<p>var num = 100</p>
<p>var num2 = num.toString(“2”)  //  “1100100”</p>
<p>var num8 = num.toString(“8”)  // “144”<br>var num16 = num.toString(“16”)  // “64”</p>
<p>console.log( parseInt(num2,2) )  2转10进制输出: 100</p>
<p>console.log( parseInt(num8 , 8) )  8转10进制: 100<br>console.log( parseInt(num16 , 16) )  16转10进制: 100</p>
]]></content>
  </entry>
  <entry>
    <title>dva记录</title>
    <url>/2019/06/02/dva%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line"> </span><br><span class="line">  namespace: &apos;example&apos;,   </span><br><span class="line"> </span><br><span class="line">  state: &#123;num:1&#125;,     //表示当前的example中的state状态，这里可以给初始值，这里num初始为1</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">  effects: &#123; //这里是做异步处理的</span><br><span class="line">    *addByONe(&#123; param&#125;, &#123; call, put,select &#125;) &#123; //这里使用select</span><br><span class="line"> </span><br><span class="line">      const num = yield select(state =&gt; state.num)    //这里就获取到了当前state中的数据num</span><br><span class="line">     //方式二： const num = yield select((&#123;num&#125;) =&gt;num)</span><br><span class="line"> </span><br><span class="line">    //方式三： const num = yield select(_ =&gt;_.num)</span><br><span class="line"> </span><br><span class="line">      let param1;</span><br><span class="line">       param1 = num + param;   这里就可以使用num进行操作了</span><br><span class="line">  </span><br><span class="line">      yield put(&#123;</span><br><span class="line">         type: &apos;save&apos;,   </span><br><span class="line">         num:param1</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line"> </span><br><span class="line">  &#125;,</span><br><span class="line">    </span><br><span class="line">  //用来保存更新state值 上面的put方法调用这里的方法</span><br><span class="line">  reducers: &#123;</span><br><span class="line">    save(state, action) &#123; //这里的state是当前总的state，这里的action包含了上面传递的参数和type</span><br><span class="line">      return &#123; ...state, ...action.num &#125;; //这里用ES6语法来更新当前state中num的值</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>微信小程序知识点</title>
    <url>/2019/04/11/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h2 id="componet-amp-template"><a href="#componet-amp-template" class="headerlink" title="componet &amp;  template"></a>componet &amp;  template</h2><p>除了component，微信小程序中还有另一种组件化你的方式template模板，这两者之间的区别是，template主要是展示，方法则需要在调用的页面中定义。而component组件则有自己的业务逻辑，可以看做一个独立的page页面。简单来说，如果只是展示，使用template就足够了，如果涉及到的业务逻辑交互比较多，那就最好使用component组件了。 </p>
]]></content>
  </entry>
  <entry>
    <title>记录package.json字段用处</title>
    <url>/2019/02/26/%E8%AE%B0%E5%BD%95package-json%E5%AD%97%E6%AE%B5%E7%94%A8%E5%A4%84/</url>
    <content><![CDATA[<p>npm install 就是安装模块，npm run dev  就是执行npm script中的命令。当我们执行npm命令的时候，它到哪里去找，这就要说到每个node项目中都有的核心文件package.json 文件。</p>
<p>　　项目开始时，我们就要建立这个文件。假设我们要创建一个node 项目，我们会新建一个文件夹命名node， 这时我们就要创建package.json文件。进入node 文件夹，你可以手动创建，就和创建一个txt文件一样，但我们一般都会使用命令创建，打开cmd 窗口，输入npm init， 这时你要回答几个问题，如name,version 等，输入内容，一路回车键，当你输入yes的时候，package.json 创建成功，你的文件夹中多了这个文件。</p>
<p>　　其中有几个字段比较重要：</p>
<p>　　name 项目名称， 你可能在项目中使用过 var express = require(‘express’), require 函数后面的参数，就是package.json 中的name字段，所以这个name一定要简短，且不能有大写，这是规定。</p>
<p>　　version版本号：安装一个模块的时候， 你可能指定过特定的版本号，npm install express @4.13.2, 版本号4.13.2 就是我们这里的version。版本号有三个组成部分，4：表示的是大版本，一般是重大升级。13：表示的是小版本, 在大版本的基础进行的小的更新，如某个功能废弃了，新增了那个功能。2： 对该版本进行补丁，主要是版本bug的修复。</p>
<p>　　script： 我们在命令行中执行的所有命令都写在这个地方，然后用 npm run 去执行这个命令。</p>
<p>　　项目初始完成后，我们就可以进行项目开发。在开发过程中我们都会用到一些第三方库和 框架，尤其是node 开发, 因为它提供的API 有点底层. 如果想用第三方的东西，就要事先安装。上面说到 安装用的命令是npm install。 npm install express –save  –save 是什么意思？–save表示，我们安装模块的时候，同时把它写到package.json 文件中。这时打开package.json 文件，我们看到多了一个dependencies字段，它包括了我们刚安装的express. node中有些es6/es7 的语法不支持，我们使用的时候，就需要进行转换。这时安装babel. npm install babel-cli babel-preset-es2015 –save–dev  –save-dev 又是什么，它也表示安装依模块的时候，把它写到package.json中，不过它写入的不是dependencies, 而是devDependencies中。</p>
<p>　　devDependencies 和dependencies 有什么区别？dependencies: 是项目运行时的依赖，就是程序上线后仍然需要依赖，比如express, 我们程序就是用express 写的，如果没有express, 我们的程序根本无法运行，更直白一点，dependencies 就是我们在程序开发的过程中手动require的模块。进行express 开发时,server.js中，都会写  var express  = require(‘express’), 我们程序直接依赖，所以是dependencies. </p>
<p>　　devDependencies, 开发依赖，就是我们在开发过程中需要的依赖。比如babel, 它只负责转换es6+ 到es5， 转换完成后，我们只要转换后的代码，上线的时候，直接把转换后的代码部署上线，不需要bebal.  这就是开发依赖，只在开发时候起作用， 上线不需要。其实就是我们在使用webpack开发时，它配置文件里所有的依赖，都是开发依赖。</p>
<p>　　无论devDependencies还是dependencies中，安装的模块版本号前面还有符号^, 其实这里还有很多符号也可以无符号，符号主要是限定版本。</p>
<p>　　“express”: “4.15.2” 版本号前面什么符号都没有，它表示固定版本，安装版本时，只会安装这个指定的版本。</p>
<p>　　“express”: “~4.15.2”，版本号前面有符号~，它表示安装4.15.x 的版本，只x&gt;3 就可以。在这里，我们express指定是4.15.2 版本，当我们npm install 安装的时候，它可能在项目中安装4.15.5或者4.15.6 版本。</p>
<p>　　“express”: “^4.15.2” , 版本号前面有符号^, 它表示可以安装4.x.x 的版本，只要中间的x  大于15就可以。</p>
<p>　　&gt;=4.15.3  版本号前面有符号&gt;=, 它安装大于我们指定的版本，就可以。</p>
<p>　　有时还看到一个*， 表示安装最新版本。</p>
<p>　　版本号一定要注意，因为有些框架和库在进行版本升级的时候，向后兼容性必较差，容易引起代码冲突。但npm install 进行安装的时候，它默认是^ 符号，如果不符合我们要求，我们可以对package.json 进行手动修改，如 把^号改成~, 或直接去掉符号， package.json文件，只是一个文件， 我们可以手动地进行任何修改。</p>
<p>　　最后再说一下package.json 中的scripts. 这个字段主要用于运行命令。我们用es6 写一个hello World项目体验下。在node文件夹中新建index.js </p>
<p>由于node 不支持 import 命令，所以要把它转成require 的形式，这要用到babel 命令: babel index.js –o server.js，由于babel-cli  是安装到本地的，所以不能全局使用，那么这个命令写在什么地方？就是写在scripts 中，</p>
<p>　　在scripts中的命令，都要用npm run 命令名启动。这时在命令行中输入npm run build，可以看到目录中多了一个server.js文件，再在命令行中输入node server, 就可以启动服务器。浏览器地址栏中输入localhost:8080, 看到hello world.</p>
<p>　　这里我们在命令行中输入了两次命令，其实可以把这两个命令合并到 一个命令中，修改scripts 中的build 如下， 直接npm run build  就可以启动服务器。</p>
<p>“build”: “babel index.js -o server.js &amp;&amp; node server”<br>　　npm 也可以做部分的任务自动化。</p>
<p>　　整个package.json文件如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;node&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;node project&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;server.js&quot;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;babel index.js -o server.js &amp;&amp; node server&quot;  </span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;author&quot;: &quot;&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;express&quot;: &quot;^4.15.2&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;babel-cli&quot;: &quot;^6.24.1&quot;,</span><br><span class="line">    &quot;babel-preset-es2015&quot;: &quot;^6.24.1&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>canvas 模拟时钟</title>
    <url>/2019/02/18/canvas-%E6%A8%A1%E6%8B%9F%E6%97%B6%E9%92%9F/</url>
    <content><![CDATA[<p>&lt;!DOCTYPE html&gt;</p>
<html lang="en"><br><head><br>    <meta charset="UTF-8"><br>    <title>Title</title>
  <meta name="generator" content="hexo-theme-yilia-plus"><br>    <style><br>        body {<br>            padding: 0;<br>            margin: 0;<br>            background-color: rgba(0, 0, 0, 0.1)<br>        }<br><br>        canvas {<br>            display: block;<br>            margin: 200px auto;<br>        }<br>    </style><br></head><br><body><br><canvas id="solar" width="300" height="300"></canvas><br><script><br>    init();<br><br>    function init(){<br>        let canvas = document.querySelector(“#solar”);<br>        let ctx = canvas.getContext(“2d”);<br>        draw(ctx);<br>    }<br><br>    function draw(ctx){<br>        requestAnimationFrame(function step(){<br>            drawDial(ctx); //绘制表盘<br>            drawAllHands(ctx); //绘制时分秒针<br>            requestAnimationFrame(step);<br>        });<br>    }<br>    /<em>绘制时分秒针</em>/<br>    function drawAllHands(ctx){<br>        let time = new Date();<br><br>        let s = time.getSeconds();<br>        let m = time.getMinutes();<br>        let h = time.getHours();<br><br>        let pi = Math.PI;<br>        let secondAngle = pi / 180 <em> 6 </em> s;  //计算出来s针的弧度<br>        let minuteAngle = pi / 180 <em> 6 </em> m + secondAngle / 60;  //计算出来分针的弧度<br>        let hourAngle = pi / 180 <em> 30 </em> h + minuteAngle / 12;  //计算出来时针的弧度<br><br>        drawHand(hourAngle, 60, 6, “red”, ctx);  //绘制时针<br>        drawHand(minuteAngle, 106, 4, “green”, ctx);  //绘制分针<br>        drawHand(secondAngle, 129, 2, “blue”, ctx);  //绘制秒针<br>    }<br>    /<em>绘制时针、或分针、或秒针
     </em> 参数1：要绘制的针的角度<br>     <em> 参数2：要绘制的针的长度
     </em> 参数3：要绘制的针的宽度<br>     <em> 参数4：要绘制的针的颜色
     </em> 参数4：ctx<br>     <em> </em>/<br>    function drawHand(angle, len, width, color, ctx){<br>        ctx.save();<br>        ctx.translate(150, 150); //把坐标轴的远点平移到原来的中心<br>        ctx.rotate(-Math.PI / 2 + angle);  //旋转坐标轴。 x轴就是针的角度<br>        ctx.beginPath();<br>        ctx.moveTo(-4, 0);<br>        ctx.lineTo(len, 0);  // 沿着x轴绘制针<br>        ctx.lineWidth = width;<br>        ctx.strokeStyle = color;<br>        ctx.lineCap = “round”;<br>        ctx.stroke();<br>        ctx.closePath();<br>        ctx.restore();<br>    }<br><br>    /<em>绘制表盘</em>/<br>    function drawDial(ctx){<br>        let pi = Math.PI;<br><br>        ctx.clearRect(0, 0, 300, 300); //清除所有内容<br>        ctx.save();<br><br>        ctx.translate(150, 150); //一定坐标原点到原来的中心<br>        ctx.beginPath();<br>        ctx.arc(0, 0, 148, 0, 2 <em> pi); //绘制圆周<br>        ctx.stroke();<br>        ctx.closePath();<br><br>        for (let i = 0; i &lt; 60; i++){//绘制刻度。<br>            ctx.save();<br>            ctx.rotate(-pi / 2 + i </em> pi / 30);  //旋转坐标轴。坐标轴x的正方形从 向上开始算起<br>            ctx.beginPath();<br>            ctx.moveTo(110, 0);<br>            ctx.lineTo(140, 0);<br>            ctx.lineWidth = i % 5 ? 2 : 4;<br>            ctx.strokeStyle = i % 5 ? “blue” : “red”;<br>            ctx.stroke();<br>            ctx.closePath();<br>            ctx.restore();<br>        }<br>        ctx.restore();<br>    }<br></script><br></body><br></html>
]]></content>
  </entry>
  <entry>
    <title>data-xxx ,attribute</title>
    <url>/2019/02/13/data-xxx-attribute/</url>
    <content><![CDATA[<p>data-* 属性是 HTML 5 的新特性，允许用户在 DOM 中存储自定义信息。</p>
<p>以前，需要存储含有特定含义的信息通常是通过 class 完成的，但这并不是 class 本来的用途。现在，利用 HTML 5，可以为元素添加data-<em>属性，从而存储自定义信息。其中</em>是可以自定义的部分。例如：</p>
<p><article id="tu" data-category="Web Development" data-author="1"> … </article><br>通过 JavaScript 访问<br>通过 JavaScript 访问自定义的信息有两种方式：getAttribute()和dataset。</p>
<p>getAttribute 方法<br>这就是经典的取得一个元素属性的方式，和以前一样。</p>
<p>document.getElementById(‘tu’).getAttribute(‘data-category’); // “Web Development”<br>dataset 方法<br>这是 HTML 5 新增的方法，可以更方便的读取所有的 data 信息。</p>
<p>var article = document.getElementById(‘tu’);<br>var data = article.dataset;<br>alert(data.category); // “Web Development”<br>alert(data.author); // 1<br>通过 jQuery 访问<br>jQuery 也提供了专门的data方法来访问这些信息：</p>
<p>$(“#tu”).data(‘category’); // “Web Development”<br>通过 CSS 访问<br>使用 attr<br>article::before {<br>    content: attr(data-category);<br>}<br>使用属性选择器<br>article[data-author=’1’] {<br>    border-width: 1px;<br>}<br>修改信息<br>在引入 jQuery 之前，使用 JavaScript 修改自定义信息也非常容易，两种方式都可以：</p>
<p>var a = document.getElementById(‘tu’);<br>a.dataset.category = “Uncategorized”;<br>a.setAttribute(“data-category”, “Uncategorized”);<br>然而如果你用 jQuery 的data方法进行修改：</p>
<p>$(“#tu”).data(“category”, “Uncategorized”);<br>会发现 HTML 代码并没有改动，同时使用dataset等标准 JavaScript 读出来的数据也是修改之前的数据。类似，如果先用 jQuery 读取一次，然后再用标准 JavaScript 修改，再用 jQuery 读取第二次，则发现读取的数据仍是修改之前的数据。可是如果没有经过 jQuery 读取直接用标准 JavaScript 修改，这时再用 jQuery 读取，读到的就是新数据了。</p>
<p>这是怎么回事儿？</p>
<p>jQuery 的文档对此有所说明：</p>
<p>The data- attributes are pulled in the first time the data property is accessed and then are no longer accessed or mutated (all data values are then stored internally in jQuery).</p>
<p>原来，标准 JavaScript 直接对 DOM 进行读写（和我们设想的一致），但是 jQuery 不同。jQuery 的内部也维护着一份这些 data 数据。当第一次使用 jQuery 读取时，数据被从 DOM 读到jQuery.cache保存起来，以后使用 jQuery 修改时，修改的是内部维护的这个数据，同时再次读取也会从 jQuery 内部而非 DOM 读取数据。</p>
<p>因此，最好的办法是，要么一直用标准 JavaScript，要么一直用 jQuery。不要两者混用就好了。jQuery 如此设计的初衷就是为了减少 DOM 读写从而提高性能。</p>
]]></content>
  </entry>
  <entry>
    <title>webpack打包记录</title>
    <url>/2018/12/21/webpack%E6%89%93%E5%8C%85%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="解决-vender的hash因为文件新增而改变"><a href="#解决-vender的hash因为文件新增而改变" class="headerlink" title="解决 vender的hash因为文件新增而改变"></a>解决 vender的hash因为文件新增而改变</h1><p>两次构建之间，vender chunk的chunkhash以及各模块的模块ID都保持了一致。从而达到了最佳的缓存效果。<br><a href="https://www.cnblogs.com/zhishaofei/p/8590627.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhishaofei/p/8590627.html</a></p>
<p>1.Webpack 4 抛弃了原有的 CommonChunksPlugin，换成了更为先进的 SplitChunksPlugin，用于提取公用代码。</p>
<p>2.js Tree Shaking<br>清除到代码中无用的js代码，只支持import方式引入，不支持commonjs的方式引入<br>只要mode是production就会生效，develpoment的tree shaking是不生效的，因为webpack为了方便你的调试<br>  optimization: {<br>    usedExports:true,<br>  }</p>
<ol start="3">
<li><p>plugins: [</p>
<pre><code>new webpack.DllPlugin({
    // 定义程序中打包公共文件的入口文件vendor.js
</code></pre></li>
<li><p>使用happypack并发执行任务<br>运行在 Node.之上的Webpack是单线程模型的，也就是说Webpack需要一个一个地处理任务，不能同时处理多个任务。 Happy Pack 就能让Webpack做到这一点，它将任务分解给多个子进程去并发执行，子进程处理完后再将结果发送给主进程。<br>cnpm i -D happypack</p>
</li>
</ol>
<p>// webpack.config.js<br> rules: [<br>     {<br>        // cnpm i babel-loader @babel/core @babel/preset-env -D<br>        test: /.jsx?$/,<br>        exclude: /node_modules/,<br>        use: [<br>          {<br>            // 一个loader对应一个id<br>            loader: “happypack/loader?id=busongBabel”<br>          }<br>        ]<br>      }<br>      ]</p>
<p>//在plugins中增加<br>plugins:[<br>      new HappyPack({<br>      // 用唯一的标识符id，来代表当前的HappyPack是用来处理一类特定的文件<br>      id:’busongBabel’,<br>      // 如何处理.js文件，用法和Loader配置中一样<br>      loaders:[‘babel-loader?cacheDirectory’],<br>      threadPool: HappyPackThreadPool,<br>  })<br>]</p>
<ol start="5">
<li>PWA优化策略<br>简言之：在你第一次访问一个网站的时候，如果成功，做一个缓存，当服务器挂了之后，你依然能够访问这个网页 ，这就是PWA。那相信你也已经知道了，这个只需要在生产环境，才需要做PWA的处理，以防不测。<br>cnpm i workbox-webpack-plugin -D</li>
</ol>
<p>const WorkboxPlugin = require(‘workbox-webpack-plugin’) // 引入 PWA 插件<br>const prodConfig = {<br>  plugins: [<br>    // 配置 PWA<br>    new WorkboxPlugin.GenerateSW({<br>      clientsClaim: true,<br>      skipWaiting: true<br>    })<br>  ]<br>}</p>
<p>在入口文件加上<br>// 判断该浏览器支不支持 serviceWorker<br>if (‘serviceWorker’ in navigator) {<br>  window.addEventListener(‘load’, () =&gt; {<br>    navigator.serviceWorker<br>      .register(‘/service-worker.js’)<br>      .then(registration =&gt; {<br>        console.log(‘service-worker registed’)<br>      })<br>      .catch(error =&gt; {<br>        console.log(‘service-worker registed error’)<br>      })<br>  })<br>}</p>
<p>6.使用 HotModuleReplacement (热模块替换HMR)<br>建立了开发环境本地服务器 后，当修改内容后，网页会同步刷新，我们现在进入toCOunt页面</p>
<p>点击按钮，将数字加到一个不为0的数，比如加到6</p>
<p>然后你可以在代码中改变按钮的文字，随便改点东西，会发现，页面刷新后，数字重新变为0</p>
<p>这显然不是我们想要的，想要的是，能不能把页面的状态保存了，也就是更改了代码后，页面还是保存了数字为6的状态，也就是实现局部更改，首先需要用到：HotModuleReplacementPlugin插件<br>devServer: {<br>    hot: true<br>},</p>
<p>plugins: [<br>    new webpack.HotModuleReplacementPlugin()<br>],<br>复制代码完事之后，继续更上边的操作，点击按钮，数字增加，然后更改内容，发现还是没有保存状态。。。what？怎么办<br>对@！这还没完呢，接着往下看，我们还需要react-hot-loader这个插件<br>10、react-hot-loader记录react页面留存状态state<br>我们继续接着上边的进行操作，分一下四步<br>cnpm i react-hot-loader -D</p>
<p>// 在主文件里这样写</p>
<p>import React from “react”;<br>import ReactDOM from “react-dom”;<br>import { AppContainer } from “react-hot-loader”;——————-1、首先引入AppContainre<br>import { BrowserRouter } from “react-router-dom”;<br>import Router from “./router”;</p>
<p>/<em>初始化</em>/<br>renderWithHotReload(Router);——————-2、初始化</p>
<p>/<em>热更新</em>/<br>if (module.hot) {——————-3、热更新操作<br>  module.hot.accept(“./router/index.js”, () =&gt; {<br>    const Router = require(“./router/index.js”).default;<br>    renderWithHotReload(Router);<br>  });<br>}</p>
<p>function renderWithHotReload(Router) {——————-4、定义渲染函数<br>  ReactDOM.render(<br>    <appcontainer><br>      <browserrouter><br>        <router><br>      </router></browserrouter><br>    </appcontainer>,<br>    document.getElementById(“app”)<br>  );<br>}</p>
]]></content>
  </entry>
  <entry>
    <title>linux git 使用记录</title>
    <url>/2018/12/18/linux%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>1.全文磁盘搜索：<br>grep -rn “hello,world!” *</p>
<p>2.git reset –hard<br>至于这几个参数：<br>–mixed<br>意思是：不删除工作空间改动代码，撤销commit，并且撤销git add . 操作<br>这个为默认参数,git reset –mixed HEAD^ 和 git reset HEAD^ 效果是一样的。</p>
<p>–soft<br>不删除工作空间改动代码，撤销commit，不撤销git add . </p>
<p>–hard<br>删除工作空间改动代码，撤销commit，撤销git add . </p>
<p>注意完成这个操作后，就恢复到了上一次的commit状态。</p>
<p>3.</p>
]]></content>
  </entry>
  <entry>
    <title>纯手写轮子</title>
    <url>/2018/11/29/%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<ol>
<li>从URL输入到页面展现到底发生什么？ #24<br><a href="https://github.com/ljianshu/Blog/issues/24" target="_blank" rel="noopener">https://github.com/ljianshu/Blog/issues/24</a></li>
</ol>
<p>2.高级curry化实现<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">func</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">curried</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(args.length&gt;=func.length)&#123;</span><br><span class="line">          <span class="keyword">return</span> func.apply(<span class="keyword">this</span>,args);</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args2</span>)</span>&#123;</span><br><span class="line">            </span><br><span class="line">               <span class="keyword">return</span> curried.apply(<span class="keyword">this</span>,args.concat(args2));</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运用递归的方式，</p>
<p>3.手写一个深拷贝</p>
<p><img src="/images/pasted-10.png" alt="upload successful"></p>
<p>4.手写一个防抖,节流函数</p>
<p><img src="/images/pasted-11.png" alt="upload successful"><br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">debunce</span>(<span class="params">func,wait</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> timeOut=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context=<span class="keyword">this</span>;</span><br><span class="line">          <span class="keyword">if</span>(timeOut)&#123;</span><br><span class="line">            clearTimeout(timeOut);</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            timeOut=setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">              func.apply(context,args);</span><br><span class="line">            &#125;</span><br><span class="line">            ,</span><br><span class="line">            wait);</span><br><span class="line">          &#125;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    现在一起实现一个 throttle：</span><br><span class="line"></span><br><span class="line"><span class="comment">// fn是我们需要包装的事件回调, interval是时间间隔的阈值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, interval</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// last为上一次触发回调的时间</span></span><br><span class="line">  <span class="keyword">let</span> last = <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 将throttle处理结果当作函数返回</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 保留调用时的this上下文</span></span><br><span class="line">      <span class="keyword">let</span> context = <span class="keyword">this</span></span><br><span class="line">      <span class="comment">// 保留调用时传入的参数</span></span><br><span class="line">      <span class="keyword">let</span> args = <span class="built_in">arguments</span></span><br><span class="line">      <span class="comment">// 记录本次触发回调的时间</span></span><br><span class="line">      <span class="keyword">let</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 判断上次触发的时间和本次触发的时间差是否小于时间间隔的阈值</span></span><br><span class="line">      <span class="keyword">if</span> (now - last &gt;= interval) &#123;</span><br><span class="line">      <span class="comment">// 如果时间间隔大于我们设定的时间间隔阈值，则执行回调</span></span><br><span class="line">          last = now;</span><br><span class="line">          fn.apply(context, args);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>5.es5 继承 和es6 class extends 继承<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.name=name;</span><br><span class="line">     <span class="keyword">this</span>.color=[<span class="string">"red"</span>,<span class="string">"blue"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">     SuperType.call(<span class="keyword">this</span>,name); <span class="comment">//就是把this 传到父类执行了构造函数。所以this变化了。但this的地址是 subtype的</span></span><br><span class="line">     <span class="keyword">this</span>.age=age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> 1. 这一步不用Child.prototype =Parent.prototype的原因是怕共享内存，修改父类原型对象就会影响子类</span></span><br><span class="line"><span class="comment"> 2. 不用Child.prototype = new Parent()的原因是会调用2次父类的构造方法（另一次是call），会存在一份多余的父类实例属性</span></span><br><span class="line"><span class="comment">3. Object.create是创建了父类原型的副本，与父类原型完全隔离</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">SubType.prototype=<span class="built_in">Object</span>.create(SuperType.prototype);</span><br><span class="line">SubType.prototype.constructor=SubType;</span><br><span class="line"></span><br><span class="line">val s1=<span class="keyword">new</span> SubType(”ren“)</span><br><span class="line">s1.sayName();</span><br><span class="line"><span class="built_in">console</span>.log(sl.color);</span><br><span class="line"></span><br><span class="line">-----</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperType</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">       <span class="keyword">this</span>.name=name;</span><br><span class="line">       <span class="keyword">this</span>.color=[<span class="string">'red'</span>,<span class="string">'blue'</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    sayName()&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubType</span> <span class="keyword">extends</span> <span class="title">SuperType</span></span>&#123;</span><br><span class="line">     <span class="keyword">constructor</span>(name,age)&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);<span class="comment">//相当于SuperType.call(this,name);</span></span><br><span class="line">        <span class="keyword">this</span>.age=age;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s1=<span class="keyword">new</span> SubType(<span class="string">'ren'</span>,<span class="number">19</span>);</span><br><span class="line">s1.sayName();</span><br><span class="line"><span class="built_in">console</span>.log(s1.color);</span><br></pre></td></tr></table></figure></p>
<p>6.//实现一个eventemitter<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Emitter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>()&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.list=&#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">constructor</span>()&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  on(e,f)&#123;</span><br><span class="line">    <span class="keyword">var</span> callback=<span class="keyword">this</span>.list[e]?<span class="keyword">this</span>.list[e]:[];</span><br><span class="line">    callback.push(f);</span><br><span class="line">    <span class="keyword">this</span>.list[e]=callback;</span><br><span class="line">  &#125;</span><br><span class="line">  emit(e,...params)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.list[e])&#123;</span><br><span class="line">      <span class="keyword">this</span>.list[e].map(<span class="function"><span class="keyword">function</span>(<span class="params">item,index</span>)</span>&#123;</span><br><span class="line">        item(...params);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  off(e,f)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.list.hasOwnProperty(e))&#123;</span><br><span class="line">      <span class="keyword">const</span> callback=<span class="keyword">this</span>.list[e];</span><br><span class="line">      <span class="keyword">let</span> index=callback.indexOf(f);</span><br><span class="line">      callback.splice(index,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  once(e,f)&#123;</span><br><span class="line">    <span class="keyword">let</span> newFunc=<span class="function">(<span class="params">...args</span>)=&gt;</span>&#123;</span><br><span class="line">      f.apply(<span class="keyword">this</span>,args);</span><br><span class="line">      <span class="keyword">this</span>.off(e,newFunc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.on(e,newFunc)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>7.//实现一个jsonp<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">window,document</span>) </span>&#123;</span><br><span class="line"><span class="meta">    "use strict"</span>;</span><br><span class="line">    <span class="keyword">var</span> jsonp = <span class="function"><span class="keyword">function</span> (<span class="params">url,data,callback</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.将传入的data数据转化为url字符串形式</span></span><br><span class="line">        <span class="comment">// &#123;id:1,name:'jack'&#125; =&gt; id=1&amp;name=jack</span></span><br><span class="line">        <span class="keyword">var</span> dataString = url.indexof(<span class="string">'?'</span>) == <span class="number">-1</span>? <span class="string">'?'</span>: <span class="string">'&amp;'</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> data)&#123;</span><br><span class="line">            dataString += key + <span class="string">'='</span> + data[key] + <span class="string">'&amp;'</span>;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2 处理url中的回调函数</span></span><br><span class="line">        <span class="comment">// cbFuncName回调函数的名字 ：my_json_cb_名字的前缀 + 随机数（把小数点去掉）</span></span><br><span class="line">        <span class="keyword">var</span> cbFuncName = <span class="string">'my_json_cb_'</span> + <span class="built_in">Math</span>.random().toString().replace(<span class="string">'.'</span>,<span class="string">''</span>);</span><br><span class="line">        dataString += <span class="string">'callback='</span> + cbFuncName;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.创建一个script标签并插入到页面中</span></span><br><span class="line">        <span class="keyword">var</span> scriptEle = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">        scriptEle.src = url + dataString;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.挂载回调函数</span></span><br><span class="line">        <span class="built_in">window</span>[cbFuncName] = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">            callback(data);</span><br><span class="line">            <span class="comment">// 处理完回调函数的数据之后，删除jsonp的script标签</span></span><br><span class="line">            <span class="built_in">document</span>.body.removeChild(scriptEle);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">document</span>.body.appendChild(scriptEle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">window</span>.$jsonp = jsonp;</span><br><span class="line"></span><br><span class="line">&#125;)(<span class="built_in">window</span>,<span class="built_in">document</span>)</span><br></pre></td></tr></table></figure></p>
<p>8.co库实现原理，就是利用产出值的done的状态，去判断是否需要再次递归执行next方法。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">co</span>(<span class="params">it</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">let</span> &#123;value,done&#125;= it.next(data);</span><br><span class="line">            <span class="keyword">if</span>(!done)&#123;</span><br><span class="line">                value.then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">                    next(res);</span><br><span class="line">                &#125;,reject)</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                resolve(value)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        next();</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol start="9">
<li><p>使用co 遍历generator </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> co=<span class="built_in">require</span>(<span class="string">'co'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">testco</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a=<span class="keyword">yield</span> promisA();</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="keyword">let</span> b=<span class="keyword">yield</span> promisA();</span><br><span class="line">    <span class="keyword">let</span> c=<span class="keyword">yield</span> promisA();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promisA</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            resolve(<span class="number">99</span>);</span><br><span class="line">        &#125;,<span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newtestco=testco();</span><br><span class="line"></span><br><span class="line">co(newtestco).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(data)&#125;)</span><br><span class="line"></span><br><span class="line">日志</span><br><span class="line"><span class="number">99</span></span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>执行下面promise ，日志为test(10)   10! ,err,undefined </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(res)</span><br><span class="line">        .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(res += <span class="string">'!'</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">'err'</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">         setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>resolve(<span class="number">10</span>),<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">           <span class="comment">//return Promise.reject("end"); //此处返回了一个新的promise </span></span><br><span class="line">.catch(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(res);</span><br><span class="line">            </span><br><span class="line">        &#125;)</span><br><span class="line">        .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(res += <span class="string">'!'</span>);  <span class="comment">//肯定会执行了</span></span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>11.手写一个简单promise</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myPromise</span>(<span class="params">constructor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">    self.status = <span class="string">"pending"</span></span><br><span class="line">        <span class="comment">//定义状态改变前的初始状态</span></span><br><span class="line">    self.value = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">//定义状态为resolved的时候的状态</span></span><br><span class="line">    self.reason = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">//定义状态为rejected的时候的状态</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//两个==="pending"，保证了状态的改变是不可逆的</span></span><br><span class="line">        <span class="keyword">if</span> (self.status === <span class="string">"pending"</span>) &#123;</span><br><span class="line">            self.value = value;</span><br><span class="line">            self.status = <span class="string">"resolved"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//两个==="pending"，保证了状态的改变是不可逆的</span></span><br><span class="line">        <span class="keyword">if</span> (self.status === <span class="string">"pending"</span>) &#123;</span><br><span class="line">            self.reason = reason;</span><br><span class="line">            self.status = <span class="string">"rejected"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//捕获构造异常</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">constructor</span>(resolve, reject);</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">        reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//同时，需要在 myPromise的原型上定义链式调用的 then方法：</span></span><br><span class="line">myPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFullfilled, onRejected</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">switch</span> (self.status) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"resolved"</span>:</span><br><span class="line">            onFullfilled(self.value);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"rejected"</span>:</span><br><span class="line">            onRejected(self.reason);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//测试一下：</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> myPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    resolve(<span class="number">1</span>)</span><br><span class="line">&#125;);</span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>12.看到一个很有意思的数组去重</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">2</span>].filter(<span class="function">(<span class="params">item, index, arr</span>) =&gt;</span> arr.indexOf(item) === index)</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>css3 相关(动画,语法)</title>
    <url>/2018/11/23/css3-%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<h1 id="1-使用-mix-blend-mode-screen-滤色模式制作-loading-效果"><a href="#1-使用-mix-blend-mode-screen-滤色模式制作-loading-效果" class="headerlink" title="1.使用 mix-blend-mode: screen 滤色模式制作 loading 效果"></a>1.使用 mix-blend-mode: screen 滤色模式制作 loading 效果</h1><iframe title="mix-blend-mode: screen" src="https://codepen.io/Chokcoco/embed/zwPyWj/?height=265&amp;theme-id=0&amp;default-tab=css,result&amp;embed-version=2" frameborder="no" scrolling="no" width="750" height="365"></iframe>

<p>更多：<a href="https://www.cnblogs.com/coco1s/p/6829372.html" target="_blank" rel="noopener">https://www.cnblogs.com/coco1s/p/6829372.html</a></p>
<h1 id="2-选择器"><a href="#2-选择器" class="headerlink" title="2.选择器"></a>2.选择器</h1><p>选择第一个类名： .exerciseInfo: nth-of-type(1) { … };</p>
<p>选择最后一个类名： .exerciseInfo: last-child { … };</p>
<iframe height="265" style="width: 100%;" scrolling="no" title="【iCSS：布局】使用:not()去除无用属性" src="https://codepen.io/steadyzeus/embed/jOOPgYJ?height=265&theme-id=0&default-tab=html,result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/steadyzeus/pen/jOOPgYJ" target="_blank" rel="noopener">【iCSS：布局】使用:not()去除无用属性</a> by Steady<br>  (<a href="https://codepen.io/steadyzeus" target="_blank" rel="noopener">@steadyzeus</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>

<h1 id="3-使用object-fit规定图像尺寸"><a href="#3-使用object-fit规定图像尺寸" class="headerlink" title="3.使用object-fit规定图像尺寸"></a>3.使用object-fit规定图像尺寸</h1><p>要点：通过object-fit使图像脱离background-size的约束，使用<img>来标记图像背景尺寸</p>
<iframe height="265" style="width: 100%;" scrolling="no" title="【iCSS：布局】使用object-fit规定图像尺寸" src="https://codepen.io/steadyzeus/embed/mddedOJ?height=265&theme-id=0&default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/steadyzeus/pen/mddedOJ" target="_blank" rel="noopener">【iCSS：布局】使用object-fit规定图像尺寸</a> by Steady<br>  (<a href="https://codepen.io/steadyzeus" target="_blank" rel="noopener">@steadyzeus</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>


<h1 id="4-iCSS：布局】使用transform描绘1px边框"><a href="#4-iCSS：布局】使用transform描绘1px边框" class="headerlink" title="4.iCSS：布局】使用transform描绘1px边框"></a>4.iCSS：布局】使用transform描绘1px边框</h1><p>//从左上角开始缩放，不然是从右下角开始<br>transform: scale(.5);<br>transform-origin: left top;</p>
<iframe height="265" style="width: 100%;" scrolling="no" title="【iCSS：布局】使用transform描绘1px边框" src="https://codepen.io/JowayYoung/embed/YzKqMVO?height=265&theme-id=0&default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true"><br>  See the Pen <a href="https://codepen.io/JowayYoung/pen/YzKqMVO" target="_blank" rel="noopener">【iCSS：布局】使用transform描绘1px边框</a> by JowayYoung<br>  (<a href="https://codepen.io/JowayYoung" target="_blank" rel="noopener">@JowayYoung</a>) on <a href="https://codepen.io" target="_blank" rel="noopener">CodePen</a>.<br></iframe>


<h1 id="5-css中“-”（波浪号）、“，”（逗号）、-“-”（加号）和-“-gt-”（大于号）是什么意思？"><a href="#5-css中“-”（波浪号）、“，”（逗号）、-“-”（加号）和-“-gt-”（大于号）是什么意思？" class="headerlink" title="5.css中“~”（波浪号）、“，”（逗号）、 “ + ”（加号）和 “ &gt; ”（大于号）是什么意思？"></a>5.css中“~”（波浪号）、“，”（逗号）、 “ + ”（加号）和 “ &gt; ”（大于号）是什么意思？</h1><p>为所有相同的父元素中位于 p 元素之后的所有 ul 元素设置背景：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    p~ul&#123;</span><br><span class="line">　　     background:#ff0000;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">      &lt;p&gt;快乐生活&lt;/p&gt;</span><br><span class="line">      &lt;ul&gt;</span><br><span class="line">　　    &lt;li&gt;生活&lt;/li&gt;</span><br><span class="line">　　    &lt;li&gt;生活&lt;/li&gt;</span><br><span class="line">　　    &lt;li&gt;生活&lt;/li&gt;</span><br><span class="line">      &lt;/ul&gt;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">p~ul 选择前面有 &lt;p&gt; 元素的每个 &lt;ul&gt; 元素。“~”的定义和用法,p~ul选择器 p之后出现的所有ul。</span><br><span class="line"></span><br><span class="line">　　两种元素必须拥有相同的父元素，但是 ul不必直接紧随 p。</span><br><span class="line"></span><br><span class="line">       css中“&gt;”是css3特有的选择器，A&gt;B 表示选择A元素的所有子B元素。</span><br><span class="line"></span><br><span class="line">　　与A B的区别在于，A B选择所有后代元素，而A&gt;B只选择一代。</span><br><span class="line"></span><br><span class="line">       .a，.b｛逗号指相同的css样式｝；</span><br><span class="line"></span><br><span class="line">       .a .b｛空格指后代元素｝；</span><br><span class="line"></span><br><span class="line">       .a&gt;.b｛大于号指子代元素｝；</span><br><span class="line"></span><br><span class="line">       .a+.b｛这个“+”是选择相邻兄弟，叫做“相邻兄弟选择器”</span><br></pre></td></tr></table></figure></p>
<p>　　如果需要选择紧接在另一个元素后的元素，而且二者有相同的父元素，可以使用相邻兄弟选择器(Adjacent sibling selector)。<br>　　例如，如果要增加紧接在 h1 元素后出现的段落的上边距，可以这样写：<br>　　h1 + p {margin-top:50px;}<br>　　这个选择器读作：“选择紧接在 h1 元素后出现的段落，h1 和 p 元素拥有共同的父元素”。｝；<br>  <code>`</code></p>
<h1 id="6-ease-seae-in-ease-in-out-ease-out"><a href="#6-ease-seae-in-ease-in-out-ease-out" class="headerlink" title="6.ease,seae-in,ease-in-out,ease-out"></a>6.ease,seae-in,ease-in-out,ease-out</h1><p>css 动画中 ease,seae-in,ease-in-out,ease-out,效果区别<br>linear    规定以相同速度开始至结束的过渡效果（等于 cubic-bezier(0,0,1,1)）。(匀速)<br>ease    规定慢速开始，然后变快，然后慢速结束的过渡效果（cubic-bezier(0.25,0.1,0.25,1)）（相对于匀速，中间快，两头慢）。<br>ease-in    规定以慢速开始的过渡效果（等于 cubic-bezier(0.42,0,1,1)）（相对于匀速，开始的时候慢，之后快）。<br>ease-out    规定以慢速结束的过渡效果（等于 cubic-bezier(0,0,0.58,1)）（相对于匀速，开始时快，结束时候间慢，）。<br>ease-in-out    规定以慢速开始和结束的过渡效果（等于 cubic-bezier(0.42,0,0.58,1)）（相对于匀速，（开始和结束都慢）两头慢）。<br>cubic-bezier(n,n,n,n)    在 cubic-bezier 函数中定义自己的值。可能的值是 0 至 1 之间的数值。</p>
<h1 id="7-animation-direction：定义是否循环交替反向播放动画。"><a href="#7-animation-direction：定义是否循环交替反向播放动画。" class="headerlink" title="7.animation-direction：定义是否循环交替反向播放动画。"></a>7.animation-direction：定义是否循环交替反向播放动画。</h1><p>normal    默认值。动画按正常播放。<br>reverse    动画反向播放。<br>alternate    动画在奇数次（1、3、5…）正向播放，在偶数次（2、4、6…）反向播放。<br>alternate-reverse    动画在奇数次（1、3、5…）反向播放，在偶数次（2、4、6…）正向播放。<br>initial    设置该属性为它的默认值。<br>inherit    从父元素继承该属性。</p>
<p>animation 属性一共有 6个基本属性：</p>
<p>animation-name    ：keyframe name</p>
<p>animation-duration</p>
<p>animation-timing-function</p>
<p>animation-delay</p>
<p>animation-iteration-count</p>
<p>animation-direction</p>
<p>animation-play-state: running | paused 检索或设置对象动画的状态，running为默认值</p>
<h1 id="8-animation-fill-mode-使用"><a href="#8-animation-fill-mode-使用" class="headerlink" title="8.animation-fill-mode 使用"></a>8.animation-fill-mode 使用</h1><p>首先，你要明白动画分为 初始状态 等待期 动画执行期 完成期 四个阶段。</p>
<p>初始状态，就是没有触发动画效果时，你元素原本应该有的状态。<br>例如你的动画是通过点击触发的，那么你元素在还没有点击的时候，是受初始状态样式控制的，也就css中不含 animation 的其他属性控制。</p>
<p>等待期，就是 animation-delay 设置的延迟期间。</p>
<p>按照点击触发为例子，等待期就是从你点击元素开始计算，持续 animation-delay 计时结束的这段时间。</p>
<p>这个期间的样式会受到 animation-fill-mode 取值的影响。</p>
<p>如果为 none，表示等待期间元素没有变化，还是初始状态的样式。<br>如果为 backwards 或者 both，表示等待期元素样式为第一帧的样式。</p>
<p>注意是第一帧的概念，可能时 @keyframes 中的 0%，也有可能为 100% 。取决于 animationo-direction 属性。</p>
<p>1、当 animationo-direction 为 normal 或者 alternate 时，第一帧就是 0% 中定义样式。<br>2、当 animation-direction 为 reverse 或者 alternate-reverse时，第一帧就时 100% 中定义样式。</p>
<p>如果为 forwards，对于等待期而言没有意义，这个是定义完成状态时元素样式，下面会细说。</p>
<p>动画执行期，指的是 delay 结束瞬间开始执行动画，一直持续到最后一帧。<br>注意最后一帧的概念也是很绕，它一定属于 @keyframes 中的 0% 或者 100% 中之一。但具体为哪一个受到 animation-direction 和 animation-iteration-count 取值影响。</p>
<p>总结：<br>1、当 animation-direction：normal 时，最后一帧总为 100% 样式，无关 animation-iteration-count。<br>2、当 animation-direction：reverse 时，最后一帧总为 0% 样式，也无关 animation-iteration-count。<br>3、当 animation-direction：alternate时，animation-iteration-count 为单数时，最后一帧 为 100%， 双数为 0%；<br>4、当 animation-direction：alternate-reverse时，animation-iteration-count 为单数时，最后一帧 为 0%， 双数为 100%；</p>
<p>完成状态，执行完最后一帧时，元素处于的状态<br>如果你理解最后一帧，就能理解完成状态。ifinite 的动画没有完成状态。<br>animation-fill-mode 取值 none。表示动画结束，元素回归初始状态，而且是瞬间回归，无动画效果。</p>
<p>animation-fill-mode 取值 forwards 或者 both。表示动画执行完最后一帧，保持在最后一帧样式。再次申明，最后一帧可能为 @keyframes 中的 0% 或者 100% 之一。</p>
<p>最后总结<br>none 表示 等待期和完成期，元素样式都为初始状态样式，不受动画定义（@keyframes）的影响。</p>
<p>both 表示 等待期样式为第一帧样式，完成期保持最后一帧样式。</p>
<p>backwards 表示等待期为第一帧样式，完成期跳转为初始样式</p>
<p>forwards 表示等待期保持初始样式，完成期间保持最后一帧样式。</p>
<h1 id="9-CSS3-filter"><a href="#9-CSS3-filter" class="headerlink" title="9.CSS3 filter"></a>9.CSS3 filter</h1><p>grayscale灰度<br>sepia褐色（求专业指点翻译）<br>saturate饱和度<br>hue-rotate色相旋转<br>invert反色<br>opacity透明度<br>brightness亮度<br>contrast对比度<br>blur模糊<br>drop-shadow阴影</p>
<p>注意: 滤镜通常使用百分比 (如：75%), 当然也可以使用小数来表示 (如：0.75)。</p>
<p>Filter    描述<br>none    默认值，没有效果。<br>blur(px)    给图像设置高斯模糊。”radius”一值设定高斯函数的标准差，或者是屏幕上以多少像素融在一起， 所以值越大越模糊；</p>
<p>如果没有设定值，则默认是0；这个参数可设置css长度值，但不接受百分比值。<br>brightness(%)    给图片应用一种线性乘法，使其看起来更亮或更暗。如果值是0%，图像会全黑。值是100%，则图像无变化。其他的值对应线性乘数效果。值超过100%也是可以的，图像会比原来更亮。如果没有设定值，默认是1。</p>
<p>contrast(%)    调整图像的对比度。值是0%的话，图像会全黑。值是100%，图像不变。值可以超过100%，意味着会运用更低的对比。若没有设置值，默认是1。</p>
<p>drop-shadow(h-shadow v-shadow blur spread color)<br>给图像设置一个阴影效果。阴影是合成在图像下面，可以有模糊度的，可以以特定颜色画出的遮罩图的偏移版本。 函数接受<shadow>(在CSS3背景中定义)类型的值，除了”inset”关键字是不允许的。该函数与已有的box-shadow box-shadow属性很相似；不同之处在于，通过滤镜，一些浏览器为了更好的性能会提供硬件加速。<shadow>参数如下：</shadow></shadow></p>
<p><offset-x> <offset-y> (必须)<br>这是设置阴影偏移量的两个 <length>值. <offset-x> 设定水平方向距离. 负值会使阴影出现在元素左边. <offset-y>设定垂直距离.负值会使阴影出现在元素上方。查看<length>可能的单位.<br>如果两个值都是0, 则阴影出现在元素正后面 (如果设置了 <blur-radius> and/or <spread-radius>，会有模糊效果).</spread-radius></blur-radius></length></offset-y></offset-x></length></offset-y></offset-x></p>
<p><blur-radius> (可选)<br>这是第三个code&gt;<length>值. 值越大，越模糊，则阴影会变得更大更淡.不允许负值 若未设定，默认是0 (则阴影的边界很锐利).</length></blur-radius></p>
<p><spread-radius> (可选)<br>这是第四个 <length>值. 正值会使阴影扩张和变大，负值会是阴影缩小.若未设定，默认是0 (阴影会与元素一样大小).<br>注意: Webkit, 以及一些其他浏览器 不支持第四个长度，如果加了也不会渲染。</length></spread-radius></p>
<p><color> (可选)<br>查看 <color>该值可能的关键字和标记。若未设定，颜色值基于浏览器。在Gecko (Firefox), Presto (Opera)和Trident (Internet Explorer)中， 会应用colorcolor属性的值。另外, 如果颜色值省略，WebKit中阴影是透明的。</color></color></p>
<p>grayscale(%)<br>将图像转换为灰度图像。值定义转换的比例。值为100%则完全转为灰度图像，值为0%图像无变化。值在0%到100%之间，则是效果的线性乘子。若未设置，值默认是0；</p>
<p>hue-rotate(deg)<br>给图像应用色相旋转。”angle”一值设定图像会被调整的色环角度值。值为0deg，则图像无变化。若值未设置，默认值是0deg。该值虽然没有最大值，超过360deg的值相当于又绕一圈。</p>
<p>invert(%)<br>反转输入图像。值定义转换的比例。100%的价值是完全反转。值为0%则图像无变化。值在0%和100%之间，则是效果的线性乘子。 若值未设置，值默认是0。</p>
<p>opacity(%)<br>转化图像的透明程度。值定义转换的比例。值为0%则是完全透明，值为100%则图像无变化。值在0%和100%之间，则是效果的线性乘子，也相当于图像样本乘以数量。 若值未设置，值默认是1。该函数与已有的opacity属性很相似，不同之处在于通过filter，一些浏览器为了提升性能会提供硬件加速。</p>
<p>saturate(%)<br>转换图像饱和度。值定义转换的比例。值为0%则是完全不饱和，值为100%则图像无变化。其他值，则是效果的线性乘子。超过100%的值是允许的，则有更高的饱和度。 若值未设置，值默认是1。</p>
<p>sepia(%)<br>将图像转换为深褐色。值定义转换的比例。值为100%则完全是深褐色的，值为0%图像无变化。值在0%到100%之间，则是效果的线性乘子。若未设置，值默认是0；</p>
<p>url()<br>URL函数接受一个XML文件，该文件设置了 一个SVG滤镜，且可以包含一个锚点来指定一个具体的滤镜元素。</p>
<p>例如：</p>
<p>filter: url(svg-url#element-id)</p>
<h1 id="10-transition"><a href="#10-transition" class="headerlink" title="10. transition"></a>10. transition</h1><p>todo</p>
]]></content>
      <categories>
        <category>css3</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript 事件冒泡和捕获</title>
    <url>/2018/11/23/JavaScript-%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E5%92%8C%E6%8D%95%E8%8E%B7/</url>
    <content><![CDATA[<p>JS事件冒泡与捕获</p>
<h1 id="1事件传播——冒泡与捕获"><a href="#1事件传播——冒泡与捕获" class="headerlink" title="1事件传播——冒泡与捕获"></a>1事件传播——冒泡与捕获</h1><p>　　默认情况下，事件使用冒泡事件流，不使用捕获事件流。然而，在Firefox和Safari里，你可以显式的指定使用捕获事件流，方法是在注册事件时传入useCapture参数，将这个参数设为true。</p>
<h1 id="2冒泡事件流"><a href="#2冒泡事件流" class="headerlink" title="2冒泡事件流"></a>2冒泡事件流</h1><p>　　当事件在某一DOM元素被触发时，例如用户在客户名字节点上点击鼠标，事件将跟随着该节点继承自的各个父节点冒泡穿过整个的DOM节点层次，直到它遇到依附有该事件类型处理器的节点，此时，该事件是onclick事件。在冒泡过程中的任何时候都可以终止事件的冒泡，在遵从W3C标准的浏览器里可以通过调用事件对象上的stopPropagation()方法，在Internet Explorer里可以通过设置事件对象的cancelBubble属性为true。如果不停止事件的传播，事件将一直通过DOM冒泡直至到达文档根。</p>
<h1 id="3捕获事件流"><a href="#3捕获事件流" class="headerlink" title="3捕获事件流"></a>3捕获事件流</h1><p>　　事件的处理将从DOM层次的根开始，而不是从触发事件的目标元素开始，事件被从目标元素的所有祖先元素依次往下传递。在这个过程中，事件会被从文档根到事件目标元素之间各个继承派生的元素所捕获，如果事件监听器在被注册时设置了useCapture属性为true,那么它们可以被分派给这期间的任何元素以对事件做出处理；否则，事件会被接着传递给派生元素路径上的下一元素，直至目标元素。事件到达目标元素后，它会接着通过DOM节点再进行冒泡。<br>复制代码<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"utf-8"</span>&gt;</span><br><span class="line">    &lt;title&gt;bubble event&lt;/title&gt;</span><br><span class="line">    &lt;style <span class="built_in">type</span>=<span class="string">"text/css"</span>&gt;</span><br><span class="line">        body&#123;margin:0;&#125;</span><br><span class="line">        <span class="comment">#one&#123;</span></span><br><span class="line">            width:500px;</span><br><span class="line">            height:300px;</span><br><span class="line">            background:rgb(255,0,0);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">#two&#123;</span></span><br><span class="line">            width:400px;</span><br><span class="line">            height:260px;</span><br><span class="line">            background:rgb(255,50,50);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">#three&#123;</span></span><br><span class="line">            width:300px;</span><br><span class="line">            height:240px;</span><br><span class="line">            background:rgb(255,100,100);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">#four&#123;</span></span><br><span class="line">            width:200px;</span><br><span class="line">            height:200px;</span><br><span class="line">            background:rgb(255,150,150);</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">'one'</span>&gt;</span><br><span class="line">      &lt;div id=<span class="string">'two'</span>&gt;</span><br><span class="line">        &lt;div id=<span class="string">'three'</span>&gt;</span><br><span class="line">          &lt;div id=<span class="string">'four'</span>&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">     </span><br><span class="line">    &lt;script&gt;</span><br><span class="line">        var one = document.getElementById(<span class="string">'one'</span>);</span><br><span class="line">        var two = document.getElementById(<span class="string">'two'</span>);</span><br><span class="line">        var three = document.getElementById(<span class="string">'three'</span>);</span><br><span class="line">        var four = document.getElementById(<span class="string">'four'</span>);</span><br><span class="line">    </span><br><span class="line">        var useCapture = <span class="literal">true</span>; //<span class="literal">false</span>为冒泡获取【目标元素先触发】    <span class="literal">true</span>为捕获获取【父级元素先触发】</span><br><span class="line">        one.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">            console.log(<span class="string">'one'</span>);</span><br><span class="line">        &#125;, useCapture);</span><br><span class="line">        two.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">            console.log(<span class="string">'two'</span>);</span><br><span class="line">        &#125;, useCapture);</span><br><span class="line">        three.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">            console.log(<span class="string">'three'</span>);</span><br><span class="line">        &#125;, useCapture);</span><br><span class="line">        four.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">            console.log(<span class="string">'four'</span>);</span><br><span class="line">        &#125;, useCapture);        </span><br><span class="line">        /*</span><br><span class="line">        <span class="literal">false</span></span><br><span class="line">        冒泡</span><br><span class="line">        点击four div</span><br><span class="line">        输出结果：four three two one        </span><br><span class="line">        </span><br><span class="line">        <span class="literal">true</span></span><br><span class="line">        捕获</span><br><span class="line">        点击four div</span><br><span class="line">        输出结果： one two three four</span><br><span class="line">        */</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">复制代码</span><br><span class="line">分析：</span><br></pre></td></tr></table></figure></p>
<p><img src="/images/pasted-6.png" alt="upload successful"><br>addEventListener第三个参数useCapture ，true时为捕获，false时为冒泡</p>
<p>冒泡从目标对象开始，向父级元素至window传递；捕获从window底层逐级至目标对象传递！</p>
<h1 id="jQuery中的事件委托方式比较丰富，就以同样的例子来说："><a href="#jQuery中的事件委托方式比较丰富，就以同样的例子来说：" class="headerlink" title="jQuery中的事件委托方式比较丰富，就以同样的例子来说："></a>jQuery中的事件委托方式比较丰富，就以同样的例子来说：</h1><p>   1、用on方法,代码如下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">复制代码</span><br><span class="line">1  $(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">2             $(<span class="string">"#lists"</span>).on(<span class="string">"click"</span>,<span class="string">"li"</span>,<span class="keyword">function</span>(event)&#123;</span><br><span class="line">3                 var target = $(event.target);</span><br><span class="line">4                 target.css(<span class="string">"background-color"</span>,<span class="string">"red"</span>);</span><br><span class="line">5             &#125;)</span><br><span class="line">6         &#125;)</span><br></pre></td></tr></table></figure></p>
<h1 id="阻止事件冒泡"><a href="#阻止事件冒泡" class="headerlink" title="阻止事件冒泡"></a>阻止事件冒泡</h1><p>jQuery 提供了两种方式来阻止事件冒泡。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">**方式一: **event.stopPropagation();</span><br><span class="line"></span><br><span class="line">$(<span class="string">"#div1"</span>).mousedown(<span class="keyword">function</span>(event)&#123;</span><br><span class="line">    event.stopPropagation();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">**方式二：**<span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">$(<span class="string">"#div1"</span>).mousedown(<span class="keyword">function</span>(event)&#123;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<font color="red">但是这两种方式是有区别的。return false 不仅阻止了事件往上冒泡，而且阻止了事件本身。event.stopPropagation() 则只阻止事件往上冒泡，不阻止事件本身。</font>

]]></content>
  </entry>
  <entry>
    <title>页面布局方式</title>
    <url>/2018/11/23/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>待学习：</p>
<h1 id="一-flex-弹性布局"><a href="#一-flex-弹性布局" class="headerlink" title="一. flex 弹性布局"></a>一. flex 弹性布局</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">        &lt;title&gt;&lt;/title&gt;</span><br><span class="line">        &lt;style <span class="built_in">type</span>=<span class="string">"text/css"</span>&gt;</span><br><span class="line">            <span class="comment">#box&#123;</span></span><br><span class="line">                display: flex;</span><br><span class="line">                display: -webkit-flex;</span><br><span class="line">                border: 1px solid <span class="comment">#0000FF;</span></span><br><span class="line">                height: 200px;</span><br><span class="line">                width: 400px;</span><br><span class="line">                align-items:center;</span><br><span class="line">                justify-content:center;</span><br><span class="line">            &#125;</span><br><span class="line">            .item&#123;</span><br><span class="line">                width: 50px;</span><br><span class="line">                height: 40px;</span><br><span class="line">                border: 1px solid <span class="comment">#00C1B3;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &lt;/style&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;div id=<span class="string">"box"</span>&gt;</span><br><span class="line">            &lt;div class=<span class="string">"item"</span>&gt;1&lt;/div&gt;</span><br><span class="line">            &lt;div class=<span class="string">"item"</span>&gt;2&lt;/div&gt;</span><br><span class="line">            &lt;div class=<span class="string">"item"</span>&gt;3&lt;/div&gt;</span><br><span class="line">            &lt;div class=<span class="string">"item"</span>&gt;4&lt;/div&gt;</span><br><span class="line">            &lt;div class=<span class="string">"item"</span>&gt;5&lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>// 4<br>.wraper {<br>  display: table;<br>  .box {<br>    display: table-cell;<br>    vertical-align: middle;<br>  }<br>}</p>
]]></content>
  </entry>
  <entry>
    <title>JavaScript 原生语法</title>
    <url>/2018/11/23/JavaScript-%E5%8E%9F%E7%94%9F%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>var anv=document.getElementsByTagName(‘body’)[0]<br>var abc=document.createElement(‘div’)</p>
<p>e.preventDefault()阻止事件默认行为。<br>e.stopPropagation()阻止事件冒泡</p>
<h1 id="屏蔽tmall的广告下载"><a href="#屏蔽tmall的广告下载" class="headerlink" title="屏蔽tmall的广告下载"></a>屏蔽tmall的广告下载</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> links=<span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;links.length;i++)&#123;  </span><br><span class="line">  <span class="keyword">if</span>( links[i].style.zIndex==<span class="string">"99999"</span>)&#123; </span><br><span class="line">     <span class="built_in">console</span>.log(links[i]); links[i].parentNode.removeChild(links[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="promise-wiki"><a href="#promise-wiki" class="headerlink" title="promise wiki"></a>promise wiki</h1><p><a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/0014345008539155e93fc16046d4bb7854943814c4f9dc2000#0" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/0014345008539155e93fc16046d4bb7854943814c4f9dc2000#0</a><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> multiply(input) &#123;</span><br><span class="line">    <span class="built_in">return</span> new Promise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">        <span class="built_in">log</span>(<span class="string">'calculating '</span> + input + <span class="string">' x '</span> + input + <span class="string">'...'</span>);</span><br><span class="line">        setTimeout(resolve, 500, input * input);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 0.5秒后返回input+input的计算结果:</span><br><span class="line"><span class="keyword">function</span> add(input) &#123;</span><br><span class="line">    <span class="built_in">return</span> new Promise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">        <span class="built_in">log</span>(<span class="string">'calculating '</span> + input + <span class="string">' + '</span> + input + <span class="string">'...'</span>);</span><br><span class="line">        setTimeout(resolve, 500, input + input);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p = new Promise(<span class="keyword">function</span> (resolve, reject) &#123;</span><br><span class="line">    <span class="built_in">log</span>(<span class="string">'start new Promise...'</span>);</span><br><span class="line">    resolve(123);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.then(multiply)</span><br><span class="line"> .<span class="keyword">then</span>(add)</span><br><span class="line"> .<span class="keyword">then</span>(multiply)</span><br><span class="line"> .<span class="keyword">then</span>(add)</span><br><span class="line"> .<span class="keyword">then</span>(<span class="keyword">function</span> (result) &#123;</span><br><span class="line">    <span class="built_in">log</span>(<span class="string">'Got value: '</span> + result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h1 id="js递归方法需要return-这个方法，不然开始调用的地方收不到这个值"><a href="#js递归方法需要return-这个方法，不然开始调用的地方收不到这个值" class="headerlink" title="js递归方法需要return 这个方法，不然开始调用的地方收不到这个值"></a>js递归方法需要return 这个方法，不然开始调用的地方收不到这个值</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.findMin=function()&#123;</span><br><span class="line">  return findMinPrivate(root);</span><br><span class="line">&#125;</span><br><span class="line">   var findMinPrivate=function(node)&#123;</span><br><span class="line">debugger;</span><br><span class="line">if(node &amp;&amp; node.left==null)&#123;</span><br><span class="line">    return node.key;</span><br><span class="line"></span><br><span class="line">&#125;else &#123;</span><br><span class="line">if(node)&#123;</span><br><span class="line">     node=node.left;</span><br><span class="line">   return findMinPrivate(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>
<h1 id="这是函数栈-然后想象一下，每次去把执行的函数压栈，执行完毕再出栈。"><a href="#这是函数栈-然后想象一下，每次去把执行的函数压栈，执行完毕再出栈。" class="headerlink" title="这是函数栈,然后想象一下，每次去把执行的函数压栈，执行完毕再出栈。"></a>这是函数栈,然后想象一下，每次去把执行的函数压栈，执行完毕再出栈。</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo(i) &#123;</span><br><span class="line">  if (i &lt; 0)</span><br><span class="line">  return;</span><br><span class="line">  console.log(&apos;begin:&apos; + i);</span><br><span class="line">  foo(i - 1);</span><br><span class="line">  console.log(&apos;end:&apos; + i);</span><br><span class="line">&#125;</span><br><span class="line">foo(3);</span><br></pre></td></tr></table></figure>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>#示例二展示了一个我们工作中常见的场景，我们预期的值应该是0,1,2..实际结果都输出了最后一次循环的值。原因是这里的i我们是在window下声明可以，当我们调用funs数组中的方法时，循环已经结束i的值已经变成了5。们可以用闭包来解决这个问题：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> funs = []</span><br><span class="line"><span class="keyword">var</span> i=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span>(; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> <span class="title">parent</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">        funs.push(<span class="function"><span class="keyword">function</span> <span class="title">child</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(i)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)(i)</span><br><span class="line">&#125;</span><br><span class="line">funs[<span class="number">0</span>]() <span class="comment">// 0</span></span><br><span class="line">funs[<span class="number">1</span>]() <span class="comment">// 1</span></span><br><span class="line">funs[<span class="number">2</span>]() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p>
<p>我们声明了一个parent函数并立即调用了它，把i当做参数传入作为parent的部变量，并在child函数中调用i形成了一个闭包。</p>
<h1 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h1><p>（1）为对象添加方法</p>
<p>Object.assign(SomeClass.prototype, {<br>  someMethod(arg1, arg2) {<br>    ···<br>  },<br>  anotherMethod() {<br>    ···<br>  }<br>});</p>
<p>// 等同于下面的写法<br>SomeClass.prototype.someMethod = function (arg1, arg2) {<br>  ···<br>};<br>SomeClass.prototype.anotherMethod = function () {<br>  ···<br>};<br>上面代码使用了对象属性的简洁表示法，直接将两个函数放在大括号中，再使用assign方法添加到SomeClass.prototype之中。</p>
<p>（2）不过，采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。</p>
<p>function clone(origin) {<br>  let originProto = Object.getPrototypeOf(origin);<br>  return Object.assign(Object.create(originProto), origin);<br>}</p>
]]></content>
  </entry>
  <entry>
    <title>react 生命周期</title>
    <url>/2018/11/21/react-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h1 id="react-生命周期函数"><a href="#react-生命周期函数" class="headerlink" title="react 生命周期函数"></a>react 生命周期函数</h1><p>初始化阶段：</p>
<p>getDefaultProps:获取实例的默认属性</p>
<p>getInitialState:获取每个实例的初始化状态</p>
<p>componentWillMount：组件即将被装载、渲染到页面上</p>
<p>render:组件在这里生成虚拟的 DOM 节点</p>
<p>componentDidMount:组件真正在被装载之后</p>
<p>运行中状态：</p>
<p>componentWillReceiveProps:组件将要接收到属性的时候调用</p>
<p>shouldComponentUpdate:组件接受到新属性或者新状态的时候（可以返回 false，接收数据后不更新，阻止 render 调用，后面的函数不会被继续执行了）</p>
<p>componentWillUpdate:组件即将更新不能修改属性和状态</p>
<p>render:组件重新描绘</p>
<p>componentDidUpdate:组件已经更新</p>
<p>销毁阶段：</p>
<p>componentWillUnmount:组件即将销毁</p>
<h1 id="shouldComponentUpdate-是做什么的，（react-性能优化是哪个周期函数？）"><a href="#shouldComponentUpdate-是做什么的，（react-性能优化是哪个周期函数？）" class="headerlink" title="shouldComponentUpdate 是做什么的，（react 性能优化是哪个周期函数？）"></a>shouldComponentUpdate 是做什么的，（react 性能优化是哪个周期函数？）</h1><p>shouldComponentUpdate 这个方法用来判断是否需要调用 render 方法重新描绘 dom。因为 dom 的描绘非常消耗性能，如果我们能在 shouldComponentUpdate 方法中能够写出更优化的 dom diff 算法，可以极大的提高性能。</p>
<p>参考react 性能优化-sf</p>
<h1 id="为什么虚拟-dom-会提高性能-必考"><a href="#为什么虚拟-dom-会提高性能-必考" class="headerlink" title="为什么虚拟 dom 会提高性能?(必考)"></a>为什么虚拟 dom 会提高性能?(必考)</h1><p>虚拟 dom 相当于在 js 和真实 dom 中间加了一个缓存，利用 dom diff 算法避免了没有必要的 dom 操作，从而提高性能。</p>
<p>用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异把 2 所记录的差异应用到步骤 1 所构建的真正的 DOM 树上，视图就更新了。</p>
<p>参考 如何理解虚拟 DOM?-zhihu</p>
<h1 id="react-diff-原理（常考，大厂必考）"><a href="#react-diff-原理（常考，大厂必考）" class="headerlink" title="react diff 原理（常考，大厂必考）"></a>react diff 原理（常考，大厂必考）</h1><p>把树形结构按照层级分解，只比较同级元素。</p>
<p>给列表结构的每个单元添加唯一的 key 属性，方便比较。</p>
<p>React 只会匹配相同 class 的 component（这里面的 class 指的是组件的名字）</p>
<p>合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty.到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制.</p>
<p>选择性子树渲染。开发人员可以重写 shouldComponentUpdate 提高 diff 的性能。</p>
<p>参考：React 的 diff 算法</p>
<h1 id="箭头函数设置-onClick事件"><a href="#箭头函数设置-onClick事件" class="headerlink" title="箭头函数设置 onClick事件"></a>箭头函数设置 onClick事件</h1><p><img src="/images/pasted-5.png" alt="upload successful"></p>
<h1 id="“React-connect-和-shouldComponentUpdate”-组件更新1次"><a href="#“React-connect-和-shouldComponentUpdate”-组件更新1次" class="headerlink" title="“React connect 和 shouldComponentUpdate” 组件更新1次"></a>“React connect 和 shouldComponentUpdate” 组件更新1次</h1><p>首先，因为connect使用的是HOC模式，所以他基本控制了你组件S的渲染。</p>
<p>其次，在connect中，每次父级传入的props发生改变的时候，都会经过一次shallow equal再决定是否有必要渲染S组件。</p>
<p>最后，虽然你的父组件Content的state发生了改变，但是传入S的props没有发生改变，所以在connect中被拦截，所以组件S就没有渲染。</p>
]]></content>
  </entry>
  <entry>
    <title>记一次大促页面性能优化</title>
    <url>/2018/11/13/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%A4%A7%E4%BF%83%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="原始问题：使用iPhone在两个大促模板，通过-前进返回操作-来回点击次数过多，就会出现cpu暴涨到99-的情况，导致应用直接黑屏闪退"><a href="#原始问题：使用iPhone在两个大促模板，通过-前进返回操作-来回点击次数过多，就会出现cpu暴涨到99-的情况，导致应用直接黑屏闪退" class="headerlink" title="原始问题：使用iPhone在两个大促模板，通过 前进返回操作 来回点击次数过多，就会出现cpu暴涨到99%的情况，导致应用直接黑屏闪退"></a>原始问题：使用iPhone在两个大促模板，通过 前进<->返回操作 来回点击次数过多，就会出现cpu暴涨到99%的情况，导致应用直接黑屏闪退</-></h1><p>原因分析：iOS使用的是UIWebview，经过查询和测试，发现进入页面并立即返回上一页时，当前页面的代码逻辑（如alert、innerHTML等操作）仍在执行，频繁切换页面会可能导致网页占用的内存和CPU资源占用未被释放，进一步导致应用直接闪退</p>
<p>测试步骤：</p>
<p>本地新增两个测试页面test1.html和test2.html，启动一个本地服务器，并保证路由能够访问到两个测试页面（切换到对应文件目录，php -S localhost:9999 ），由于APP网页存在白名单，需要使用nginx配置一下代理<br>在测试页面导入客户端协议代码，支持使用客户端协议loadpage，编写逻辑代码，保证能从test1.html点击跳转到test2.html<br>频繁操作：test1.html点击跳转到test2.html -&gt; test2.hteml点击左上角返回按钮返回test1.html -&gt; test1.html点击跳转到test2.html<br>在test2.html页面足够简单的情况下，重复操作不会导致应用崩溃，可以在test2页面编写一下代码，返回足够快时可以在test1.html看见test2.html的弹窗执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">      alert(<span class="string">'alert from test2.html'</span>)</span><br><span class="line">&#125;, 1000);</span><br><span class="line">在test2.html页面编写渲染逻辑代码，模拟大促模板渲染逻辑</span><br><span class="line"></span><br><span class="line">// 每个模块每个deal的模板字符串</span><br><span class="line">var html = `&lt;div class=<span class="string">"deal module-item"</span> data-exposure=<span class="string">"313"</span> data-hit-type=<span class="string">"0"</span> data-dealid=<span class="string">"52046201"</span> data-zid=<span class="string">"ze181022124027966415"</span></span><br><span class="line">        data-type=<span class="string">"1"</span> data-goods-type=<span class="string">"6"</span> data-deal-type=<span class="string">"1"</span> data-begintime=<span class="string">"1541865600000"</span> data-endtime=<span class="string">"1542124799000"</span></span><br><span class="line">        data-offline=<span class="string">"1"</span> data-sellerid=<span class="string">"data-item-index=&amp;quot;1&amp;quot;"</span>&gt;</span><br><span class="line">        &lt;div class=<span class="string">"container"</span>&gt;</span><br><span class="line">            &lt;div class=<span class="string">"image"</span>&gt;</span><br><span class="line">                &lt;div class=<span class="string">"image-fade-in-viewer image-load-fade-in"</span> style=<span class="string">"opacity: 1; background-image: url(&amp;quot;https://z13.tuanimg.com/imagev2/trade/800x800.27859ac926bfe89888fe12750d7b4b2a.310x310.jpg&amp;quot;);"</span>&gt;&lt;/div&gt;</span><br><span class="line">                &lt;img class=<span class="string">"image-fade-in-loader"</span> src=<span class="string">"https://z13.tuanimg.com/imagev2/trade/800x800.27859ac926bfe89888fe12750d7b4b2a.310x310.jpg"</span></span><br><span class="line">                    style=<span class="string">"display: none;"</span>&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">            &lt;div class=<span class="string">"detail"</span>&gt;</span><br><span class="line">                &lt;h4 class=<span class="string">"title"</span>&gt;慵懒风毛衣2018秋冬季新款韩版宽松长袖羊毛毛衣纯色针织衫女潮&lt;/h4&gt;</span><br><span class="line">                &lt;p class=<span class="string">"price"</span>&gt;&lt;em&gt;52&lt;/em&gt;&lt;i&gt;398&lt;/i&gt;&lt;/p&gt; &lt;span class=<span class="string">"buy-now"</span> role=<span class="string">"button"</span>&gt;立即抢购 &amp;gt;&lt;/span&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;`;</span><br><span class="line">// 页面上配置了30个模块容器</span><br><span class="line">var <span class="variable">$modules</span> = $(<span class="string">".user-module"</span>);</span><br><span class="line">var repeatTime = 200;</span><br><span class="line"><span class="variable">$modules</span>.each(<span class="keyword">function</span> (index) &#123;</span><br><span class="line">    var element = $(this);</span><br><span class="line">    var rows = []</span><br><span class="line">    <span class="keyword">for</span> (var i = 0; i &lt; repeatTime; ++i) &#123;</span><br><span class="line">        rows.push(html)</span><br><span class="line">    &#125;</span><br><span class="line">    // 同大促模板使用innerHTML，插入拼接后的模块字符串</span><br><span class="line">    element.html(rows.join(<span class="string">''</span>));</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>再次进行频繁操作，就会复现上述闪退问题，可以通过调整$modules的数量，以及repeatTime(每个模块下deal的数量)来修改页面渲染的复杂度，数字越大则越容易出现闪退</p>
<p>经过上述分析和测试步骤，初步得出结论 ：在运营配置的模板页面过于复杂时（如模块过多，deal数量过多时），在切换到上一页时，由于webview容器没有及时释放web页面的资源，导致CPU及内存占用过高，导致页面闪退，CPU的资源占用点有</p>
<p>innerHTML，innerHTML会创建一个HTML解析器，效率高于手动调用createElement等方法，效率提升带来的问题是需要消耗大量的CPU，这在需要解析的html字符串过长时更为明显<br>每个模块的渲染都是等待接口返回，异步执行渲染的，可能存在在某个时间段内，多个模块连续调用innerHTML的情况，导致CPU占用时间过长；此外还会导致页面频繁的reflow等操作</p>
<p>查阅现在的大促模板渲染代码(/statics/activity/common/lib/render_modules.js)发现，对应的渲染代码是</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var <span class="variable">$modules</span> = $(<span class="string">'.user-module, .public-module'</span>, container);</span><br><span class="line"><span class="variable">$modules</span>.forEach(<span class="keyword">function</span> (element) &#123;</span><br><span class="line">    // ...</span><br><span class="line">    <span class="keyword">if</span> (moduleName) &#123;</span><br><span class="line">        var module;</span><br><span class="line">        try &#123;</span><br><span class="line">            module = requireModule(<span class="string">'statics/activity/modules/'</span> + moduleName + <span class="string">'/'</span> + styleCodeName + <span class="string">'.js'</span>);</span><br><span class="line">        &#125; catch (error) &#123;</span><br><span class="line">            console.error(error);</span><br><span class="line">        &#125;</span><br><span class="line">        element.rendered = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (typeof module === <span class="string">'function'</span>) &#123;</span><br><span class="line">            module.call(window.activitySettings, element, id ? moduleData[id] : null);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>会遍历模块并加载对应的模块渲染函数，所有模块的逻辑函数都是同步执行的，在需要deal详细数据的接口会先调用Deal.load方法请求数据，并在回调中处理模块的渲染逻辑，调用innerHTML渲染到页面上。</p>
<p>此处可以优化为：通过节流函数控制每个模块的渲染间隔，页面靠后的模块间隔一定时间后再执行加载渲染逻辑，这样可以避免同一时间多个网络请求发出，并在某个很短的间隔内同时处理多个模块的渲染逻辑，错开innerHTML的渲染高峰期。</p>
<p>此外，在进入页面就立即离开的频繁操作中，取消掉未完成渲染模块的请求和渲染（通过$.calljs.goback注册原生方法），可以节省相关资源的浪费</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var isRendering = <span class="literal">true</span>;</span><br><span class="line">// 离开页面时修改标志符，清空当前页面，释放内存</span><br><span class="line">$.calljs.goback = <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    isRendering = <span class="literal">false</span>;</span><br><span class="line">    document.body.innerHTML = <span class="string">''</span>;</span><br><span class="line">    <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$modules</span>.each(<span class="keyword">function</span> (index) &#123;</span><br><span class="line">    var element = $(this);</span><br><span class="line">    <span class="keyword">function</span> <span class="function"><span class="title">render</span></span>()&#123;</span><br><span class="line">        module.call(window.activitySettings, element, id ? moduleData[id] : null);</span><br><span class="line">    &#125;</span><br><span class="line">    // 首屏元素仍旧保持同步渲染</span><br><span class="line">    <span class="keyword">if</span> (index &lt; 3) &#123;</span><br><span class="line">        render()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            // 如果离开页面，则不进行后续模块的渲染</span><br><span class="line">            <span class="keyword">if</span> (isRendering) &#123;</span><br><span class="line">                render()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, index * 100);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="优先使用渲染层合并属性"><a href="#优先使用渲染层合并属性" class="headerlink" title="优先使用渲染层合并属性"></a>优先使用渲染层合并属性</h1><p>渲染层的合并，就是把页面中完成了绘制过程的部分合并成一层，然后显示在屏幕上。</p>
<p>使用transform/opacity来实现动画效果，目前只有transforms和opacity这两个属性不会触发浏览器的布局和绘制，对网页元素这两个属性的修改会直接触发渲染层合并。</p>
<h1 id="优化JavaScript的执行效率"><a href="#优化JavaScript的执行效率" class="headerlink" title="优化JavaScript的执行效率"></a>优化JavaScript的执行效率</h1><p>对于动画效果的实现，避免使用setTimeout或setInterval，请使用requestAnimationFrame。</p>
<p>把耗时长的JavaScript代码放到Web Workers中去做。</p>
<p>这里可以使用Chrome DevTools的Timeline和JavaScript Profiler来分析JavaScript的性能。</p>
]]></content>
  </entry>
  <entry>
    <title>屏幕height width 获取</title>
    <url>/2018/11/12/%E5%B1%8F%E5%B9%95height-width-%E8%8E%B7%E5%8F%96/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">网页可见区域宽： document.body.clientWidth</span><br><span class="line">网页可见区域高： document.body.clientHeight</span><br><span class="line">网页可见区域宽： document.body.offsetWidth (包括边线的宽)</span><br><span class="line">网页可见区域高： document.body.offsetHeight (包括边线的高)</span><br><span class="line">网页正文全文宽： document.body.scrollWidth</span><br><span class="line">网页正文全文高： document.body.scrollHeight</span><br><span class="line">网页被卷去的高： document.body.scrollTop</span><br><span class="line">网页被卷去的左： document.body.scrollLeft</span><br><span class="line">网页正文部分上： window.screenTop</span><br><span class="line">网页正文部分左： window.screenLeft</span><br><span class="line">屏幕分辨率的高： window.screen.height</span><br><span class="line">屏幕分辨率的宽： window.screen.width</span><br><span class="line">屏幕可用工作区高度： window.screen.availHeight</span><br><span class="line">屏幕可用工作区宽度： window.screen.availWidth</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">JQuery:</span><br><span class="line">$(document).ready(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">alert($(window).height()); //浏览器当前窗口可视区域高度</span><br><span class="line">alert($(document).height()); //浏览器当前窗口文档的高度</span><br><span class="line">alert($(document.body).height());//浏览器当前窗口文档body的高度</span><br><span class="line">alert($(document.body).outerHeight(<span class="literal">true</span>));//浏览器当前窗口文档body的总高度 包括border padding margin</span><br><span class="line"></span><br><span class="line">alert($(window).width()); //浏览器当前窗口可视区域宽度</span><br><span class="line">alert($(document).width());//浏览器当前窗口文档对象宽度</span><br><span class="line">alert($(document.body).width());//浏览器当前窗口文档body的宽度</span><br><span class="line">alert($(document.body).outerWidth(<span class="literal">true</span>));//浏览器当前窗口文档body的总宽度 包括border padding margin</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 网页被卷起来的高度/宽度（即浏览器滚动条滚动后隐藏的页面内容高度）</span><br><span class="line"></span><br><span class="line">(javascript)        document.documentElement.scrollTop //firefox，chrome</span><br><span class="line"></span><br><span class="line">(javascript)        document.documentElement.scrollLeft //firefox，chrome </span><br><span class="line"></span><br><span class="line">(javascript)        document.body.scrollTop //IE</span><br><span class="line"></span><br><span class="line">(javascript)        document.body.scrollLeft //IE</span><br><span class="line"></span><br><span class="line">(jqurey)             $(window).scrollTop() </span><br><span class="line"></span><br><span class="line">(jqurey)             $(window).scrollLeft()</span><br><span class="line"></span><br><span class="line"> 网页工作区域的高度和宽度  </span><br><span class="line"></span><br><span class="line">(javascript)       document.documentElement.clientHeight// IE firefox       </span><br><span class="line"></span><br><span class="line">(jqurey)             $(window).height()</span><br><span class="line"></span><br><span class="line"> 元素距离文档顶端和左边的偏移值  </span><br><span class="line"></span><br><span class="line">(javascript)        document.documentElement.offsetTop //IE firefox</span><br><span class="line"></span><br><span class="line">(javascript)        document.documentElement.offsetLeft //IE firefox</span><br><span class="line"></span><br><span class="line">(jqurey)             jq对象.offset().top</span><br><span class="line"></span><br><span class="line">(jqurey)             jq对象.offset().left</span><br><span class="line"></span><br><span class="line">获取页面元素距离浏览器工作区顶端的距离</span><br><span class="line"> 页面元素距离浏览器工作区顶端的距离  =  元素距离文档顶端偏移值  -   网页被卷起来的高度  </span><br><span class="line"></span><br><span class="line">即：</span><br><span class="line"></span><br><span class="line"> 页面元素距离浏览器工作区顶端的距离 =  document.documentElement.offsetTop  -  document.documentElement.scrollTop</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>抖动节流函数</title>
    <url>/2018/11/09/%E6%8A%96%E5%8A%A8%E8%8A%82%E6%B5%81%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>【前端性能】高性能滚动 scroll 及页面渲染优化<br>最近在研究页面渲染及web动画的性能问题，以及拜读《CSS SECRET》（CSS揭秘）这本大作。</p>
<p>本文主要想谈谈页面优化之滚动优化。</p>
<p>主要内容包括了为何需要优化滚动事件，滚动与页面渲染的关系，节流与防抖，pointer-events:none 优化滚动。因为本文涉及了很多很多基础，可以对照上面的知识点，选择性跳到相应地方阅读。</p>
<p>滚动优化的由来<br>滚动优化其实也不仅仅指滚动（scroll 事件），还包括了例如 resize 这类会频繁触发的事件。简单的看看：</p>
<p>var i = 0;<br>window.addEventListener(‘scroll’,function(){<br>    console.log(i++);<br>},false);<br>输出如下：</p>
<p>在绑定 scroll 、resize 这类事件时，当它发生时，它被触发的频次非常高，间隔很近。如果事件中涉及到大量的位置计算、DOM 操作、元素重绘等工作且这些工作无法在下一个 scroll 事件触发前完成，就会造成浏览器掉帧。加之用户鼠标滚动往往是连续的，就会持续触发 scroll 事件导致掉帧扩大、浏览器 CPU 使用率增加、用户体验受到影响。</p>
<p>在滚动事件中绑定回调应用场景也非常多，在图片的懒加载、下滑自动加载数据、侧边浮动导航栏等中有着广泛的应用。</p>
<p>当用户浏览网页时，拥有平滑滚动经常是被忽视但却是用户体验中至关重要的部分。当滚动表现正常时，用户就会感觉应用十分流畅，令人愉悦，反之，笨重不自然卡顿的滚动，则会给用户带来极大不舒爽的感觉。</p>
<p>滚动与页面渲染的关系<br>为什么滚动事件需要去优化？因为它影响了性能。那它影响了什么性能呢？额……这个就要从页面性能问题由什么决定说起。</p>
<p>我觉得搞技术一定要追本溯源，不要看到别人一篇文章说滚动事件会导致卡顿并说了一堆解决方案优化技巧就如获至宝奉为圭臬，我们需要的不是拿来主义而是批判主义，多去源头看看。</p>
<p>从问题出发，一步一步寻找到最后，就很容易找到问题的症结所在，只有这样得出的解决方法才容易记住。</p>
<p>说教了一堆废话，不喜欢的直接忽略哈，回到正题，要找到优化的入口就要知道问题出在哪里，对于页面优化而言，那么我们就要知道页面的渲染原理：</p>
<p>浏览器渲染原理我在我上一篇文章里也要详细的讲到，不过更多的是从动画渲染的角度去讲的：【Web动画】CSS3 3D 行星运转 &amp;&amp; 浏览器渲染原理 。</p>
<p>想了想，还是再简单的描述下，我发现每次 review 这些知识点都有新的收获，这次换一张图，以 chrome 为例子，一个 Web 页面的展示，简单来说可以认为经历了以下下几个步骤：</p>
<p>JavaScript：一般来说，我们会使用 JavaScript 来实现一些视觉变化的效果。比如做一个动画或者往页面里添加一些 DOM 元素等。</p>
<p>Style：计算样式，这个过程是根据 CSS 选择器，对每个 DOM 元素匹配对应的 CSS 样式。这一步结束之后，就确定了每个 DOM 元素上该应用什么 CSS 样式规则。</p>
<p>Layout：布局，上一步确定了每个 DOM 元素的样式规则，这一步就是具体计算每个 DOM 元素最终在屏幕上显示的大小和位置。web 页面中元素的布局是相对的，因此一个元素的布局发生变化，会联动地引发其他元素的布局发生变化。比如，<body> 元素的宽度的变化会影响其子元素的宽度，其子元素宽度的变化也会继续对其孙子元素产生影响。因此对于浏览器来说，布局过程是经常发生的。</body></p>
<p>Paint：绘制，本质上就是填充像素的过程。包括绘制文字、颜色、图像、边框和阴影等，也就是一个 DOM 元素所有的可视效果。一般来说，这个绘制过程是在多个层上完成的。</p>
<p>Composite：渲染层合并，由上一步可知，对页面中 DOM 元素的绘制是在多个层上进行的。在每个层上完成绘制过程之后，浏览器会将所有层按照合理的顺序合并成一个图层，然后显示在屏幕上。对于有位置重叠的元素的页面，这个过程尤其重要，因为一旦图层的合并顺序出错，将会导致元素显示异常。</p>
<p>这里又涉及了层（GraphicsLayer）的概念，GraphicsLayer 层是作为纹理(texture)上传给 GPU 的，现在经常能看到说 GPU 硬件加速，就和所谓的层的概念密切相关。但是和本文的滚动优化相关性不大，有兴趣深入了解的可以自行 google 更多。</p>
<p>简单来说，网页生成的时候，至少会渲染（Layout+Paint）一次。用户访问的过程中，还会不断重新的重排（reflow）和重绘（repaint）。</p>
<p>其中，用户 scroll 和 resize 行为（即是滑动页面和改变窗口大小）会导致页面不断的重新渲染。</p>
<p>当你滚动页面时，浏览器可能会需要绘制这些层(有时也被称为合成层)里的一些像素。通过元素分组，当某个层的内容改变时，我们只需要更新该层的结构，并仅仅重绘和栅格化渲染层结构里变化的那一部分，而无需完全重绘。显然，如果当你滚动时，像视差网站(戳我看看)这样有东西在移动时，有可能在多层导致大面积的内容调整，这会导致大量的绘制工作。</p>
<p>   防抖（Debouncing）和节流（Throttling）<br>scroll 事件本身会触发页面的重新渲染，同时 scroll 事件的 handler 又会被高频度的触发, 因此事件的 handler 内部不应该有复杂操作，例如 DOM 操作就不应该放在事件处理中。</p>
<p>针对此类高频度触发事件问题（例如页面 scroll ，屏幕 resize，监听用户输入等），下面介绍两种常用的解决方法，防抖和节流。</p>
<p>防抖（Debouncing）<br>防抖技术即是可以把多个顺序地调用合并成一次，也就是在一定时间内，规定事件被触发的次数。</p>
<p>通俗一点来说，看看下面这个简化的例子：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 简单的防抖动函数</span><br><span class="line"><span class="keyword">function</span> debounce(func, <span class="built_in">wait</span>, immediate) &#123;</span><br><span class="line">    // 定时器变量</span><br><span class="line">    var timeout;</span><br><span class="line">    <span class="built_in">return</span> <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        // 每次触发 scroll handler 时先清除定时器</span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        // 指定 xx ms 后触发真正想进行的操作 handler</span><br><span class="line">        timeout = setTimeout(func, <span class="built_in">wait</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">// 实际想绑定在 scroll 事件上的 handler</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">realFunc</span></span>()&#123;</span><br><span class="line">    console.log(<span class="string">"Success"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// 采用了防抖动</span><br><span class="line">window.addEventListener(<span class="string">'scroll'</span>,debounce(realFunc,500));</span><br><span class="line">// 没采用防抖动</span><br><span class="line">window.addEventListener(<span class="string">'scroll'</span>,realFunc);</span><br><span class="line">上面简单的防抖的例子可以拿到浏览器下试一下，大概功能就是如果 500ms 内没有连续触发两次 scroll 事件，那么才会触发我们真正想在 scroll 事件中触发的函数。</span><br><span class="line"></span><br><span class="line">上面的示例可以更好的封装一下：</span><br><span class="line"></span><br><span class="line">// 防抖动函数</span><br><span class="line"><span class="keyword">function</span> debounce(func, <span class="built_in">wait</span>, immediate) &#123;</span><br><span class="line">    var timeout;</span><br><span class="line">    <span class="built_in">return</span> <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        var context = this, args = arguments;</span><br><span class="line">        var later = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">            timeout = null;</span><br><span class="line">            <span class="keyword">if</span> (!immediate) func.apply(context, args);</span><br><span class="line">        &#125;;</span><br><span class="line">        var callNow = immediate &amp;&amp; !timeout;</span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        timeout = setTimeout(later, <span class="built_in">wait</span>);</span><br><span class="line">        <span class="keyword">if</span> (callNow) func.apply(context, args);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">var myEfficientFn = debounce(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    // 滚动中的真正的操作</span><br><span class="line">&#125;, 250);</span><br><span class="line"> </span><br><span class="line">// 绑定监听</span><br><span class="line">window.addEventListener(<span class="string">'resize'</span>, myEfficientFn);</span><br></pre></td></tr></table></figure></p>
<p>节流（Throttling）<br>防抖函数确实不错，但是也存在问题，譬如图片的懒加载，我希望在下滑过程中图片不断的被加载出来，而不是只有当我停止下滑时候，图片才被加载出来。又或者下滑时候的数据的 ajax 请求加载也是同理。</p>
<p>这个时候，我们希望即使页面在不断被滚动，但是滚动 handler 也可以以一定的频率被触发（譬如 250ms 触发一次），这类场景，就要用到另一种技巧，称为节流函数（throttling）。</p>
<p>节流函数，只允许一个函数在 X 毫秒内执行一次。</p>
<p>与防抖相比，节流函数最主要的不同在于它保证在 X 毫秒内至少执行一次我们希望触发的事件 handler。</p>
<p>与防抖相比，节流函数多了一个 mustRun 属性，代表 mustRun 毫秒内，必然会触发一次 handler ，同样是利用定时器，看看简单的示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 简单的节流函数</span><br><span class="line"><span class="keyword">function</span> throttle(func, <span class="built_in">wait</span>, mustRun) &#123;</span><br><span class="line">    var timeout,</span><br><span class="line">        startTime = new Date();</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">return</span> <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        var context = this,</span><br><span class="line">            args = arguments,</span><br><span class="line">            curTime = new Date();</span><br><span class="line"> </span><br><span class="line">        clearTimeout(timeout);</span><br><span class="line">        // 如果达到了规定的触发时间间隔，触发 handler</span><br><span class="line">        <span class="keyword">if</span>(curTime - startTime &gt;= mustRun)&#123;</span><br><span class="line">            func.apply(context,args);</span><br><span class="line">            startTime = curTime;</span><br><span class="line">        // 没达到触发间隔，重新设定定时器</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            timeout = setTimeout(func, <span class="built_in">wait</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">// 实际想绑定在 scroll 事件上的 handler</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">realFunc</span></span>()&#123;</span><br><span class="line">    console.log(<span class="string">"Success"</span>);</span><br><span class="line">&#125;</span><br><span class="line">// 采用了节流函数</span><br><span class="line">window.addEventListener(<span class="string">'scroll'</span>,throttle(realFunc,500,1000));</span><br></pre></td></tr></table></figure>
<p>throttle(realFunc,500,1000)的调用相当于var fn=throttle(realFunc,500,1000)；对fn引用调用</p>
<p>上面简单的节流函数的例子可以拿到浏览器下试一下，大概功能就是如果在一段时间内 scroll 触发的间隔一直短于 500ms ，那么能保证事件我们希望调用的 handler 至少在 1000ms 内会触发一次。</p>
<p>使用 rAF（requestAnimationFrame）触发滚动事件<br>上面介绍的抖动与节流实现的方式都是借助了定时器 setTimeout ，但是如果页面只需要兼容高版本浏览器或应用在移动端，又或者页面需要追求高精度的效果，那么可以使用浏览器的原生方法 rAF（requestAnimationFrame）。</p>
<p>requestAnimationFrame<br>window.requestAnimationFrame() 这个方法是用来在页面重绘之前，通知浏览器调用一个指定的函数。这个方法接受一个函数为参，该函数会在重绘前调用。</p>
<p>rAF 常用于 web 动画的制作，用于准确控制页面的帧刷新渲染，让动画效果更加流畅，当然它的作用不仅仅局限于动画制作，我们可以利用它的特性将它视为一个定时器。（当然它不是定时器）</p>
<p>通常来说，rAF 被调用的频率是每秒 60 次，也就是 1000/60 ，触发频率大概是 16.7ms 。（当执行复杂操作时，当它发现无法维持 60fps 的频率时，它会把频率降低到 30fps 来保持帧数的稳定。）</p>
<p>简单而言，使用 requestAnimationFrame 来触发滚动事件，相当于上面的：</p>
<p>throttle(func, xx, 1000/60) //xx 代表 xx ms内不会重复触发事件 handler<br>简单的示例如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var ticking = <span class="literal">false</span>; // rAF 触发锁</span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">onScroll</span></span>()&#123;</span><br><span class="line">  <span class="keyword">if</span>(!ticking) &#123;</span><br><span class="line">    requestAnimationFrame(realFunc);</span><br><span class="line">    ticking = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">realFunc</span></span>()&#123;</span><br><span class="line">    // <span class="keyword">do</span> something...</span><br><span class="line">    console.log(<span class="string">"Success"</span>);</span><br><span class="line">    ticking = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">// 滚动事件监听</span><br><span class="line">window.addEventListener(<span class="string">'scroll'</span>, onScroll, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>上面简单的使用 rAF 的例子可以拿到浏览器下试一下，大概功能就是在滚动的过程中，保持以 16.7ms 的频率触发事件 handler。</p>
<p>使用 requestAnimationFrame 优缺点并存，首先我们不得不考虑它的兼容问题，其次因为它只能实现以 16.7ms 的频率来触发，代表它的可调节性十分差。但是相比 throttle(func, xx, 16.7) ，用于更复杂的场景时，rAF 可能效果更佳，性能更好。</p>
<p>总结一下 </p>
<p>防抖动：防抖技术即是可以把多个顺序地调用合并成一次，也就是在一定时间内，规定事件被触发的次数。</p>
<p>节流函数：只允许一个函数在 X 毫秒内执行一次，只有当上一次函数执行后过了你规定的时间间隔，才能进行下一次该函数的调用。</p>
<p>rAF：16.7ms 触发一次 handler，降低了可控性，但是提升了性能和精确度。</p>
<p>   简化 scroll 内的操作<br>上面介绍的方法都是如何去优化 scroll 事件的触发，避免 scroll 事件过度消耗资源的。</p>
<p>但是从本质上而言，我们应该尽量去精简 scroll 事件的 handler ，将一些变量的初始化、不依赖于滚动位置变化的计算等都应当在 scroll 事件外提前就绪。</p>
<p>建议如下：</p>
<p>避免在scroll 事件中修改样式属性 / 将样式操作从 scroll 事件中剥离</p>
<p>输入事件处理函数，比如 scroll / touch 事件的处理，都会在 requestAnimationFrame 之前被调用执行。</p>
<p>因此，如果你在 scroll 事件的处理函数中做了修改样式属性的操作，那么这些操作会被浏览器暂存起来。然后在调用 requestAnimationFrame 的时候，如果你在一开始做了读取样式属性的操作，那么这将会导致触发浏览器的强制同步布局。</p>
<p>   滑动过程中尝试使用 pointer-events: none 禁止鼠标事件<br>大部分人可能都不认识这个属性，嗯，那么它是干什么用的呢？</p>
<p>pointer-events 是一个 CSS 属性，可以有多个不同的值，属性的一部分值仅仅与 SVG 有关联，这里我们只关注 pointer-events: none 的情况，大概的意思就是禁止鼠标行为，应用了该属性后，譬如鼠标点击，hover 等功能都将失效，即是元素不会成为鼠标事件的 target。</p>
<p>可以就近 F12 打开开发者工具面板，给 <body> 标签添加上 pointer-events: none 样式，然后在页面上感受下效果，发现所有鼠标事件都被禁止了。</body></p>
<p>那么它有什么用呢？</p>
<p>pointer-events: none 可用来提高滚动时的帧频。的确，当滚动时，鼠标悬停在某些元素上，则触发其上的 hover 效果，然而这些影响通常不被用户注意，并多半导致滚动出现问题。对 body 元素应用 pointer-events: none ，禁用了包括 hover 在内的鼠标事件，从而提高滚动性能。</p>
<p>.disable-hover {<br>    pointer-events: none;<br>}<br>大概的做法就是在页面滚动的时候, 给 <body> 添加上 .disable-hover 样式，那么在滚动停止之前, 所有鼠标事件都将被禁止。当滚动结束之后，再移除该属性。</body></p>
<p>可以查看这个 demo 页面。</p>
<p>上面说 pointer-events: none 可用来提高滚动时的帧频 的这段话摘自 pointer-events-MDN ，还专门有文章讲解过这个技术：</p>
<p>使用pointer-events:none实现60fps滚动 。</p>
<p>这就完了吗？没有，张鑫旭有一篇专门的文章，用来探讨 pointer-events: none 是否真的能够加速滚动性能，并提出了自己的质疑：</p>
<p>pointer-events:none提高页面滚动时候的绘制性能？</p>
<p>结论见仁见智，使用 pointer-events: none 的场合要依据业务本身来定夺，拒绝拿来主义，多去源头看看，动手实践一番再做定夺。</p>
<p>转自：<a href="https://www.cnblogs.com/coco1s/p/5499469.html" target="_blank" rel="noopener">https://www.cnblogs.com/coco1s/p/5499469.html</a></p>
]]></content>
  </entry>
  <entry>
    <title>es6语法</title>
    <url>/2018/11/08/es6%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h1><h2 id="for-in-遍历数组下标"><a href="#for-in-遍历数组下标" class="headerlink" title="for in 遍历数组下标"></a>for in 遍历数组下标</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function add(...values) &#123;</span><br><span class="line">  let sum = 0;</span><br><span class="line">console.log(values);</span><br><span class="line">  for (var val in values) &#123;console.log(val);</span><br><span class="line">    sum += values[val];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="for-of-遍历数组值"><a href="#for-of-遍历数组值" class="headerlink" title="for of 遍历数组值"></a>for of 遍历数组值</h2><p>##es6之扩展运算符 三个点（…）<br>对象的扩展运算符<br>理解对象的扩展运算符其实很简单，只要记住一句话就可以：</p>
<p>对象中的扩展运算符(…)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let bar = &#123; a: 1, b: 2 &#125;;</span><br><span class="line">let baz = &#123; ...bar &#125;; // &#123; a: 1, b: 2 &#125;</span><br><span class="line"></span><br><span class="line">上述方法实际上等价于:</span><br><span class="line"></span><br><span class="line">let bar = &#123; a: 1, b: 2 &#125;;</span><br><span class="line">let baz = Object.assign(&#123;&#125;, bar); // &#123; a: 1, b: 2 &#125;</span><br></pre></td></tr></table></figure></p>
<p>Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。</p>
<p>Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。(如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性)。</p>
<p>同样，如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let bar = &#123;a: 1, b: 2&#125;;</span><br><span class="line">let baz = &#123;...bar, ...&#123;a:2, b: 4&#125;&#125;;  // &#123;a: 2, b: 4&#125;</span><br></pre></td></tr></table></figure></p>
<p>利用上述特性就可以很方便的修改对象的部分属性。在redux中的reducer函数规定必须是一个纯函数（如果不是很清楚什么是纯函数的可以参考这里），reducer中的state对象要求不能直接修改，可以通过扩展运算符把修改路径的对象都复制一遍，然后产生一个新的对象返回。</p>
<p>这里有点需要注意的是扩展运算符对对象实例的拷贝属于一种浅拷贝。肯定有人要问什么是浅拷贝？我们知道javascript中有两种数据类型，分别是基础数据类型和引用数据类型。基础数据类型是按值访问的，常见的基础数据类型有Number、String、Boolean、Null、Undefined，这类变量的拷贝的时候会完整的复制一份；引用数据类型比如Array，在拷贝的时候拷贝的是对象的引用，当原对象发生变化的时候，拷贝对象也跟着变化，比如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let obj1 = &#123; a: 1, b: 2&#125;;</span><br><span class="line">let obj2 = &#123; ...obj1, b: &apos;2-edited&apos;&#125;;</span><br><span class="line">console.log(obj1); // &#123;a: 1, b: 2&#125;</span><br><span class="line">console.log(obj2); //  &#123;a: 1, b: &quot;2-edited&quot;&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面这个例子扩展运算符拷贝的对象是基础数据类型，因此对obj2的修改并不会影响obj1，如果改成这样：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let obj1 = &#123; a: 1, b: 2, c: &#123;nickName: &apos;d&apos;&#125;&#125;;</span><br><span class="line">let obj2 = &#123; ...obj1&#125;;</span><br><span class="line">obj2.c.nickName = &apos;d-edited&apos;;</span><br><span class="line">console.log(obj1); // &#123;a: 1, b: 2, c: &#123;nickName: &apos;d-edited&apos;&#125;&#125;</span><br><span class="line">console.log(obj2); // &#123;a: 1, b: 2, c: &#123;nickName: &apos;d-edited&apos;&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里可以看到，对obj2的修改影响到了被拷贝对象obj1，原因上面已经说了，因为obj1中的对象c是一个引用数据类型，拷贝的时候拷贝的是对象的引用。</p>
<p>数组的扩展运算符<br>扩展运算符同样可以运用在对数组的操作中。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">可以将数组转换为参数序列</span><br><span class="line">function add(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const numbers = [4, 38];</span><br><span class="line">add(...numbers) // 42</span><br><span class="line"></span><br><span class="line">可以复制数组</span><br><span class="line">如果直接通过下列的方式进行数组复制是不可取的：</span><br><span class="line"></span><br><span class="line">const arr1 = [1, 2];</span><br><span class="line">const arr2 = arr1;</span><br><span class="line">arr2[0] = 2;</span><br><span class="line">arr1 // [2, 2]</span><br><span class="line"></span><br><span class="line">原因上面已经介绍过，用扩展运算符就很方便：</span><br><span class="line"></span><br><span class="line">const arr1 = [1, 2];</span><br><span class="line">const arr2 = [...arr1];</span><br><span class="line"></span><br><span class="line">还是记住那句话：扩展运算符(…)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中，这里参数对象是个数组，数组里面的所有对象都是基础数据类型，将所有基础数据类型重新拷贝到新的数组中。</span><br><span class="line"></span><br><span class="line">扩展运算符可以与解构赋值结合起来，用于生成数组</span><br><span class="line">const [first, ...rest] = [1, 2, 3, 4, 5];</span><br><span class="line">first // 1</span><br><span class="line">rest  // [2, 3, 4, 5]</span><br><span class="line"></span><br><span class="line">需要注意的一点是：</span><br><span class="line"></span><br><span class="line">如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</span><br><span class="line"></span><br><span class="line">const [...rest, last] = [1, 2, 3, 4, 5];</span><br><span class="line">// 报错</span><br><span class="line">const [first, ...rest, last] = [1, 2, 3, 4, 5];</span><br><span class="line">// 报错</span><br><span class="line"></span><br><span class="line">扩展运算符还可以将字符串转为真正的数组</span><br><span class="line">[...&apos;hello&apos;]</span><br><span class="line">// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">任何 Iterator 接口的对象（参阅 Iterator 一章），都可以用扩展运算符转为真正的数组</span><br><span class="line">这点说的比较官方，大家具体可以参考阮一峰老师的ECMAScript 6入门教程。</span><br><span class="line"></span><br><span class="line">比较常见的应用是可以将某些数据结构转为数组,比如：</span><br><span class="line"></span><br><span class="line">// arguments对象</span><br><span class="line">function foo() &#123;</span><br><span class="line">  const args = [...arguments];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>用于替换es5中的Array.prototype.slice.call(arguments)写法。</p>
<h1 id="promise-和-generator"><a href="#promise-和-generator" class="headerlink" title="promise 和 generator"></a>promise 和 generator</h1><p>function firstPromise(){<br>  return new Promise(function(resolve,reject){<br>       setTimeout(function(){<br>         resolve(“this is data”);<br>       },5000);<br>  });<br>}</p>
<p>function *foo() {<br>    var x = 1 + (yield firstPromise);<br>    console.log(x+”one”);<br>}<br>var action=foo();<br>var abc=action.next().value;</p>
<p>abc().then(function(data){console.log(data)});<br>var firstObj=action.next(10);<br>console.log(firstObj.value,firstObj)</p>
<h1 id="promise-搭配-async-function"><a href="#promise-搭配-async-function" class="headerlink" title="promise 搭配 async function"></a>promise 搭配 async function</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> callbackResolve=<span class="function"><span class="params">()</span>=&gt;</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">redireact</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>)=&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">  callbackResolve=resolve;</span><br><span class="line">&#125;);</span><br><span class="line">  <span class="comment">//如果不执行 callbackResolve，后面的log 代码就被暂停了</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"in"</span>);</span><br><span class="line">&#125;</span><br><span class="line">redireact();</span><br><span class="line">callbackResolve();</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>es6</category>
      </categories>
  </entry>
</search>
